<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SVG Drawing App (Ref Image Controls)</title>
    <style>
        /* CSS variables for theming */
        :root {
            --bg-main: #f3f4f6;
            --bg-panel: #ffffff;
            --bg-canvas: #ffffff;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --accent-color: #4f46e5;
            --accent-hover: #4338ca;
            --border-color: #d1d5db;
        }

        /* Generated TailwindCSS bundle for offline use */
        *,
        ::before,
        ::after {
            box-sizing: border-box;
            border-width: 0;
            border-style: solid;
            border-color: #e5e7eb;
        }

        html {
            line-height: 1.5;
            -webkit-text-size-adjust: 100%;
            -moz-tab-size: 4;
            tab-size: 4;
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }

        body {
            margin: 0;
            line-height: inherit;
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            background-color: var(--bg-main);
            color: var(--text-primary);
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        input,
        textarea {
            user-select: text;
            -webkit-user-select: text;
        }

        h1,
        h3,
        p,
        label {
            margin: 0;
        }

        button {
            color: inherit;
            padding: 0;
            background-color: transparent;
            background-image: none;
            cursor: pointer;
        }

        input:not([type='range']):not([type='color']),
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: #fff;
            border-color: #6b7280;
            border-width: 1px;
            border-radius: 0.375rem;
            padding: .5rem .75rem;
            font-size: 1rem;
            line-height: 1.5rem;
            width: 100%;
        }

        select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%c/svg%3e");
            background-position: right .5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }

        svg {
            display: block;
        }

        /* General App Styles */
        #svg-canvas {
            touch-action: none;
            cursor: crosshair;
            border-radius: 0.75rem;
            -webkit-tap-highlight-color: transparent;
            will-change: transform;
            /* Performance optimization */
        }

        #marching-ants-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Allows clicks to pass through to the SVG */
            z-index: 20;
        }

        /* Reference Preview Image Overlay */
        #reference-preview-image {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            /* Changed from 5 to show above reference image (z-index 10) */
            opacity: 0.8;
            border: 2px dashed rgba(79, 70, 229, 0.5);
            box-sizing: border-box;
        }

        #reference-preview-image.visible {
            pointer-events: all;
        }

        #reference-preview-image.moving {
            cursor: move;
        }

        /* MODIFICATION: Fullscreen Sidebar Logic */
        /* Sidebar is now always an overlay, matching "full screen canvas" request */
        #sidebar {
            transform: translateX(-100%);
            position: fixed;
            top: 0;
            bottom: 0;
            height: 100vh;
            z-index: 50;
            transition: transform 0.3s ease-in-out, width 0.3s ease-in-out;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.05);
            -webkit-overflow-scrolling: touch;
        }

        #sidebar.open {
            transform: translateX(0);
        }

        #sidebar-backdrop {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 40;
            transition: opacity 0.3s ease-in-out;
        }

        /* END MODIFICATION */

        #sidebar.hidden {
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        .control-section details[open] summary {
            color: var(--accent-color);
        }

        .tool-btn {
            border: 2px solid transparent;
        }

        .tool-btn.active {
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tool-btn.active svg {
            stroke: white;
        }

        .tool-btn#edit-color-ref-btn.active {
            background-color: #fca5a5;
            /* red-300 */
            color: #b91c1c;
            /* red-700 */
            border-color: #ef4444;
            /* red-500 */
        }

        .tool-btn#edit-color-ref-btn.active:hover {
            background-color: #f87171;
            /* red-400 */
        }

        .color-swatch.active {
            transform: scale(1.15);
            box-shadow: 0 0 0 3px var(--accent-color), 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 5;
            border-color: var(--accent-color);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        #stroke-width-value,
        #stroke-opacity-value,
        /* NEW */
        #stroke-blur-value

        /* NEW */
            {
            min-width: 40px;
            text-align: right;
            font-weight: 600;
        }

        #zoom-slider {
            width: 10rem;
        }

        #zoom-slider-container {
            backdrop-filter: blur(4px);
            background-color: rgba(255, 255, 255, 0.7);
        }

        .toggle-label {
            position: relative;
            display: inline-flex;
            align-items: center;
            cursor: pointer;
        }

        .toggle-label.disabled {
            cursor: not-allowed;
        }

        .toggle-label.disabled .toggle-div {
            background-color: #e5e7eb;
            opacity: 0.7;
        }

        .toggle-label input {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .toggle-label .toggle-div {
            width: 2.75rem;
            height: 1.5rem;
            background-color: #e5e7eb;
            border-radius: 9999px;
            transition: background-color 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle-label .toggle-div::after {
            content: '';
            position: absolute;
            top: 0.125rem;
            left: 2px;
            background-color: #ffffff;
            border-color: #d1d5db;
            border-width: 1px;
            border-radius: 9999px;
            height: 1.25rem;
            width: 1.25rem;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle-label input:checked~.toggle-div {
            background-color: var(--accent-color);
        }

        .toggle-label input:checked~.toggle-div::after {
            transform: translateX(100%);
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Gradient Backgrounds */
        .bg-gradient-to-r {
            background-image: linear-gradient(to right, var(--tw-gradient-stops));
        }

        .from-indigo-500 {
            --tw-gradient-from: #6366f1;
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(99, 102, 241, 0));
        }

        .to-purple-600 {
            --tw-gradient-to: #9333ea;
        }

        .hover\:from-indigo-600:hover {
            --tw-gradient-from: #4f46e5;
        }

        .hover\:to-purple-700:hover {
            --tw-gradient-to: #7e22ce;
        }

        /* Amber Colors for Profiles */
        .bg-amber-100 {
            background-color: #fef3c7;
        }

        .bg-amber-200 {
            background-color: #fde68a;
        }

        .text-amber-700 {
            color: #b45309;
        }

        .border-amber-300 {
            border-color: #fcd34d;
        }

        .hover\:bg-amber-200:hover {
            background-color: #fde68a;
        }

        /* Green Colors for Profile Create */
        .bg-green-100 {
            background-color: #dcfce7;
        }

        .text-green-700 {
            color: #15803d;
        }

        .border-green-300 {
            border-color: #86efac;
        }

        .hover\:bg-green-200:hover {
            background-color: #bbf7d0;
        }

        /* Indigo Colors */
        .bg-indigo-600 {
            background-color: #4f46e5;
        }

        .hover\:bg-indigo-700:hover {
            background-color: #4338ca;
        }

        .toast {
            transition: opacity 0.3s, transform 0.3s;
        }

        #toast-notification {
            pointer-events: none;
        }

        #toast-notification.opacity-0 {
            display: none !important;
            transform: translateX(200%) !important;
        }

        #projects-modal.flex {
            backdrop-filter: blur(4px);
        }

        #projects-modal .projects-panel {
            width: 100%;
            max-width: 640px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .project-list-message {
            padding: 0.75rem;
            text-align: left;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .project-list {
            display: flex;
            flex-direction: column;
        }

        .project-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            border-radius: 0;
            background-color: transparent;
            transition: background-color 0.15s ease;
        }

        .project-item:hover {
            background-color: #f9fafb;
        }

        .project-meta {
            flex: 1;
            min-width: 0;
        }

        .project-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .project-updated {
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Project Selection Styles */
        .project-checkbox {
            width: 20px;
            height: 20px;
            min-width: 20px;
            margin-right: 0.75rem;
            cursor: pointer;
            accent-color: var(--accent-color);
            display: none;
        }

        .selection-mode .project-checkbox {
            display: block;
        }

        .project-item.selected {
            background-color: #e5e7eb;
        }

        .delete-selected-container {
            display: none;
            padding: 0.5rem 0.75rem;
            background: #f9fafb;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
            align-items: center;
            justify-content: space-between;
        }

        .selection-mode .delete-selected-container {
            display: flex;
        }

        .delete-selected-btn {
            background-color: #e5e7eb;
            color: #111827;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-weight: 400;
            font-size: 0.85rem;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .delete-selected-btn:hover {
            background-color: #d1d5db;
        }

        .delete-selected-btn:disabled {
            background-color: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
        }

        .selection-mode .project-actions {
            display: none;
        }

        .project-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            justify-content: flex-end;
        }

        .project-action-btn {
            border-radius: 0.25rem;
            font-size: 0.85rem;
            font-weight: 400;
            padding: 0.25rem 0.75rem;
            border: 1px solid var(--border-color);
            background-color: #f9fafb;
            color: #111827;
            transition: background-color 0.15s ease;
        }

        .project-action-btn.primary {
            background-color: #e5e7eb;
            color: #111827;
        }

        .project-action-btn.ghost {
            background-color: transparent;
            color: var(--text-secondary);
        }

        .project-action-btn.danger {
            background-color: #fef2f2;
            color: #b91c1c;
            border-color: #fecaca;
        }

        .project-action-btn:hover {
            background-color: #e5e7eb;
        }

        .bg-red-50 {
            background-color: #fef2f2;
        }

        .border-red-300 {
            border-color: #fca5a5;
        }

        /* NEW: Styles for canvas undo/redo buttons */
        #canvas-undo-redo-container {
            position: absolute;
            bottom: 1rem;
            /* bottom-4 */
            right: 1rem;
            /* right-4 */
            z-index: 20;
            display: flex;
            gap: 0.5rem;
            /* gap-2 */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }

        #canvas-undo-redo-container.visible {
            opacity: 0.6;
            pointer-events: all;
        }

        /* Make undo/redo more visible on touch devices */
        @media (hover: none) and (pointer: coarse) {
            #canvas-undo-redo-container.visible {
                opacity: 0.85;
            }
        }

        /* END NEW STYLES */

        /* MODIFICATION: Floating Wand Toggle Button */
        #wand-toggle-btn {
            position: absolute;
            z-index: 30;
            padding: 0.75rem;
            background-color: rgba(79, 70, 229, 0.7);
            color: white;
            border-radius: 50%;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: opacity 0.2s, top 0.1s, left 0.1s;
            pointer-events: none;
            opacity: 0;
        }

        #wand-toggle-btn.visible {
            pointer-events: all;
            opacity: 0.7;
            cursor: grab;
        }

        #wand-toggle-btn.visible.dragging {
            cursor: grabbing;
        }

        /* Make wand toggle more visible and larger on touch devices */
        @media (hover: none) and (pointer: coarse) {
            #wand-toggle-btn {
                padding: 1rem;
            }

            #wand-toggle-btn.visible {
                opacity: 0.85;
            }
        }

        #wand-toggle-btn:hover {
            opacity: 1;
            background-color: var(--accent-color);
        }

        .canvas-history-btn {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: #374151;
            transition: all 0.2s;
        }

        /* Larger history buttons for touch devices */
        @media (hover: none) and (pointer: coarse) {
            .canvas-history-btn {
                padding: 0.75rem;
                min-width: 48px;
                min-height: 48px;
            }
        }

        .canvas-history-btn:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            opacity: 1;
        }

        .canvas-history-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background-color: rgba(243, 244, 246, 0.7);
        }

        /* --- NEW: Floating History (Undo/Redo) Styles - Moved near color palette --- */
        #wand-history-container {
            position: absolute;
            bottom: 1rem;
            left: 11rem;
            z-index: 30;
            opacity: 0;
            pointer-events: none;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            display: flex;
            gap: 0.5rem;
            /* gap-2 */
            transform: translateY(10px);
        }

        #wand-history-container.visible {
            opacity: 0.7;
            pointer-events: all;
            transform: translateY(0);
        }

        /* Make wand history more visible on touch devices */
        @media (hover: none) and (pointer: coarse) {
            #wand-history-container.visible {
                opacity: 0.85;
            }
        }

        #wand-history-container:hover {
            opacity: 1;
        }

        /* Position near color palette when palette is visible */
        #floating-color-palette-container.visible~#wand-history-container,
        #floating-color-palette-container.visible+* #wand-history-container {
            left: calc(11rem + 340px);
        }

        /* --- END NEW STYLES --- */

        /* Tool Shortcut Icons - PERMANENTLY VISIBLE */
        #tool-shortcuts-container {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 30;
            /* Behind sidebar (50) but above canvas */
            display: flex;
            gap: 0.5rem;
            opacity: 1 !important;
            /* Always fully visible */
            transition: none;
            visibility: visible !important;
        }

        #tool-shortcuts-container:hover {
            opacity: 1 !important;
        }

        /* Make tool shortcuts always visible on all devices */
        @media (hover: none) and (pointer: coarse) {
            #tool-shortcuts-container {
                opacity: 1 !important;
                display: flex !important;
                visibility: visible !important;
            }
        }

        @media (max-width: 768px) {
            #tool-shortcuts-container {
                opacity: 1 !important;
                display: flex !important;
                visibility: visible !important;
                z-index: 30;
            }
        }

        .tool-shortcut-btn {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: #374151;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            /* Prevent double-tap zoom on mobile */
            -webkit-tap-highlight-color: transparent;
            /* Remove tap highlight */
            user-select: none;
            /* Prevent text selection */
        }

        /* Larger buttons for touch devices */
        @media (hover: none) and (pointer: coarse) {
            .tool-shortcut-btn {
                width: 48px;
                height: 48px;
                padding: 0.75rem;
            }
        }

        .tool-shortcut-btn:hover {
            background-color: rgba(255, 255, 255, 1);
            opacity: 1;
        }

        .tool-shortcut-btn.active {
            background-color: var(--accent-color);
            color: white;
            opacity: 0.9;
        }

        /* Stroke width control in bottom left */
        .bottom-left-stroke-width-container {
            position: fixed;
            bottom: 1rem;
            left: calc(1rem + 6 * 40px + 6 * 0.5rem);
            /* Position before undo/redo */
            z-index: 30;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.25rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            opacity: 1 !important;
            visibility: visible !important;
        }

        .bottom-left-stroke-btn {
            background: transparent;
            border: none;
            border-radius: 0.25rem;
            padding: 0.25rem;
            cursor: pointer;
            color: #374151;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .bottom-left-stroke-btn:hover:not(:disabled) {
            background-color: rgba(55, 71, 91, 0.1);
        }

        .bottom-left-stroke-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .bottom-left-stroke-value {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            min-width: 32px;
            text-align: center;
            pointer-events: none;
        }

        @media (hover: none) and (pointer: coarse) {
            .bottom-left-stroke-btn {
                width: 36px;
                height: 36px;
                padding: 0.5rem;
            }
        }

        /* Undo/Redo buttons next to tool shortcuts - PERMANENTLY VISIBLE */
        #bottom-left-undo-redo-container {
            position: fixed;
            bottom: 1rem;
            left: calc(1rem + 6 * 40px + 6 * 0.5rem + 3 * 32px + 3 * 0.25rem + 0.5rem + 32px + 0.5rem);
            /* Position after stroke width control */
            z-index: 30;
            /* Behind sidebar (50) but above canvas */
            display: flex;
            gap: 0.5rem;
            opacity: 1 !important;
            visibility: visible !important;
        }

        .bottom-left-history-btn {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: #374151;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            border: none;
            cursor: pointer;
        }

        .bottom-left-history-btn:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 1);
        }

        .bottom-left-history-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        @media (hover: none) and (pointer: coarse) {
            .bottom-left-history-btn {
                width: 48px;
                height: 48px;
                padding: 0.75rem;
            }
        }

        /* Fullscreen button */
        #fullscreen-btn {
            position: fixed;
            bottom: 1rem;
            left: calc(1rem + 6 * 40px + 6 * 0.5rem + 3 * 32px + 3 * 0.25rem + 0.5rem + 32px + 0.5rem + 2 * 40px + 2 * 0.5rem);
            /* Position after undo/redo (tool shortcuts + stroke width + undo/redo) */
            z-index: 30;
            /* Behind sidebar (50) but above canvas */
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: #374151;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 1 !important;
            visibility: visible !important;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            border: none;
        }

        #fullscreen-btn:hover {
            background-color: rgba(255, 255, 255, 1);
        }

        #fullscreen-btn.active {
            background-color: var(--accent-color);
            color: white;
        }

        @media (hover: none) and (pointer: coarse) {
            #fullscreen-btn {
                width: 48px;
                height: 48px;
                padding: 0.75rem;
            }
        }

        /* --- NEW: Floating Color Palette Panel Styles --- */
        #floating-color-palette-container {
            position: fixed;
            bottom: 1rem;
            left: calc(1rem + 6 * 40px + 6 * 0.5rem + 2 * 40px + 2 * 0.5rem + 40px + 0.5rem + 40px + 0.5rem);
            /* Position to the right of palette toggle (tool shortcuts + undo/redo + fullscreen + palette toggle) */
            z-index: 30;
            /* Behind sidebar (50) but above canvas */
            opacity: 0;
            pointer-events: none;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(10px);
            min-width: 280px;
            max-width: 320px;
        }

        #floating-color-palette-container.visible {
            opacity: 1;
            pointer-events: all;
            transform: translateY(0);
            z-index: 60;
            /* Ensure it's above sidebar */
        }

        #floating-color-palette-toggle {
            position: fixed;
            bottom: 1rem;
            left: calc(1rem + 6 * 40px + 6 * 0.5rem + 2 * 40px + 2 * 0.5rem + 40px + 0.5rem);
            /* Position after fullscreen button (tool shortcuts + undo/redo + fullscreen) */
            z-index: 30;
            /* Behind sidebar (50) but above canvas */
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: #374151;
            transition: all 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 1 !important;
            /* Always visible */
            display: flex !important;
            /* Always visible */
            visibility: visible !important;
            touch-action: manipulation;
            /* Prevent double-tap zoom on mobile */
            -webkit-tap-highlight-color: transparent;
            /* Remove tap highlight */
            user-select: none;
            /* Prevent text selection */
        }

        /* Ensure palette toggle is always visible on mobile/tablet */
        @media (hover: none) and (pointer: coarse) {
            #floating-color-palette-toggle {
                opacity: 1 !important;
                display: flex !important;
                visibility: visible !important;
            }
        }

        @media (max-width: 768px) {
            #floating-color-palette-toggle {
                opacity: 1 !important;
                display: flex !important;
                visibility: visible !important;
                z-index: 30;
            }
        }

        /* Adjust positions for mobile/tablet - all buttons in bottom left */
        @media (max-width: 768px) {
            #tool-shortcuts-container {
                left: 0.5rem !important;
                bottom: 0.5rem !important;
            }

            #bottom-left-undo-redo-container {
                left: calc(0.5rem + 6 * 48px + 6 * 0.5rem) !important;
                bottom: 0.5rem !important;
            }

            #fullscreen-btn {
                left: calc(0.5rem + 6 * 48px + 6 * 0.5rem + 2 * 48px + 2 * 0.5rem) !important;
                bottom: 0.5rem !important;
                width: 48px;
                height: 48px;
                padding: 0.75rem;
            }

            #floating-color-palette-toggle {
                left: calc(0.5rem + 6 * 48px + 6 * 0.5rem + 2 * 48px + 2 * 0.5rem + 48px + 0.5rem) !important;
                bottom: 0.5rem !important;
                width: 48px;
                height: 48px;
                padding: 0.75rem;
            }

            #floating-color-palette-container {
                left: 0.5rem !important;
                bottom: calc(0.5rem + 48px + 0.5rem);
                /* Above the buttons */
                min-width: 260px;
                max-width: calc(100vw - 1rem);
            }

            #wand-history-container {
                left: 0.5rem;
                bottom: calc(0.5rem + 48px + 0.5rem);
            }

            #floating-color-palette-container.visible~#wand-history-container,
            #floating-color-palette-container.visible+* #wand-history-container {
                left: calc(0.5rem + 280px);
                bottom: calc(0.5rem + 48px + 0.5rem);
            }
        }

        @media (max-width: 480px) {
            #tool-shortcuts-container {
                left: 0.5rem !important;
                bottom: 0.5rem !important;
            }

            #bottom-left-undo-redo-container {
                left: calc(0.5rem + 6 * 48px + 6 * 0.5rem) !important;
                bottom: 0.5rem !important;
            }

            #fullscreen-btn {
                left: calc(0.5rem + 4 * 48px + 4 * 0.5rem + 2 * 48px + 2 * 0.5rem) !important;
                bottom: 0.5rem !important;
            }

            #floating-color-palette-toggle {
                left: calc(0.5rem + 4 * 48px + 4 * 0.5rem + 2 * 48px + 2 * 0.5rem + 48px + 0.5rem) !important;
                bottom: 0.5rem !important;
            }

            #floating-color-palette-container {
                left: 0.5rem !important;
                bottom: calc(0.5rem + 48px + 0.5rem);
                min-width: calc(100vw - 1rem);
                max-width: calc(100vw - 1rem);
            }

            #wand-history-container {
                left: 0.5rem;
                bottom: calc(0.5rem + 48px + 0.5rem);
            }

            #canvas-undo-redo-container {
                right: 0.5rem;
                bottom: 0.5rem;
            }
        }

        /* For touch devices (tablets/mobile Chrome) */
        @media (hover: none) and (pointer: coarse) {
            #tool-shortcuts-container {
                left: 0.5rem !important;
                bottom: 0.5rem !important;
            }

            #bottom-left-undo-redo-container {
                left: calc(0.5rem + 4 * 48px + 4 * 0.5rem) !important;
                bottom: 0.5rem !important;
            }

            #fullscreen-btn {
                left: calc(0.5rem + 4 * 48px + 4 * 0.5rem + 2 * 48px + 2 * 0.5rem) !important;
                bottom: 0.5rem !important;
            }

            #floating-color-palette-toggle {
                left: calc(0.5rem + 4 * 48px + 4 * 0.5rem + 2 * 48px + 2 * 0.5rem + 48px + 0.5rem) !important;
                bottom: 0.5rem !important;
            }
        }

        #floating-color-palette-toggle:hover {
            background-color: rgba(255, 255, 255, 1);
            opacity: 1;
        }

        #floating-color-palette-toggle.active {
            background-color: var(--accent-color);
            color: white;
        }

        .floating-palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .floating-palette-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .floating-palette-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.25rem;
        }

        .floating-palette-close:hover {
            background-color: rgba(0, 0, 0, 0.05);
            color: var(--text-primary);
        }

        .floating-custom-color-section {
            margin-bottom: 1rem;
        }

        .floating-custom-color-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: block;
        }

        .floating-custom-color-input {
            width: 100%;
            height: 40px;
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
        }

        .floating-custom-color-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .floating-custom-color-input::-webkit-color-swatch {
            border: none;
            border-radius: 0.375rem;
        }

        .floating-palette-colors {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.5rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        /* Show more colors on mobile/tablet */
        @media (max-width: 768px) {
            .floating-palette-colors {
                grid-template-columns: repeat(10, 1fr);
                gap: 0.4rem;
                max-height: 70vh;
            }
        }

        @media (max-width: 480px) {
            .floating-palette-colors {
                grid-template-columns: repeat(8, 1fr);
                gap: 0.35rem;
            }
        }

        /* For touch devices */
        @media (hover: none) and (pointer: coarse) {
            .floating-palette-colors {
                grid-template-columns: repeat(10, 1fr);
                gap: 0.4rem;
                max-height: 70vh;
            }

            @media (max-width: 480px) {
                .floating-palette-colors {
                    grid-template-columns: repeat(8, 1fr);
                }
            }
        }

        .floating-color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 0.375rem;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .floating-color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 1;
        }

        .floating-color-swatch.active {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-color), 0 2px 8px rgba(0, 0, 0, 0.3);
            transform: scale(1.15);
            z-index: 2;
        }

        /* Multi-Wand Toggle Active State */
        #multi-wand-toggle.active {
            background-color: var(--accent-color);
            color: white;
        }

        #multi-wand-toggle.active .text-gray-600 {
            color: white !important;
        }

        /* --- NEW: Selection Pencil Slider Styles (moved to sidebar) --- */
        #wand-pencil-slider-container {
            display: none;
            /* Hidden by default, shown when selection is active */
        }

        #wand-pencil-slider-container.visible {
            display: block;
            /* Show when selection is active */
        }

        #wand-pencil-slider-container input[type="range"] {
            width: 100%;
            flex-grow: 1;
        }

        #wand-pencil-slider-value {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .wand-pencil-adj-btn {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 9999px;
            /* rounded-full */
            padding: 0.25rem;
            /* p-1 */
            line-height: 1;
            color: var(--text-primary);
            flex-shrink: 0;
        }

        .wand-pencil-adj-btn:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        #wand-shrink-slider-value {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 28px;
            text-align: right;
        }

        /* --- END NEW STYLES --- */

        /* --- RIGHT COLOR PALETTE --- */
        #right-side-palette-wrapper {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%) translateX(0);
            z-index: 45;
            transition: transform 0.3s ease-in-out;
            display: flex;
            align-items: center;
        }

        #right-side-palette-wrapper.collapsed {
            transform: translateY(-50%) translateX(100%);
        }

        #right-palette-toggle {
            position: absolute;
            left: -40px;
            width: 40px;
            height: 48px;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border: 1px solid var(--border-color);
            border-right: none;
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: background-color 0.2s, color 0.2s;
        }

        #right-palette-toggle:hover {
            color: var(--accent-color);
            background-color: white;
        }

        #right-side-palette {
            width: auto;
            max-height: 90vh;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            padding: 0.5rem;
            overflow-y: auto;
            overflow-x: hidden;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.35rem;
            border-left: 1px solid var(--border-color);
        }

        .right-color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .right-color-swatch:hover {
            transform: scale(1.15);
            z-index: 2;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .right-color-swatch.active {
            transform: scale(1.2);
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-color);
            z-index: 3;
        }

        /* --- END RIGHT COLOR PALETTE --- */

        /* Utility Classes (Mini-Tailwind) */
        .absolute {
            position: absolute;
        }

        .relative {
            position: relative;
        }

        .fixed {
            position: fixed;
        }

        .inset-0 {
            top: 0px;
            right: 0px;
            bottom: 0px;
            left: 0px;
        }

        ._right-2 {
            right: -0.5rem;
        }

        .top-4 {
            top: 1rem;
        }

        .right-4 {
            right: 1rem;
        }

        /* NEW */
        .bottom-4 {
            bottom: 1rem;
        }

        .left-1\/2 {
            left: 50%;
        }

        .top-0 {
            top: 0px;
        }

        .left-0 {
            left: 0px;
        }

        .top-0\.5 {
            top: 0.125rem;
        }

        .left-\[2px\] {
            left: 2px;
        }

        .z-2 {
            z-index: 2;
        }

        .z-5 {
            z-index: 5;
        }

        .z-10 {
            z-index: 10;
        }

        .z-20 {
            z-index: 20;
        }

        .z-30 {
            z-index: 30;
        }

        .z-40 {
            z-index: 40;
        }

        .z-50 {
            z-index: 50;
        }

        .z-60 {
            z-index: 60;
        }

        .z-70 {
            z-index: 70;
        }

        .m-1 {
            margin: 0.25rem;
        }

        .mr-1 {
            margin-right: 0.25rem;
        }

        .mt-1 {
            margin-top: 0.5rem;
        }

        .mt-2 {
            margin-top: 0.5rem;
        }

        .mr-2 {
            margin-right: 0.5rem;
        }

        .mr-4 {
            margin-right: 1rem;
        }

        .mt-6 {
            margin-top: 1.5rem;
        }

        .mt-2 {
            margin-top: 0.5rem;
        }

        .mb-1 {
            margin-bottom: 0.25rem;
        }

        .mb-4 {
            margin-bottom: 1rem;
        }

        .pb-3 {
            padding-bottom: 0.75rem;
        }

        .pb-4 {
            padding-bottom: 1rem;
        }

        .block {
            display: block;
        }

        .inline-flex {
            display: inline-flex;
        }

        .flex {
            display: flex;
        }

        .grid {
            display: grid;
        }

        .hidden {
            display: none;
        }

        .h-5 {
            height: 1.25rem;
        }

        .w-5 {
            width: 1.25rem;
        }

        .h-6 {
            height: 1.5rem;
        }

        .w-6 {
            width: 1.5rem;
        }

        .h-8 {
            height: 2rem;
        }

        .w-11 {
            width: 2.75rem;
        }

        .h-full {
            height: 100%;
        }

        .w-full {
            width: 100%;
        }

        .h-screen {
            height: 100vh;
        }

        .w-40 {
            width: 10rem;
        }

        .w-80 {
            width: 20rem;
        }

        .max-w-md {
            max-width: 28rem;
        }

        .max-w-sm {
            max-width: 24rem;
        }

        .max-w-2xl {
            max-width: 42rem;
        }

        .min-w-0 {
            min-width: 0;
        }

        .flex-shrink-0 {
            flex-shrink: 0;
        }

        .flex-1 {
            flex: 1 1 0%;
        }

        .flex-grow {
            flex-grow: 1;
        }

        .translate-x-full {
            transform: translateX(100%);
        }

        .translate-y-full {
            transform: translateY(100%);
        }

        .-translate-x-1\/2 {
            transform: translateX(-50%);
        }

        .flex-col {
            flex-direction: column;
        }

        .flex-wrap {
            flex-wrap: wrap;
        }

        .items-center {
            align-items: center;
        }

        .justify-center {
            justify-content: center;
        }

        .justify-end {
            justify-content: flex-end;
        }

        .justify-between {
            justify-content: space-between;
        }

        .gap-1 {
            gap: 0.25rem;
        }

        .gap-2 {
            gap: 0.5rem;
        }

        .space-x-1> :not([hidden])~ :not([hidden]) {
            margin-right: 0;
            margin-left: 0.25rem;
        }

        .space-x-2> :not([hidden])~ :not([hidden]) {
            margin-right: 0;
            margin-left: 0.5rem;
        }

        .space-x-3> :not([hidden])~ :not([hidden]) {
            margin-right: 0;
            margin-left: 0.75rem;
        }

        .space-y-1> :not([hidden])~ :not([hidden]) {
            margin-top: 0.25rem;
            margin-bottom: 0;
        }

        .space-y-2> :not([hidden])~ :not([hidden]) {
            margin-top: 0.5rem;
            margin-bottom: 0;
        }

        .space-y-3> :not([hidden])~ :not([hidden]) {
            margin-top: 0.75rem;
            margin-bottom: 0;
        }

        .space-y-4> :not([hidden])~ :not([hidden]) {
            margin-top: 1rem;
            margin-bottom: 0;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        .overflow-y-auto {
            overflow-y: auto;
        }

        .rounded-full {
            border-radius: 9999px;
        }

        .rounded-lg {
            border-radius: 0.5rem;
        }

        .rounded-xl {
            border-radius: 0.75rem;
        }

        .rounded-md {
            border-radius: 0.375rem;
        }

        .rounded {
            border-radius: 0.25rem;
        }

        .border {
            border-width: 1px;
        }

        .border-t {
            border-top-width: 1px;
        }

        .border-b {
            border-bottom-width: 1px;
        }

        .border-2 {
            border-width: 2px;
        }

        .border-gray-200 {
            border-color: #e5e7eb;
        }

        .border-gray-300 {
            border-color: #d1d5db;
        }

        .border-border-color {
            border-color: var(--border-color);
        }

        .border-red-400 {
            border-color: #f87171;
        }

        .border-red-500 {
            border-color: #ef4444;
        }

        .border-green-600 {
            border-color: #16a34a;
        }

        .border-gray-400 {
            border-color: #9ca3af;
        }

        .bg-white {
            background-color: #fff;
        }

        .bg-gray-50\/50 {
            background-color: rgba(249, 250, 251, .5);
        }

        .bg-gray-100 {
            background-color: #f3f4f6;
        }

        .bg-gray-200 {
            background-color: #e5e7eb;
        }

        .bg-gray-800 {
            background-color: #1f2937;
        }

        .bg-gray-900 {
            background-color: #111827;
        }

        .bg-red-50:hover {
            background-color: #fef2f2;
        }

        .bg-red-600 {
            background-color: #dc2626;
        }

        .bg-red-700:hover {
            background-color: #b91c1c;
        }

        .bg-green-600 {
            background-color: #16a34a;
        }

        .bg-green-700:hover {
            background-color: #15803d;
        }

        .bg-panel {
            background-color: var(--bg-panel);
        }

        .bg-bg-main {
            background-color: var(--bg-main);
        }

        .bg-bg-canvas {
            background-color: var(--bg-canvas);
        }

        .bg-accent-color {
            background-color: var(--accent-color);
        }

        .hover\:bg-gray-100:hover {
            background-color: #f3f4f6;
        }

        .hover\:bg-gray-200:hover {
            background-color: #e5e7eb;
        }

        .hover\:bg-accent-hover:hover {
            background-color: var(--accent-hover);
        }

        .hover\:bg-gray-300:hover {
            background-color: #d1d5db;
        }

        .hover\:bg-red-100:hover {
            background-color: #fee2e2;
        }

        .bg-opacity-50 {
            --tw-bg-opacity: 0.5;
            background-color: rgba(255, 255, 255, var(--tw-bg-opacity));
        }

        .bg-opacity-75 {
            --tw-bg-opacity: 0.75;
            background-color: rgba(255, 255, 255, var(--tw-bg-opacity));
        }

        .p-1 {
            padding: 0.25rem;
        }

        .p-2 {
            padding: 0.5rem;
        }

        .p-3 {
            padding: 0.75rem;
        }

        .p-4 {
            padding: 1rem;
        }

        .p-6 {
            padding: 1.5rem;
        }

        .pt-3 {
            padding-top: 0.75rem;
        }

        .pr-2 {
            padding-right: 0.5rem;
        }

        .py-1 {
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
        }

        .py-2 {
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }

        .px-3 {
            padding-left: 0.75rem;
            padding-right: 0.75rem;
        }

        .px-4 {
            padding-left: 1rem;
            padding-right: 1rem;
        }

        .px-5 {
            padding-left: 1.25rem;
            padding-right: 1.25rem;
        }

        .text-center {
            text-align: center;
        }

        .text-sm {
            font-size: 0.875rem;
            line-height: 1.25rem;
        }

        .text-xs {
            font-size: 0.75rem;
            line-height: 1rem;
        }

        .text-lg {
            font-size: 1.125rem;
            line-height: 1.75rem;
        }

        .text-xl {
            font-size: 1.25rem;
            line-height: 1.75rem;
        }

        .font-semibold {
            font-weight: 600;
        }

        .font-bold {
            font-weight: 700;
        }

        .font-medium {
            font-weight: 500;
        }

        .uppercase {
            text-transform: uppercase;
        }

        .leading-6 {
            line-height: 1.5rem;
        }

        .tracking-wider {
            letter-spacing: 0.05em;
        }

        .text-gray-300 {
            color: #d1d5db;
        }

        .text-gray-500 {
            color: #6b7280;
        }

        .text-gray-600 {
            color: #4b5563;
        }

        .text-gray-700 {
            color: #374151;
        }

        .text-gray-800 {
            color: #1f2937;
        }

        .text-gray-900 {
            color: #111827;
        }

        .text-red-500 {
            color: #ef4444;
        }

        .text-red-600 {
            color: #dc2626;
        }

        .text-white {
            color: #fff;
        }

        .text-accent-color {
            color: var(--accent-color);
        }

        .text-secondary {
            color: var(--text-secondary);
        }

        .text-green-600 {
            color: #16a34a;
        }

        .shadow {
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .1), 0 1px 2px -1px rgba(0, 0, 0, .1);
        }

        .shadow-sm {
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, .05);
        }

        .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, .1), 0 4px 6px -4px rgba(0, 0, 0, .1);
        }

        .shadow-inner {
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, .05);
        }

        .outline-none {
            outline: 2px solid transparent;
            outline-offset: 2px;
        }

        .grid-cols-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .grid-cols-3 {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }

        .transition-all {
            transition-property: all;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s;
        }

        .transition-colors {
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s;
        }

        .transition-opacity {
            transition-property: opacity;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s;
        }

        .after\:content-\[\'\'\]::after {
            content: '';
        }

        .after\:absolute::after {
            position: absolute;
        }

        .after\:top-0\.5::after {
            top: 0.125rem;
        }

        .after\:left-\[2px\]::after {
            left: 2px;
        }

        .after\:h-5::after {
            height: 1.25rem;
        }

        .after\:w-5::after {
            width: 1.25rem;
        }

        .after\:transform::after {
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
        }

        .after\:rounded-full::after {
            border-radius: 9999px;
        }

        .after\:border::after {
            border-width: 1px;
        }

        .after\:border-gray-300::after {
            border-color: #d1d5db;
        }

        .after\:bg-white::after {
            background-color: #fff;
        }

        .after\:transition-all::after {
            transition-property: all;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s;
        }

        .pointer-events-none {
            pointer-events: none;
        }

        .cursor-pointer {
            cursor: pointer;
        }

        .cursor-crosshair {
            cursor: crosshair;
        }

        .select-none {
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .disabled\:opacity-50:disabled {
            opacity: .5;
        }

        .disabled\:cursor-not-allowed:disabled {
            cursor: not-allowed;
        }

        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        @media (min-width: 640px) {
            .sm\:inline {
                display: inline;
            }

            .sm\:p-4 {
                padding: 1rem;
            }
        }

        /* MODIFICATION: Removed media queries for sidebar, now global */

        /* Password Protection Modal */
        #passwordModal {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #passwordModal.show {
            opacity: 1;
            visibility: visible;
        }

        .password-card {
            background: #fff;
            padding: 40px;
            border-radius: 16px;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .password-card h2 {
            margin: 0 0 10px 0;
            font-size: 24px;
            color: var(--text-primary);
        }

        .password-card p {
            margin: 0 0 24px 0;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .password-input-group {
            margin-bottom: 20px;
        }

        .password-input-group input {
            width: 100%;
            padding: 12px 16px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            font-size: 16px;
            text-align: center;
            letter-spacing: 2px;
            transition: border-color 0.2s;
        }

        .password-input-group input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .password-input-group input.error {
            border-color: #ef4444;
            animation: shake 0.4s;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-10px);
            }

            75% {
                transform: translateX(10px);
            }
        }

        .password-error {
            color: #ef4444;
            font-size: 13px;
            margin-top: 8px;
            min-height: 20px;
        }

        .password-submit-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .password-submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .password-submit-btn:active {
            transform: translateY(0);
        }

        .password-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
    </style>
</head>

<body class="h-screen overflow-hidden bg-bg-main">
    <!-- Password Protection Modal -->
    <div id="passwordModal">
        <div class="password-card">
            <div class="password-icon"></div>
            <h2>Device Authentication</h2>
            <p>Enter password to access this application</p>
            <div class="password-input-group">
                <input type="password" id="passwordInput" placeholder="Enter password" autocomplete="off"
                    maxlength="10" />
                <div class="password-error" id="passwordError"></div>
            </div>
            <button class="password-submit-btn" id="passwordSubmitBtn">Unlock</button>
        </div>
    </div>

    <div id="main-app-container" class="hidden h-full">
        <!-- MODIFICATION: Sidebar backdrop is now always available -->
        <div id="sidebar-backdrop" class="hidden"></div>

        <aside id="sidebar" class="w-80 bg-panel p-4 space-y-4 overflow-y-auto flex flex-col flex-shrink-0">
            <div class="flex items-center justify-between pb-3 border-b border-border-color">
                <div class="flex items-center space-x-3">
                    <svg class="w-8 h-8 text-accent-color" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M12 20h9" />
                        <path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z" />
                        <path d="m15 5 3 3" />
                    </svg>
                    <h1 class="text-xl font-bold">SVG Draw & Color</h1>
                </div>
                <!-- MODIFICATION: Removed lg:hidden, close button is now always visible inside sidebar -->
                <button id="close-sidebar-btn" class="p-1 rounded-full hover:bg-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="w-6 h-6">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>

            <div class="space-y-3 flex-grow">
                <!-- Project Management -->
                <div class="control-section border border-border-color rounded-lg bg-gray-50/50">
                    <details open>
                        <summary class="p-3 font-semibold cursor-pointer text-sm uppercase tracking-wider select-none">
                            Project</summary>
                        <div class="p-3 border-t border-border-color space-y-3">
                            <div class="text-sm">
                                <span class="font-medium text-gray-600 block mb-1">Current Project:</span>
                                <span id="current-project-name"
                                    class="font-bold text-accent-color truncate block">Untitled Project</span>
                            </div>
                            <div class="grid grid-cols-2 gap-2">
                                <button id="save-project-btn" title="Save current project (Ctrl+S)"
                                    class="w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm flex items-center justify-center space-x-2 disabled:opacity-50"
                                    disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z">
                                        </path>
                                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                        <polyline points="7 3 7 8 15 8"></polyline>
                                    </svg>
                                    <span>Save</span>
                                </button>
                                <button id="manage-projects-btn"
                                    class="w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path
                                            d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z">
                                        </path>
                                    </svg>
                                    <span>Projects</span>
                                </button>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <button id="export-project-btn" title="Export project as file"
                                    class="w-full bg-blue-100 text-blue-800 font-semibold py-2 px-4 rounded-lg hover:bg-blue-200 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="17 8 12 3 7 8"></polyline>
                                        <line x1="12" x2="12" y1="3" y2="15"></line>
                                    </svg>
                                    <span>Export</span>
                                </button>
                                <button id="import-project-btn" title="Import project from file"
                                    class="w-full bg-green-100 text-green-800 font-semibold py-2 px-4 rounded-lg hover:bg-green-200 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                        <polyline points="7 10 12 15 17 10"></polyline>
                                        <line x1="12" x2="12" y1="15" y2="3"></line>
                                    </svg>
                                    <span>Import</span>
                                </button>
                            </div>
                            <input type="file" id="project-file-upload" class="hidden" accept=".json">
                            <div>
                                <label for="autosave-interval" class="text-sm font-medium">Auto-save (sec)</label>
                                <input type="number" id="autosave-interval" min="10" step="5" value="60"
                                    class="w-full mt-1"
                                    title="Set auto-save frequency in seconds. This setting is saved with the project.">
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <button id="clear-cache-btn"
                                    class="w-full bg-orange-100 text-orange-800 font-semibold py-2 px-4 rounded-lg hover:bg-orange-200 transition-all text-sm flex items-center justify-center space-x-2"
                                    title="Clear all cached data for this project">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M3 6h18" />
                                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                                    </svg>
                                    <span>Clear Cache</span>
                                </button>
                                <button id="reset-app-btn"
                                    class="w-full bg-red-100 text-red-800 font-semibold py-2 px-4 rounded-lg hover:bg-red-200 transition-all text-sm flex items-center justify-center space-x-2"
                                    title="Reset app: Delete all data, cache, and projects. App will reload.">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                                        <path d="M21 3v5h-5" />
                                        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                                        <path d="M3 21v-5h5" />
                                    </svg>
                                    <span>Reset App</span>
                                </button>
                            </div>
                        </div>
                    </details>
                </div>

                <!-- Image Upload Section -->
                <div class="control-section border border-border-color rounded-lg bg-gray-50/50">
                    <details>
                        <summary class="p-3 font-semibold cursor-pointer text-sm uppercase tracking-wider select-none">
                            Image &amp; SVG</summary>
                        <div class="p-3 border-t border-border-color space-y-4">
                            <input type="file" id="image-upload" class="hidden"
                                accept="image/png, image/jpeg, image/webp">
                            <input type="file" id="svg-upload" class="hidden" accept=".svg">
                            <input type="file" id="temp-image-upload" class="hidden"
                                accept="image/png, image/jpeg, image/webp">
                            <input type="file" id="bg-image-upload" class="hidden"
                                accept="image/png, image/jpeg, image/webp">

                            <div class="grid grid-cols-2 gap-2">
                                <button onclick="document.getElementById('image-upload').click()"
                                    class="w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                                        <polyline points="17 8 12 3 7 8" />
                                        <line x1="12" x2="12" y1="3" y2="15" />
                                    </svg>
                                    <span>Upload Img</span>
                                </button>
                                <button id="import-svg-btn"
                                    class="w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                        <polyline points="14 2 14 8 20 8"></polyline>
                                        <path d="m10 14-2 2 2 2" />
                                        <path d="m14 18 2-2-2-2" />
                                    </svg>
                                    <span>Import SVG</span>
                                </button>
                            </div>

                            <button id="upload-temp-image-btn"
                                class="w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm flex items-center justify-center space-x-2 mt-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-5 h-5">
                                    <path d="m16 13 5.223 3.482a.5.5 0 0 1 0 .869L16 20.833V13Z" />
                                    <path
                                        d="m4 13-1.106-.737a.5.5 0 0 0-.894.44V18.5c0 .276.224.5.5.5h13a.5.5 0 0 0 .5-.5v-4.833c0 .204-.124-.385-.31-.462L16 13H4Z" />
                                    <path d="M12 12V3m-2 2 2-2 2 2" />
                                </svg>
                                <span>Upload Color Ref</span>
                            </button>

                            <button id="upload-preview-image-btn"
                                class="w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm flex items-center justify-center space-x-2 mt-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-5 h-5">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                                    <circle cx="8.5" cy="8.5" r="1.5" />
                                    <polyline points="21 15 16 10 5 21" />
                                </svg>
                                <span>Upload Preview Image</span>
                            </button>
                            <input type="file" id="preview-image-upload" class="hidden"
                                accept="image/png, image/jpeg, image/webp">

                            <div id="preview-image-controls" class="hidden space-y-2 pt-2 border-t border-border-color">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium text-gray-700">Show Preview</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="toggle-preview-image">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <button id="delete-preview-image-btn"
                                    class="w-full bg-red-50 text-red-600 border border-red-300 font-semibold py-2 px-4 rounded-lg hover:bg-red-100 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M3 6h18" />
                                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                                    </svg>
                                    <span>Delete Preview</span>
                                </button>
                            </div>

                            <button id="delete-temp-image-btn"
                                class="w-full bg-red-50 text-red-600 border border-red-300 font-semibold py-2 px-4 rounded-lg hover:bg-red-100 transition-all text-sm flex items-center justify-center space-x-2 mt-2 hidden"
                                title="Delete the temporary color reference image (This is saved with the project)">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-5 h-5">
                                    <path d="M3 6h18" />
                                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                                    <line x1="10" y1="11" x2="10" y2="17" />
                                    <line x1="14" y1="11" x2="14" y2="17" />
                                </svg>
                                <span>Delete Color Ref</span>
                            </button>

                            <div class="pt-2 border-t border-border-color space-y-2">
                                <button id="upload-bg-image-btn"
                                    class="w-full bg-blue-50 text-blue-600 border border-blue-300 font-semibold py-2 px-4 rounded-lg hover:bg-blue-100 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                                        <circle cx="8.5" cy="8.5" r="1.5" />
                                        <polyline points="21 15 16 10 5 21" />
                                    </svg>
                                    <span>Upload Background</span>
                                </button>
                                <div id="bg-image-controls" class="hidden space-y-2">
                                    <div class="flex items-center justify-between">
                                        <span class="text-sm font-medium text-gray-700">BG Opacity</span>
                                        <span id="bg-opacity-value"
                                            class="text-xs font-mono bg-blue-50 text-blue-600 px-1.5 py-0.5 rounded">1.0</span>
                                    </div>
                                    <input type="range" id="bg-opacity-slider" min="0" max="1" step="0.01" value="1.0"
                                        class="w-full">
                                    <button id="delete-bg-image-btn"
                                        class="w-full bg-red-50 text-red-600 border border-red-300 font-semibold py-2 px-4 rounded-lg hover:bg-red-100 transition-all text-sm flex items-center justify-center space-x-2">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                            stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                                            <path d="M3 6h18" />
                                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                                        </svg>
                                        <span>Delete Background</span>
                                    </button>
                                </div>
                            </div>

                            <div id="color-ref-controls" class="hidden space-y-4 pt-4 border-t border-border-color">
                                <p class="text-sm font-semibold text-gray-700">Color Reference Controls</p>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium text-gray-700">Ref Mode</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="ref-mode-toggle">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <div class="flex items-center justify-between mt-2">
                                    <span class="text-sm font-medium text-gray-700">Auto Ref Opacity</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="auto-ref-opacity-toggle">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <div class="flex items-center justify-between mt-2">
                                    <span class="text-sm font-medium text-gray-700">Auto Stroke Path</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="auto-stroke-path-toggle">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <div class="mt-3">
                                    <label for="auto-stroke-style-select" class="text-sm font-medium text-gray-700">Auto
                                        Stroke Style</label>
                                    <select id="auto-stroke-style-select"
                                        class="w-full mt-1 px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                        <option value="uniform">Uniform</option>
                                        <option value="organic">Organic</option>
                                    </select>
                                </div>
                                <div class="mt-3">
                                    <label for="auto-stroke-density-slider"
                                        class="text-sm font-medium text-gray-700">Stroke Density</label>
                                    <input type="range" id="auto-stroke-density-slider" min="2" max="20" value="8"
                                        step="1" class="w-full mt-1">
                                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                                        <span>Dense</span>
                                        <span>Sparse</span>
                                    </div>
                                </div>
                                <div class="mt-3">
                                    <label for="auto-stroke-uturn-slider"
                                        class="text-sm font-medium text-gray-700">U-Turn Step Distance</label>
                                    <input type="range" id="auto-stroke-uturn-slider" min="0.1" max="4.0" value="1.99"
                                        step="0.05" class="w-full mt-1">
                                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                                        <span>10% (<span id="auto-stroke-uturn-value">1.99</span>)</span>
                                        <span>400%</span>
                                    </div>
                                </div>
                                <div>
                                    <label for="color-ref-opacity-slider" class="text-sm font-medium">Ref
                                        Opacity</label>
                                    <input type="range" id="color-ref-opacity-slider" min="0" max="1" step="0.05"
                                        value="1.0" class="w-full" title="Adjust color reference image transparency">
                                </div>
                                <button id="edit-color-ref-btn"
                                    class="tool-btn w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm flex items-center justify-center space-x-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-5 h-5">
                                        <path d="M5 11.5a1.5 1.5 0 0 0-3 0v1.5a1.5 1.5 0 0 0 3 0v-1.5Z" />
                                        <path d="M22 11.5a1.5 1.5 0 0 0-3 0v1.5a1.5 1.5 0 0 0 3 0v-1.5Z" />
                                        <path
                                            d="M11.5 22a1.5 1.5 0 0 1-1.5-1.5v-3a1.5 1.5 0 0 1 3 0v3a1.5 1.5 0 0 1-1.5 1.5Z" />
                                        <path
                                            d="M11.5 6.5a1.5 1.5 0 0 1-1.5-1.5v-3a1.5 1.5 0 0 1 3 0v3a1.5 1.5 0 0 1-1.5 1.5Z" />
                                        <path d="M2 11.5h1.5" />
                                        <path d="M20.5 11.5H22" />
                                        <path d="M11.5 2v1.5" />
                                        <path d="M11.5 20.5V22" />
                                        <path
                                            d="M7 11.5c0 2.5 2 4.5 4.5 4.5s4.5-2 4.5-4.5-2-4.5-4.5-4.5-4.5 2-4.5 4.5Z" />
                                    </svg>
                                    <span>Pan/Zoom Color Ref</span>
                                </button>
                                <div class="grid grid-cols-2 gap-2">
                                    <button id="reset-color-ref-btn"
                                        class="w-full bg-gray-100 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-200 transition-all text-sm">Reset</button>
                                    <button id="save-color-ref-btn"
                                        class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition-all text-sm">Save
                                        Settings</button>
                                </div>
                            </div>

                        </div>
                    </details>
                </div>

                <!-- Tools -->
                <div class="control-section border border-border-color rounded-lg bg-gray-50/50">
                    <details open>
                        <summary class="p-3 font-semibold cursor-pointer text-sm uppercase tracking-wider select-none">
                            Tools</summary>
                        <div class="p-3 border-t border-border-color space-y-4">
                            <div class="grid grid-cols-3 gap-2">
                                <button id="pan-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Pan Tool"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                        stroke-linecap="round" stroke-linejoin="round"
                                        class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M5 11.5a1.5 1.5 0 0 0-3 0v1.5a1.5 1.5 0 0 0 3 0v-1.5Z" />
                                        <path d="M22 11.5a1.5 1.5 0 0 0-3 0v1.5a1.5 1.5 0 0 0 3 0v-1.5Z" />
                                        <path
                                            d="M11.5 22a1.5 1.5 0 0 1-1.5-1.5v-3a1.5 1.5 0 0 1 3 0v3a1.5 1.5 0 0 1-1.5 1.5Z" />
                                        <path
                                            d="M11.5 6.5a1.5 1.5 0 0 1-1.5-1.5v-3a1.5 1.5 0 0 1 3 0v3a1.5 1.5 0 0 1-1.5 1.5Z" />
                                        <path d="M2 11.5h1.5" />
                                        <path d="M20.5 11.5H22" />
                                        <path d="M11.5 2v1.5" />
                                        <path d="M11.5 20.5V22" />
                                        <path
                                            d="M7 11.5c0 2.5 2 4.5 4.5 4.5s4.5-2 4.5-4.5-2-4.5-4.5-4.5-4.5 2-4.5 4.5Z" />
                                    </svg><span class="text-xs">Pan</span></button>

                                <button id="pencil-tool"
                                    class="tool-btn active flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Pencil Tool (M)"><svg xmlns="http://www.w3.org/2000/svg" width="24"
                                        height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                        class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
                                        <path d="m15 5 4 4" />
                                    </svg><span class="text-xs">Pencil</span></button>

                                <button id="eraser-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Eraser Tool"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                        stroke-linecap="round" stroke-linejoin="round"
                                        class="w-6 h-6 mb-1 text-gray-600">
                                        <path
                                            d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21H7Z" />
                                        <path d="M22 21H7" />
                                        <path d="m5 12 5 5" />
                                    </svg><span class="text-xs">Eraser</span></button>

                                <button id="color-picker-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Pick Color (B) / Long-press on canvas">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="m16 13 5.223 3.482a.5.5 0 0 1 0 .869L16 20.833V13Z" />
                                        <path
                                            d="m4 13-1.106-.737a.5.5 0 0 0-.894.44V18.5c0 .276.224.5.5.5h13a.5.5 0 0 0 .5-.5v-4.833c0 .204-.124-.385-.31-.462L16 13H4Z" />
                                        <path d="m12 12 4-4" />
                                    </svg>
                                    <span class="text-xs">Pick Color</span>
                                </button>

                                <button id="magic-wand-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Magic Wand Tool (Select Area)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M15 4V2" />
                                        <path d="M15 8V6" />
                                        <path d="M15 12V10" />
                                        <path d="M15 16V14" />
                                        <path d="M15 20V18" />
                                        <path d="M3 10l-1.65-1.65a.5.5 0 0 1 0-.7L3 6" />
                                        <path d="M21 10l1.65-1.65a.5.5 0 0 0 0-.7L21 6" />
                                        <path d="M12 2v6" />
                                        <path d="M6 6l-1.65-1.65a.5.5 0 0 1 0-.7L6 2" />
                                        <path d="M18 6l1.65-1.65a.5.5 0 0 0 0-.7L18 2" />
                                        <path
                                            d="M11.64 16.36a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28L4.05 7.71a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4L11.64 16.36z" />
                                        <path
                                            d="M18.83 14.17a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28l-2.94-6.56a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4l.22.53z" />
                                    </svg>
                                    <span class="text-xs">Wand</span>
                                </button>

                                <!-- NEW: Wand 2 - Outline Selector -->
                                <button id="magic-wand-2-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Wand 2 (Select All Black Outlines)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M4 4h6v2H6v4H4z" />
                                        <path d="M20 4h-6v2h4v4h2z" />
                                        <path d="M4 20h6v-2H6v-4H4z" />
                                        <path d="M20 20h-6v-2h4v-4h2z" />
                                        <path d="M9 9l6 6" />
                                        <path d="M15 9l-6 6" />
                                    </svg>
                                    <span class="text-xs">Wand 2</span>
                                </button>

                                <!-- NEW: Multi-Wand Toggle -->
                                <button id="multi-wand-toggle"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Multi-Wand Mode (Auto-detect all closed shapes)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M15 4V2m0 2v2m0-2h2m-2 0h-2" />
                                        <path
                                            d="M18.83 14.17a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28l-2.94-6.56a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4l.22.53z" />
                                        <circle cx="11" cy="11" r="8" />
                                        <path d="m21 21-4.35-4.35" />
                                    </svg>
                                    <span class="text-xs">Multi</span>
                                </button>

                                <!-- NEW: Pencil 2 - Outline Follower -->
                                <button id="pencil-2-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Pencil 2 (Auto Width on Outlines)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
                                        <path d="m15 5 4 4" />
                                        <path d="M4 14c2 2 4 3 8 3s6-1 8-3" />
                                    </svg>
                                    <span class="text-xs">Pencil 2</span>
                                </button>

                                <!-- NEW: Mask Brush Tool -->
                                <button id="mask-brush-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Mask Brush (Create Temporary Mask)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <circle cx="12" cy="12" r="10" />
                                        <line x1="4.93" y1="4.93" x2="19.07" y2="19.07" />
                                    </svg>
                                    <span class="text-xs">Mask</span>
                                </button>

                                <button id="paint-bucket-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Paint Bucket (Fill Area)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path
                                            d="M19 11H5M19 11a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2M19 11V9a2 2 0 0 0-2-2M5 11V9a2 2 0 0 1 2-2m0 0V5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2M7 7h10" />
                                        <path d="M12 2v2m0 4v2m0 4v2m0 4v2" stroke-width="1.5" />
                                    </svg>
                                    <span class="text-xs">Fill</span>
                                </button>

                                <button id="wet-paint-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Wet Paint Fill (Animated)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path
                                            d="M19 11H5M19 11a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2M19 11V9a2 2 0 0 0-2-2M5 11V9a2 2 0 0 1 2-2m0 0V5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2M7 7h10" />
                                        <circle cx="12" cy="15" r="1" fill="currentColor" />
                                    </svg>
                                    <span class="text-xs">Wet Paint</span>
                                </button>

                                <button id="water-mix-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Water Mix Effect (Subtle Blending)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z" />
                                        <path d="M12 12v.01" />
                                        <path d="M12 16v.01" />
                                        <path d="M8 14v.01" />
                                        <path d="M16 14v.01" />
                                    </svg>
                                    <span class="text-xs">Water Mix</span>
                                </button>

                                <button id="glossy-effect-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Glossy Effect (Shiny)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <circle cx="12" cy="12" r="10" />
                                        <path
                                            d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" />
                                        <path d="M8 12h8" />
                                    </svg>
                                    <span class="text-xs">Glossy</span>
                                </button>

                                <button id="glitter-effect-tool"
                                    class="tool-btn flex flex-col items-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200"
                                    title="Glitter Effect (Sparkles)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="w-6 h-6 mb-1 text-gray-600">
                                        <path d="M12 2L2 7l10 5 10-5-10-5z" />
                                        <path d="M2 17l10 5 10-5" />
                                        <path d="M2 12l10 5 10-5" />
                                        <circle cx="12" cy="12" r="1" fill="currentColor" />
                                        <circle cx="6" cy="7" r="0.5" fill="currentColor" />
                                        <circle cx="18" cy="7" r="0.5" fill="currentColor" />
                                        <circle cx="6" cy="17" r="0.5" fill="currentColor" />
                                        <circle cx="18" cy="17" r="0.5" fill="currentColor" />
                                    </svg>
                                    <span class="text-xs">Glitter</span>
                                </button>

                            </div>
                            <div class="space-y-2">
                                <label for="stroke-width-slider"
                                    class="text-sm font-medium flex justify-between items-center">
                                    <span>Line Width</span>
                                    <span id="stroke-width-value" class="text-sm">2px</span>
                                </label>
                                <input type="range" id="stroke-width-slider" min="0.01" max="50" step="0.01" value="2"
                                    class="w-full">
                            </div>

                            <!-- Selection Pencil Line Width Slider (moved from canvas) -->
                            <div id="wand-pencil-slider-container" class="space-y-2 pt-2 border-t border-border-color">
                                <label class="text-sm font-medium flex justify-between items-center">
                                    <span>Selection Pencil Width</span>
                                    <span id="wand-pencil-slider-value" class="text-sm">2px</span>
                                </label>
                                <div class="flex items-center gap-2">
                                    <button id="wand-pencil-minus-btn" class="wand-pencil-adj-btn">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                                            stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4">
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                    <input type="range" id="wand-pencil-slider" min="0.01" max="50" step="0.01"
                                        value="2" class="flex-1">
                                    <button id="wand-pencil-plus-btn" class="wand-pencil-adj-btn">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                                            stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4">
                                            <line x1="12" y1="5" x2="12" y2="19"></line>
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <!-- NEW Opacity Slider -->
                            <div class="space-y-2">
                                <label for="stroke-opacity-slider"
                                    class="text-sm font-medium flex justify-between items-center">
                                    <span>Line Opacity</span>
                                    <span id="stroke-opacity-value" class="text-sm">1.0</span>
                                </label>
                                <input type="range" id="stroke-opacity-slider" min="0.1" max="1" step="0.05" value="1"
                                    class="w-full">
                            </div>
                            <!-- END New Opacity Slider -->

                            <!-- Shade Mode Darken Slider -->
                            <div id="shade-darken-container" class="space-y-2 hidden">
                                <label for="shade-darken-slider"
                                    class="text-sm font-medium flex justify-between items-center">
                                    <span>Darken</span>
                                    <span id="shade-darken-value" class="text-sm">20%</span>
                                </label>
                                <input type="range" id="shade-darken-slider" min="0" max="100" step="1" value="20"
                                    class="w-full">

                                <div class="space-y-1">
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm font-medium">Shade Opacity</span>
                                        <span id="shade-opacity-value" class="text-sm">0.50</span>
                                    </div>
                                    <input type="range" id="shade-opacity-slider" min="0.05" max="1.0" step="0.05"
                                        value="0.5" class="w-full">
                                </div>

                                <div class="space-y-1">
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm font-medium">Shade Width</span>
                                        <span id="shade-width-value" class="text-sm">20px</span>
                                    </div>
                                    <input type="range" id="shade-width-slider" min="1" max="100" step="1" value="20"
                                        class="w-full">
                                </div>

                                <div class="space-y-1">
                                    <div class="flex justify-between items-center">
                                        <span class="text-sm font-medium">Shade Smoothness</span>
                                        <span id="shade-smoothness-value" class="text-sm">10.0</span>
                                    </div>
                                    <input type="range" id="shade-smoothness-slider" min="0.5" max="20" step="0.5"
                                        value="10" class="w-full">
                                </div>
                            </div>

                            <!-- NEW: Snap to Outline Controls -->
                            <div class="flex items-center justify-between mt-2 pt-2 border-t border-border-color">
                                <span class="text-sm font-medium text-gray-700">Snap to Outline</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="snap-toggle">
                                    <div class="toggle-div"></div>
                                </label>
                            </div>
                            <div id="snap-strength-container" class="space-y-2" style="display: none;">
                                <label for="snap-strength-slider"
                                    class="text-sm font-medium flex justify-between items-center">
                                    <span>Snap Strength</span>
                                    <span id="snap-strength-value" class="text-sm">10px</span>
                                </label>
                                <input type="range" id="snap-strength-slider" min="0" max="10" step="0.1" value="1"
                                    class="w-full">
                            </div>
                            <!-- END NEW -->

                            <!-- NEW Blur Slider -->
                            <div class="space-y-2">
                                <label for="stroke-blur-slider"
                                    class="text-sm font-medium flex justify-between items-center">
                                    <span>Line Blur</span>
                                    <span id="stroke-blur-value" class="text-sm">0</span>
                                </label>
                                <input type="range" id="stroke-blur-slider" min="0" max="5" step="1" value="0"
                                    class="w-full">
                            </div>
                            <!-- END New Blur Slider -->

                            <!-- NEW: Wet Paint Shadow Settings -->
                            <div id="wet-paint-shadow-settings" class="space-y-3 pt-2 border-t border-border-color">
                                <p class="text-xs font-bold uppercase tracking-widest text-gray-500">Wet Paint Shadows
                                </p>

                                <div class="space-y-1">
                                    <label for="wp-outer-shadow-size" class="text-xs font-medium flex justify-between">
                                        <span>Outer Shadow Size</span>
                                        <span id="wp-outer-shadow-size-val">1.2</span>
                                    </label>
                                    <input type="range" id="wp-outer-shadow-size" min="0" max="5" step="0.1" value="1.2"
                                        class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="wp-outer-shadow-blur" class="text-xs font-medium flex justify-between">
                                        <span>Outer Shadow Blur</span>
                                        <span id="wp-outer-shadow-blur-val">0.35</span>
                                    </label>
                                    <input type="range" id="wp-outer-shadow-blur" min="0" max="3" step="0.05"
                                        value="0.35" class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="wp-inner-shadow-size" class="text-xs font-medium flex justify-between">
                                        <span>Inner Shadow Size</span>
                                        <span id="wp-inner-shadow-size-val">0.5</span>
                                    </label>
                                    <input type="range" id="wp-inner-shadow-size" min="0" max="3" step="0.1" value="0.5"
                                        class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="wp-inner-shadow-blur" class="text-xs font-medium flex justify-between">
                                        <span>Inner Shadow Blur</span>
                                        <span id="wp-inner-shadow-blur-val">0.4</span>
                                    </label>
                                    <input type="range" id="wp-inner-shadow-blur" min="0" max="2" step="0.05"
                                        value="0.4" class="w-full h-1.5">
                                </div>
                            </div>
                            <!-- END Wet Paint Shadow Settings -->

                            <!-- NEW: Water Mix Shadow Settings -->
                            <div id="water-mix-settings" class="space-y-3 pt-2 border-t border-border-color">
                                <p class="text-xs font-bold uppercase tracking-widest text-gray-500">Water Mix Settings
                                </p>

                                <div class="space-y-1">
                                    <label for="wm-shadow-size" class="text-xs font-medium flex justify-between">
                                        <span>Shadow Size</span>
                                        <span id="wm-shadow-size-val">0.6</span>
                                    </label>
                                    <input type="range" id="wm-shadow-size" min="0" max="3" step="0.1" value="0.6"
                                        class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="wm-shadow-blur" class="text-xs font-medium flex justify-between">
                                        <span>Shadow Blur</span>
                                        <span id="wm-shadow-blur-val">0.4</span>
                                    </label>
                                    <input type="range" id="wm-shadow-blur" min="0" max="2" step="0.05" value="0.4"
                                        class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="wm-shadow-opacity" class="text-xs font-medium flex justify-between">
                                        <span>Shadow Intensity</span>
                                        <span id="wm-shadow-opacity-val">0.15</span>
                                    </label>
                                    <input type="range" id="wm-shadow-opacity" min="0" max="1" step="0.05" value="0.15"
                                        class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="wm-mix-strength" class="text-xs font-medium flex justify-between">
                                        <span>Mix Strength</span>
                                        <span id="wm-mix-strength-val">0.3</span>
                                    </label>
                                    <input type="range" id="wm-mix-strength" min="0" max="2" step="0.05" value="0.3"
                                        class="w-full h-1.5">
                                </div>

                                <div class="flex items-center justify-between pt-1">
                                    <span class="text-xs font-medium text-gray-700">Inner Highlight</span>
                                    <label class="toggle-label scale-75">
                                        <input type="checkbox" id="wm-highlight-toggle">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>

                                <div id="wm-highlight-opacity-container" class="space-y-1">
                                    <label for="wm-highlight-opacity" class="text-xs font-medium flex justify-between">
                                        <span>Highlight Intensity</span>
                                        <span id="wm-highlight-opacity-val">0.50</span>
                                    </label>
                                    <input type="range" id="wm-highlight-opacity" min="0" max="1" step="0.05"
                                        value="0.5" class="w-full h-1.5">
                                </div>

                                <div id="wm-highlight-size-container" class="space-y-1">
                                    <label for="wm-highlight-size" class="text-xs font-medium flex justify-between">
                                        <span>Highlight Size</span>
                                        <span id="wm-highlight-size-val">0.6</span>
                                    </label>
                                    <input type="range" id="wm-highlight-size" min="0" max="3" step="0.1" value="0.6"
                                        class="w-full h-1.5">
                                </div>

                                <div id="wm-highlight-blur-container" class="space-y-1">
                                    <label for="wm-highlight-blur" class="text-xs font-medium flex justify-between">
                                        <span>Highlight Blur</span>
                                        <span id="wm-highlight-blur-val">0.00</span>
                                    </label>
                                    <input type="range" id="wm-highlight-blur" min="0" max="3" step="0.05" value="0"
                                        class="w-full h-1.5">
                                </div>
                            </div>
                            <!-- END Water Mix Shadow Settings -->

                            <!-- NEW: Glitter Effect Settings -->
                            <div id="glitter-settings" class="hidden space-y-3 pt-2 border-t border-border-color">
                                <p class="text-xs font-bold uppercase tracking-widest text-gray-500">Glitter Settings
                                </p>

                                <div class="space-y-1">
                                    <label for="glitter-density" class="text-xs font-medium flex justify-between">
                                        <span>Glitter Density</span>
                                        <span id="glitter-density-val">0.45</span>
                                    </label>
                                    <input type="range" id="glitter-density" min="0.1" max="0.9" step="0.05"
                                        value="0.45" class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="glitter-size" class="text-xs font-medium flex justify-between">
                                        <span>Grain Size</span>
                                        <span id="glitter-size-val">3.0</span>
                                    </label>
                                    <input type="range" id="glitter-size" min="1.0" max="10.0" step="0.5" value="3.0"
                                        class="w-full h-1.5">
                                </div>

                                <div class="space-y-1">
                                    <label for="glitter-star-count" class="text-xs font-medium flex justify-between">
                                        <span>Star Count</span>
                                        <span id="glitter-star-count-val">0.5</span>
                                    </label>
                                    <input type="range" id="glitter-star-count" min="0" max="1" step="0.01" value="0.5"
                                        class="w-full h-1.5 accent-blue-500">
                                </div>
                            </div>
                            <!-- END Glitter Effect Settings -->

                            <!-- Paint Bucket Shrink Slider -->
                            <div id="paint-bucket-shrink-container"
                                class="hidden space-y-2 pt-2 border-t border-border-color">
                                <label for="paint-bucket-shrink-slider"
                                    class="text-sm font-medium flex justify-between items-center">
                                    <span>Fill Shrink</span>
                                    <span id="paint-bucket-shrink-value" class="text-sm">0px</span>
                                </label>
                                <div class="flex items-center gap-2">
                                    <button id="paint-bucket-shrink-minus-btn" type="button" class="wand-pencil-adj-btn"
                                        aria-label="Decrease fill shrink">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                                            stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4">
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                    <input type="range" id="paint-bucket-shrink-slider" min="-5" max="10" step="1"
                                        value="0" class="flex-1">
                                    <button id="paint-bucket-shrink-plus-btn" type="button" class="wand-pencil-adj-btn"
                                        aria-label="Increase fill shrink">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                                            stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4">
                                            <line x1="12" y1="5" x2="12" y2="19"></line>
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <!-- END Paint Bucket Shrink Slider -->

                            <div id="image-tools" class="hidden space-y-4 pt-4 border-t border-border-color">
                                <p class="text-sm font-semibold text-gray-700">Tracing Image Controls</p>
                                <div>
                                    <label for="opacity-slider" class="text-sm font-medium">Trace Opacity</label>
                                    <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="1.0"
                                        class="w-full" title="Adjust tracing image transparency">
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium text-gray-700">Lock Pan/Zoom</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="lock-image">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium text-gray-700">Trace Lock</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="trace-lock">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium text-gray-700">Auto Color Pick Mode</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="auto-color-pick-toggle">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium text-gray-700">Wand W (Shape Bounds)</span>
                                    <label class="toggle-label">
                                        <input type="checkbox" id="wand-w-toggle">
                                        <div class="toggle-div"></div>
                                    </label>
                                </div>
                                <button id="delete-image-btn"
                                    class="w-full text-red-600 border border-red-500 font-semibold py-2 px-4 rounded-lg hover:bg-red-50 transition-all text-sm">Delete
                                    Trace Image</button>
                                <button id="delete-fill-btn"
                                    class="w-full text-red-600 border border-red-500 font-semibold py-2 px-4 rounded-lg hover:bg-red-50 transition-all text-sm">Delete
                                    Fill</button>
                                <button id="delete-imported-svg-btn"
                                    class="w-full text-red-600 border border-red-500 font-semibold py-2 px-4 rounded-lg hover:bg-red-50 transition-all text-sm hidden">Delete
                                    Imported SVG</button>
                            </div>

                            <div class="grid grid-cols-2 gap-2 pt-4 border-t border-border-color">
                                <button id="undo-btn"
                                    class="flex items-center justify-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                    disabled title="Undo (Ctrl+Z)"><svg xmlns="http://www.w3.org/2000/svg" width="24"
                                        height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                        class="w-5 h-5 mr-1">
                                        <path d="M3 7v6h6" />
                                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                                    </svg><span class="text-sm">Undo</span></button>
                                <button id="redo-btn"
                                    class="flex items-center justify-center p-2 rounded-lg bg-gray-100 hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                    disabled title="Redo (Ctrl+Y)"><svg xmlns="http://www.w3.org/2000/svg" width="24"
                                        height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                        class="w-5 h-5 mr-1">
                                        <path d="M21 7v6h-6" />
                                        <path d="M3 17a9 9 0 0 0 9 9 9 9 0 0 0 6-2.3L21 13" />
                                    </svg><span class="text-sm">Redo</span></button>
                            </div>
                            <div class="space-y-2">
                                <label for="pencil-mode-select" class="text-sm font-medium block mb-1">Pencil
                                    Mode</label>
                                <select id="pencil-mode-select">
                                    <option value="smoothness" selected>Smoothness</option>
                                    <option value="fixed_nodes">Fixed Nodes</option>
                                </select>
                            </div>
                            <div id="smoothness-slider-container" class="space-y-2">
                                <label for="simplify-slider"
                                    class="text-sm font-medium flex justify-between"><span>Pencil Smoothness
                                        Strength</span> <span id="simplify-value">1.5</span></label>
                                <input type="range" id="simplify-slider" min="0.5" max="20" step="0.1" value="1.5"
                                    class="w-full"
                                    title="Controls stroke smoothness (strength). Higher = Fewer nodes, smoother. Lower = More detail, more nodes.">
                            </div>
                            <div id="fixed-nodes-slider-container" class="hidden space-y-2">
                                <label for="pencil-nodes-slider"
                                    class="text-sm font-medium flex justify-between"><span>Pencil Node Count</span>
                                    <span id="pencil-nodes-value">10</span></label>
                                <input type="range" id="pencil-nodes-slider" min="2" max="30" step="1" value="10"
                                    class="w-full" title="Sets a fixed number of nodes for the pencil path.">
                            </div>

                            <div class="flex items-center justify-between pt-2 border-t border-border-color">
                                <span class="text-sm font-medium text-gray-700">Sticky Pencil</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="sticky-pencil-toggle">
                                    <div class="toggle-div"></div>
                                </label>
                            </div>

                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium text-gray-700">Temp Stroke</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="temp-stroke-toggle">
                                    <div class="toggle-div"></div>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium text-gray-700">Zero Opacity Strokes</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="zero-opacity-strokes-toggle">
                                    <div class="toggle-div"></div>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium text-gray-700">Force Black Stroke (Export)</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="force-black-stroke-toggle">
                                    <div class="toggle-div"></div>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium text-gray-700">Black Outline Mode</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="black-outline-mode-toggle">
                                    <div class="toggle-div"></div>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium text-gray-700">Exclude Fills on Export</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="fill-export-toggle">
                                    <div class="toggle-div"></div>
                                </label>
                            </div>

                            <div class="space-y-2 pt-2 border-t border-border-color">
                                <label for="mask-brush-size-slider" class="text-sm font-medium flex justify-between">
                                    <span>Mask Brush Size</span>
                                    <span id="mask-brush-size-value">20px</span>
                                </label>
                                <input type="range" id="mask-brush-size-slider" min="5" max="100" step="5" value="20"
                                    class="w-full">
                            </div>
                            <div class="space-y-2">
                                <label for="mask-opacity-slider" class="text-sm font-medium flex justify-between">
                                    <span>Mask Opacity</span>
                                    <span id="mask-opacity-value">80%</span>
                                </label>
                                <input type="range" id="mask-opacity-slider" min="10" max="100" step="5" value="80"
                                    class="w-full">
                            </div>

                            <button id="delete-temp-strokes-btn"
                                class="w-full mt-2 flex items-center justify-center p-2 rounded-lg border border-gray-400 text-gray-600 hover:bg-gray-100 transition-all text-sm"
                                title="Delete all temporary strokes">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-5 h-5 mr-1">
                                    <path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.07" />
                                    <path d="M7 13.01V10a2 2 0 0 1 2-2h3.01" />
                                    <path d="M11 17a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-3.01" />
                                </svg>
                                <span>Delete Temp Strokes</span>
                            </button>
                        </div>
                    </details>
                </div>

                <div class="control-section border border-border-color rounded-lg bg-gray-50/50">
                    <details>
                        <summary class="p-3 font-semibold cursor-pointer text-sm uppercase tracking-wider select-none">
                            Selection</summary>
                        <div class="p-3 border-t border-border-color space-y-4">
                            <div class="space-y-2">
                                <label for="tolerance-slider" class="text-sm font-medium flex justify-between">
                                    <span>Wand Tolerance</span>
                                    <span id="tolerance-value">30</span>
                                </label>
                                <input type="range" id="tolerance-slider" min="0" max="100" step="1" value="30"
                                    class="w-full">
                            </div>
                            <div class="space-y-2">
                                <label for="all-color-tolerance-slider"
                                    class="text-sm font-medium flex justify-between">
                                    <span>All Color Tolerance (Precise)</span>
                                    <span id="all-color-tolerance-value">5</span>
                                </label>
                                <input type="range" id="all-color-tolerance-slider" min="0" max="50" step="0.5"
                                    value="5" class="w-full">
                                <p class="text-xs text-gray-500">Lower = more precise, Higher = more similar colors</p>
                            </div>
                            <div class="space-y-2">
                                <label for="wand-shrink-slider" class="text-sm font-medium flex justify-between">
                                    <span>Selection Shrink</span>
                                    <span id="wand-shrink-slider-value" class="text-sm">0px</span>
                                </label>
                                <div class="flex items-center gap-2">
                                    <button id="wand-shrink-minus-btn" type="button" class="wand-pencil-adj-btn"
                                        aria-label="Decrease selection shrink">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                                            stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4">
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                    <input type="range" id="wand-shrink-slider" min="-5" max="10" step="1" value="0"
                                        class="flex-1">
                                    <button id="wand-shrink-plus-btn" type="button" class="wand-pencil-adj-btn"
                                        aria-label="Increase selection shrink">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"
                                            stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4">
                                            <line x1="12" y1="5" x2="12" y2="19"></line>
                                            <line x1="5" y1="12" x2="19" y2="12"></line>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium text-gray-700">Show Selection Outline</span>
                                <label class="toggle-label">
                                    <input type="checkbox" id="show-selection-outline-toggle" checked>
                                    <div class="toggle-div"></div>
                                </label>
                            </div>
                            <button id="deselect-btn"
                                class="w-full mt-2 flex items-center justify-center p-2 rounded-lg border border-gray-400 text-gray-600 hover:bg-gray-100 transition-all hidden"
                                title="Clear current selection">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-5 h-5 mr-1">
                                    <path
                                        d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z" />
                                    <path d="m14.5 9.5-5 5m0-5 5 5" />
                                </svg>
                                <span class="text-sm">Deselect</span>
                            </button>
                        </div>
                    </details>
                </div>

                <div class="control-section border border-border-color rounded-lg bg-gray-50/50">
                    <details>
                        <summary class="p-3 font-semibold cursor-pointer text-sm uppercase tracking-wider select-none">
                            Color Filter</summary>
                        <div class="p-3 border-t border-border-color space-y-4">
                            <div class="space-y-2">
                                <label for="color-filter-select" class="text-sm font-medium block mb-1">Filter
                                    Type</label>
                                <select id="color-filter-select">
                                    <option value="none" selected>None</option>
                                    <option value="sepia">Sepia</option>
                                    <option value="vintage">Vintage/Retro</option>
                                    <option value="teal-orange">Cinematic Teal & Orange</option>
                                    <option value="luminosity">Luminosity Filters</option>
                                </select>
                            </div>
                            <div id="luminosity-controls" class="space-y-2 hidden">
                                <label for="luminosity-saturation-slider"
                                    class="text-sm font-medium flex justify-between">
                                    <span>Saturation</span>
                                    <span id="luminosity-saturation-value">100</span>
                                </label>
                                <input type="range" id="luminosity-saturation-slider" min="0" max="200" step="5"
                                    value="100" class="w-full">
                                <label for="luminosity-vibrance-slider"
                                    class="text-sm font-medium flex justify-between">
                                    <span>Vibrance</span>
                                    <span id="luminosity-vibrance-value">100</span>
                                </label>
                                <input type="range" id="luminosity-vibrance-slider" min="0" max="200" step="5"
                                    value="100" class="w-full">
                            </div>
                        </div>
                    </details>
                </div>

                <div class="control-section border border-border-color rounded-lg bg-gray-50/50">
                    <details open>
                        <summary class="p-3 font-semibold cursor-pointer text-sm uppercase tracking-wider select-none">
                            Color</summary>
                        <div class="p-3 border-t border-border-color space-y-4">

                            <div id="color-palette-container" class="space-y-4">
                                <!-- Color palette will be generated here -->
                            </div>

                        </div>
                    </details>
                </div>

            </div>

            <!-- Settings Profiles Section -->
            <div class="control-section border border-border-color rounded-lg bg-gray-50/50">
                <details>
                    <summary class="p-3 font-semibold cursor-pointer text-sm uppercase tracking-wider select-none">
                        Settings Profiles</summary>
                    <div class="p-3 border-t border-border-color space-y-4">
                        <!-- Active Profile Display -->
                        <div class="space-y-2">
                            <label for="profile-select" class="text-sm font-medium block">Active Profile</label>
                            <select id="profile-select" class="w-full">
                                <option value="default">Default</option>
                            </select>
                        </div>

                        <!-- Save All Settings Button -->
                        <button id="save-all-settings-btn"
                            class="w-full flex items-center justify-center p-2 rounded-lg bg-gradient-to-r from-indigo-500 to-purple-600 text-white font-semibold shadow hover:from-indigo-600 hover:to-purple-700 transition-all"
                            title="Save all current settings to the selected profile">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5 mr-2">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                                <polyline points="17 21 17 13 7 13 7 21" />
                                <polyline points="7 3 7 8 15 8" />
                            </svg>
                            <span>Save All Settings</span>
                        </button>

                        <!-- Profile Management Buttons -->
                        <div class="grid grid-cols-2 gap-2">
                            <button id="create-profile-btn"
                                class="flex items-center justify-center p-2 rounded-lg bg-green-100 text-green-700 border border-green-300 hover:bg-green-200 transition-all text-sm"
                                title="Create a new profile">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-4 h-4 mr-1">
                                    <line x1="12" y1="5" x2="12" y2="19" />
                                    <line x1="5" y1="12" x2="19" y2="12" />
                                </svg>
                                <span>New Profile</span>
                            </button>
                            <button id="delete-profile-btn"
                                class="flex items-center justify-center p-2 rounded-lg bg-red-100 text-red-700 border border-red-300 hover:bg-red-200 transition-all text-sm"
                                title="Delete the selected profile">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-4 h-4 mr-1">
                                    <path d="M3 6h18" />
                                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                                </svg>
                                <span>Delete</span>
                            </button>
                        </div>

                        <!-- Set as Default Button -->
                        <div class="flex items-center justify-between pt-2 border-t border-border-color">
                            <span class="text-sm font-medium text-gray-700">Set as Default</span>
                            <button id="set-default-profile-btn"
                                class="flex items-center justify-center px-3 py-1.5 rounded-lg bg-amber-100 text-amber-700 border border-amber-300 hover:bg-amber-200 transition-all text-sm"
                                title="Set the selected profile as default">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round" class="w-4 h-4 mr-1">
                                    <polygon
                                        points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" />
                                </svg>
                                <span id="default-profile-indicator">Default</span>
                            </button>
                        </div>

                        <!-- Current Default Display -->
                        <div class="text-xs text-gray-500 text-center" id="current-default-display">
                            Current Default: <span id="current-default-name" class="font-semibold">Default</span>
                        </div>
                    </div>
                </details>
            </div>

            <div class="pt-3 border-t border-border-color space-y-2">
                <button id="delete-fill-paths-btn"
                    class="w-full flex items-center justify-center p-2 rounded-lg border border-orange-400 text-orange-600 hover:bg-orange-50 transition-all"
                    title="Delete all fill paths"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" class="w-5 h-5 mr-1">
                        <path d="M3 6h18" />
                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                        <path d="M9 12l2 2 4-4" />
                    </svg><span class="text-sm">Delete Fill Paths</span></button>
                <button id="clear-btn"
                    class="w-full flex items-center justify-center p-2 rounded-lg border border-red-400 text-red-500 hover:bg-red-50 transition-all"
                    title="Clear canvas"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" class="w-5 h-5 mr-1">
                        <path d="M3 6h18" />
                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                    </svg><span class="text-sm">Clear</span></button>
            </div>
        </aside>

        <div class="flex-1 flex flex-col min-w-0">
            <header class="bg-panel shadow-sm p-2 flex items-center justify-between z-10 flex-shrink-0">
                <!-- MODIFICATION: open-sidebar-btn is now always visible and first -->
                <button id="open-sidebar-btn" class="p-2 rounded-full hover:bg-gray-200"><svg
                        xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="w-6 h-6">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg></button>

                <div class="flex-1"></div>
                <div id="loader" class="hidden loader mr-4"></div>
                <button id="export-btn"
                    class="bg-accent-color text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-accent-hover transition-all flex items-center space-x-2"
                    title="Export as SVG"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" class="w-5 h-5">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" x2="12" y1="15" y2="3" />
                    </svg><span class="hidden sm:inline">Export SVG</span></button>
                <button id="export-png-btn"
                    class="bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-green-700 transition-all flex items-center space-x-2 ml-2"
                    title="Export as PNG"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round" class="w-5 h-5">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                        <polyline points="7 10 12 15 17 10" />
                        <line x1="12" x2="12" y1="15" y2="3" />
                    </svg><span class="hidden sm:inline">Export PNG</span></button>
            </header>
            <main class="flex-1 bg-bg-main flex items-center justify-center p-2 sm:p-4 overflow-hidden relative"
                id="canvas-parent">
                <div id="canvas-container"
                    class="w-full h-full bg-bg-canvas rounded-xl shadow-inner relative overflow-hidden">

                    <svg id="svg-canvas" class="w-full h-full absolute top-0 left-0 z-10"
                        style="will-change: transform; contain: layout style paint;">
                        <!-- NEW: Blur Filters -->
                        <defs>
                            <pattern id="diagonalHatch" width="5" height="5" patternTransform="rotate(45)"
                                patternUnits="userSpaceOnUse">
                                <line x1="0" y1="0" x2="0" y2="5" stroke="rgba(0,0,0,0.6)" stroke-width="1" />
                            </pattern>
                            <filter id="trace-mask-filter">
                                <feFlood flood-color="white" result="bg" />
                                <feComposite in="SourceGraphic" in2="bg" operator="over" result="composite" />
                                <feColorMatrix in="composite" type="matrix"
                                    values="0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0" />
                            </filter>
                            <mask id="image-mask"></mask>
                            <filter id="blur-1" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="1" />
                            </filter>
                            <filter id="blur-2" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="2" />
                            </filter>
                            <filter id="blur-3" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="3" />
                            </filter>
                            <filter id="blur-4" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="4" />
                            </filter>
                            <filter id="blur-5" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="5" />
                            </filter>
                        </defs>
                    </svg>
                    <!-- Dedicated Mask Overlay SVG (Top of all) - needs same viewBox and transforms as svgCanvas -->
                    <svg id="mask-overlay-svg" class="w-full h-full absolute top-0 left-0 z-40 pointer-events-none"
                        style="z-index: 40; overflow: visible; will-change: transform; contain: layout style paint;"
                        preserveAspectRatio="none"></svg>
                    <canvas id="marching-ants-canvas" class="absolute inset-0 z-20 pointer-events-none"></canvas>

                </div>

                <div id="zoom-slider-container"
                    class="absolute bottom-4 left-1\/2 -translate-x-1\/2 z-20 hidden items-center space-x-2 p-2 rounded-lg shadow">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="text-gray-600 flex-shrink-0">
                        <circle cx="11" cy="11" r="8" />
                        <line x1="21" y1="21" x2="16.65" y2="16.65" />
                        <line x1="8" y1="11" x2="14" y2="11" />
                    </svg>
                    <input type="range" id="zoom-slider" min="10" max="1000" step="10" value="100" class="w-40">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="text-gray-600 flex-shrink-0">
                        <circle cx="11" cy="11" r="8" />
                        <line x1="21" y1="21" x2="16.65" y2="16.65" />
                        <line x1="8" y1="11" x2="14" y2="11" />
                        <line x1="11" y1="8" x2="11" y2="14" />
                    </svg>
                </div>

                <button id="wand-toggle-btn" class="" title="Re-select area (W)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="w-6 h-6">
                        <path d="M15 4V2" />
                        <path d="M15 8V6" />
                        <path d="M15 12V10" />
                        <path d="M15 16V14" />
                        <path d="M15 20V18" />
                        <path d="M3 10l-1.65-1.65a.5.5 0 0 1 0-.7L3 6" />
                        <path d="M21 10l1.65-1.65a.5.5 0 0 0 0-.7L21 6" />
                        <path d="M12 2v6" />
                        <path d="M6 6l-1.65-1.65a.5.5 0 0 1 0-.7L6 2" />
                        <path d="M18 6l1.65-1.65a.5.5 0 0 0 0-.7L18 2" />
                        <path
                            d="M11.64 16.36a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28L4.05 7.71a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4L11.64 16.36z" />
                        <path
                            d="M18.83 14.17a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28l-2.94-6.56a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4l.22.53z" />
                    </svg>
                </button>

                <!-- --- NEW: Floating History (Undo/Redo) --- -->
                <div id="wand-history-container">
                    <button id="wand-undo-btn" class="canvas-history-btn" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            class="w-6 h-6">
                            <path d="M3 7v6h6" />
                            <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                        </svg>
                    </button>
                    <button id="wand-redo-btn" class="canvas-history-btn" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            class="w-6 h-6">
                            <path d="M21 7v6h-6" />
                            <path d="M3 17a9 9 0 0 0 9 9 9 9 0 0 0 6-2.3L21 13" />
                        </svg>
                    </button>
                </div>
                <!-- --- END NEW --- -->


                <div id="canvas-undo-redo-container">
                    <button id="canvas-undo-btn" class="canvas-history-btn" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            class="w-6 h-6">
                            <path d="M3 7v6h6" />
                            <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                        </svg>
                    </button>
                    <button id="canvas-redo-btn" class="canvas-history-btn" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            class="w-6 h-6">
                            <path d="M21 7v6h-6" />
                            <path d="M3 17a9 9 0 0 0 9 9 9 9 0 0 0 6-2.3L21 13" />
                        </svg>
                    </button>
                </div>
                <!-- CONSOLIDATED BOTTOM LEFT TOOLBAR -->
                <div id="bottom-left-toolbar" class="fixed bottom-4 left-4 z-50 flex items-center gap-2"
                    style="pointer-events: auto;">

                    <!-- 1. Shortcuts -->
                    <div id="tool-shortcuts-container" class="pointer-events-auto flex gap-2"
                        style="position: static !important; inset: auto !important; margin: 0 !important; opacity: 1 !important; visibility: visible !important;">
                        <button id="shortcut-wand-btn" class="tool-shortcut-btn" title="Magic Wand (W)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-6 h-6">
                                <path d="M15 4V2" />
                                <path d="M15 8V6" />
                                <path d="M15 12V10" />
                                <path d="M15 16V14" />
                                <path d="M15 20V18" />
                                <path d="M3 10l-1.65-1.65a.5.5 0 0 1 0-.7L3 6" />
                                <path d="M21 10l1.65-1.65a.5.5 0 0 0 0-.7L21 6" />
                                <path d="M12 2v6" />
                                <path d="M6 6l-1.65-1.65a.5.5 0 0 1 0-.7L6 2" />
                                <path d="M18 6l1.65-1.65a.5.5 0 0 0 0-.7L18 2" />
                                <path
                                    d="M11.64 16.36a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28L4.05 7.71a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4L11.64 16.36z" />
                                <path
                                    d="M18.83 14.17a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28l-2.94-6.56a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4l.22.53z" />
                            </svg>
                        </button>
                        <button id="shortcut-wand-2-btn" class="tool-shortcut-btn"
                            title="Magic Wand 2 (Outline Selection)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-6 h-6">
                                <path d="M4 4h6v2H6v4H4z" />
                                <path d="M20 4h-6v2h4v4h2z" />
                                <path d="M4 20h6v-2H6v-4H4z" />
                                <path d="M20 20h-6v-2h4v-4h2z" />
                                <path d="M9 9l6 6" />
                                <path d="M15 9l-6 6" />
                            </svg>
                        </button>
                        <button id="shortcut-fill-btn" class="tool-shortcut-btn" title="Fill (Paint Bucket)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-6 h-6">
                                <path
                                    d="M19 11H5M19 11a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2M19 11V9a2 2 0 0 0-2-2M5 11V9a2 2 0 0 1 2-2m0 0V5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2M7 7h10" />
                                <path d="M12 2v2m0 4v2m0 4v2m0 4v2" stroke-width="1.5" />
                            </svg>
                        </button>
                        <button id="shortcut-pencil-btn" class="tool-shortcut-btn active" title="Pencil (M)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-6 h-6">
                                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
                                <path d="m15 5 4 4" />
                            </svg>
                        </button>
                        <button id="shortcut-pan-btn" class="tool-shortcut-btn" title="Pan Tool">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-6 h-6">
                                <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" />
                                <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" />
                                <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" />
                                <path
                                    d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" />
                            </svg>
                        </button>
                        <button id="shortcut-eyedropper-btn" class="tool-shortcut-btn" title="Pick Color from Screen">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-6 h-6">
                                <path d="m2 22 1-1h3l9-9" />
                                <path d="M3 21v-3l9-9" />
                                <path d="m15 6 3.4-3.4a2.1 2.1 0 1 1 3 3L18 9l.9.9 1.4-1.4" />
                                <path d="m15 6 3 3" />
                                <path d="m15 6-3 3" />
                            </svg>
                        </button>
                        <button id="shortcut-ref-mode-btn" class="tool-shortcut-btn" title="Toggle Ref Mode">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                                <circle cx="8.5" cy="8.5" r="1.5" />
                                <polyline points="21 15 16 10 5 21" />
                            </svg>
                        </button>
                        <button id="shortcut-mask-brush-btn" class="tool-shortcut-btn" title="Mask Brush">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <circle cx="12" cy="12" r="10" />
                                <line x1="4.93" y1="4.93" x2="19.07" y2="19.07" />
                            </svg>
                        </button>
                        <button id="shortcut-shade-btn" class="tool-shortcut-btn" title="Shade Mode (S)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                            </svg>
                        </button>
                        <button id="shortcut-wet-paint-btn" class="tool-shortcut-btn" title="Wet Paint Fill">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <rect x="5" y="11" width="14" height="10" rx="2" />
                                <circle cx="12" cy="15" r="1" fill="currentColor" />
                            </svg>
                        </button>
                        <button id="shortcut-water-mix-btn" class="tool-shortcut-btn" title="Water Mix Effect">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path
                                    d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z">
                                </path>
                                <path d="M8 14v.01" />
                                <path d="M16 14v.01" />
                            </svg>
                        </button>
                        <button id="shortcut-glitter-btn" class="tool-shortcut-btn" title="Glitter Effect">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path
                                    d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z">
                                </path>
                                <circle cx="12" cy="12" r="0.5" fill="currentColor" />
                                <circle cx="6" cy="17" r="0.5" fill="currentColor" />
                                <circle cx="18" cy="17" r="0.5" fill="currentColor" />
                            </svg>
                        </button>
                        <button id="shortcut-disable-filters-btn" class="tool-shortcut-btn"
                            title="Disable Active Filters">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path>
                                <line x1="12" y1="2" x2="12" y2="12"></line>
                            </svg>
                        </button>
                        <button id="shortcut-selection-visibility-btn" class="tool-shortcut-btn"
                            title="Toggle Selection Outline">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" />
                                <circle cx="12" cy="12" r="3" />
                            </svg>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5 hidden" id="selection-hidden-icon">
                                <path
                                    d="M9.88 9.88a3 3 0 1 0 4.24 4.24m-5.32-5.32A10.45 10.45 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68" />
                                <path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9 0 0 0 5.39-1.61" />
                                <line x1="2" y1="2" x2="22" y2="22" />
                            </svg>
                        </button>
                        <button id="pin-image-btn" class="tool-shortcut-btn" title="Pin/Unpin Image Position">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5" id="pin-icon">
                                <path
                                    d="M12 17c-2.76 0-5-2.24-5-5 0-2.76 2.24-5 5-5s5 2.24 5 5c0 2.76-2.24 5-5 5m0-10V2m0 20v-5" />
                            </svg>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5 hidden" id="pin-filled-icon">
                                <path
                                    d="M12 17c-2.76 0-5-2.24-5-5 0-2.76 2.24-5 5-5s5 2.24 5 5c0 2.76-2.24 5-5 5m0-10V2m0 20v-5" />
                            </svg>
                        </button>
                        <button id="shortcut-auto-fill-btn" class="tool-shortcut-btn"
                            title="Auto Fill All Colors (Ref Mode)"
                            style="background: linear-gradient(135deg, rgba(99,102,241,0.15), rgba(236,72,153,0.15)); border: 1.5px solid rgba(99,102,241,0.3);">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path
                                    d="M19 11H5M19 11a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2" />
                                <path d="M12 2l1.5 3.5L17 7l-3.5 1.5L12 12l-1.5-3.5L7 7l3.5-1.5L12 2"
                                    stroke="currentColor" stroke-width="1.5" fill="rgba(99,102,241,0.3)" />
                            </svg>
                        </button>
                        <button id="canvas-auto-stroke-toggle-btn" class="tool-shortcut-btn"
                            title="Toggle Auto Stroke (On/Off)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path d="M6 4h12c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H6c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" />
                                <path d="M9 9h6M9 15h6M12 12v3" />
                            </svg>
                        </button>
                        <button id="canvas-auto-ref-opacity-toggle-btn" class="tool-shortcut-btn"
                            title="Toggle Auto Ref Opacity (On/Off)">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                                <circle cx="12" cy="12" r="3" fill="currentColor" opacity="0.5" />
                                <path d="M23 1L1 23" stroke="currentColor" stroke-width="2" opacity="0.3" />
                            </svg>
                        </button>
                    </div>

                    <!-- 2. Stroke Width -->
                    <div id="bottom-left-stroke-width-container"
                        class="bottom-left-stroke-width-container pointer-events-auto"
                        style="position: static !important; inset: auto !important; margin: 0 !important; visibility: visible !important;">
                        <button id="stroke-width-minus-btn" class="bottom-left-stroke-btn"
                            title="Decrease stroke width">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M5 12h14" />
                            </svg>
                        </button>
                        <span id="bottom-left-stroke-width-value" class="bottom-left-stroke-value">2px</span>
                        <button id="stroke-width-plus-btn" class="bottom-left-stroke-btn" title="Increase stroke width">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M5 12h14" />
                                <path d="M12 5v14" />
                            </svg>
                        </button>
                    </div>

                    <!-- 3. Undo/Redo -->
                    <div id="bottom-left-undo-redo-container" class="pointer-events-auto flex gap-2"
                        style="position: static !important; inset: auto !important; margin: 0 !important; display: flex !important; opacity: 1 !important; visibility: visible !important;">
                        <button id="bottom-left-undo-btn" class="bottom-left-history-btn" title="Undo (Ctrl+Z)"
                            disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path d="M3 7v6h6" />
                                <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" />
                            </svg>
                        </button>
                        <button id="bottom-left-redo-btn" class="bottom-left-history-btn" title="Redo (Ctrl+Y)"
                            disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="w-5 h-5">
                                <path d="M21 7v6h-6" />
                                <path d="M3 17a9 9 0 0 0 9 9 9 9 0 0 0 6-2.3L21 13" />
                            </svg>
                        </button>
                    </div>

                    <!-- 4. Fullscreen -->
                    <button id="fullscreen-btn" title="Toggle Fullscreen" class="pointer-events-auto"
                        style="position: static !important; inset: auto !important; margin: 0 !important; visibility: visible !important;">
                        <svg id="fullscreen-enter-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                            <path
                                d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                        </svg>
                        <svg id="fullscreen-exit-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5" style="display: none;">
                            <path
                                d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
                        </svg>
                    </button>


                    <!-- 5. Palette Toggle -->
                    <button id="floating-color-palette-toggle" title="Color Palette" class="pointer-events-auto"
                        style="position: static !important; inset: auto !important; margin: 0 !important; display: flex !important; visibility: visible !important;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            class="w-5 h-5">
                            <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18" />
                            <line x1="7" y1="2" x2="7" y2="22" />
                            <line x1="17" y1="2" x2="17" y2="22" />
                            <line x1="2" y1="12" x2="22" y2="12" />
                            <line x1="2" y1="7" x2="7" y2="7" />
                            <line x1="2" y1="17" x2="7" y2="17" />
                            <line x1="17" y1="17" x2="22" y2="17" />
                            <line x1="17" y1="7" x2="22" y2="7" />
                        </svg>
                    </button>
                </div>

                <!-- Floating Color Palette Panel -->
                <div id="floating-color-palette-container">
                    <div class="floating-palette-header">
                        <span class="floating-palette-title">Color Palette</span>
                        <button class="floating-palette-close" id="floating-palette-close-btn" title="Close">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                    <div class="floating-custom-color-section">
                        <label class="floating-custom-color-label">Custom Color</label>
                        <input type="color" id="floating-custom-color-input" class="floating-custom-color-input"
                            value="#000000">
                    </div>
                    <div class="floating-palette-colors" id="floating-palette-colors">
                        <!-- Color swatches will be generated here -->
                    </div>
                </div>

                <!-- Reference Preview Image Overlay -->
                <img id="reference-preview-image" class="hidden" draggable="false">

                <!-- NEW: Un-pick Color Button -->
                <button id="unpick-color-btn"
                    class="absolute top-4 right-4 z-30 hidden bg-white text-gray-800 font-semibold py-2 px-4 rounded-lg shadow-lg hover:bg-gray-100 transition-all text-sm flex items-center justify-center space-x-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="w-5 h-5">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                    <span>Cancel Pick</span>
                </button>
                <!-- END NEW -->

                <!-- RIGHT COLOR PALETTE -->
                <div id="right-side-palette-wrapper" class="collapsed">
                    <button id="right-palette-toggle" title="Toggle Color Palette">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="13.5" cy="6.5" r=".5" fill="currentColor" />
                            <circle cx="17.5" cy="10.5" r=".5" fill="currentColor" />
                            <circle cx="8.5" cy="7.5" r=".5" fill="currentColor" />
                            <circle cx="6.5" cy="12.5" r=".5" fill="currentColor" />
                            <path
                                d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z" />
                        </svg>
                    </button>
                    <div id="right-side-palette"></div>
                </div>
                <!-- END RIGHT COLOR PALETTE -->
            </main>
        </div>
    </div>

    <!-- Modals -->
    <div id="confirm-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full z-70 hidden items-center justify-center p-4">
        <div class="p-6 border w-full max-w-md shadow-lg rounded-xl bg-white">
            <div class="text-center">
                <h3 id="confirm-title" class="text-lg leading-6 font-medium text-gray-900">Clear Canvas?</h3>
                <p id="confirm-message" class="mt-2 text-sm text-gray-500">This will delete all drawings and cannot be
                    undone.</p>
            </div>
            <div class="flex justify-center items-center mt-6 space-x-4">
                <button id="cancel-confirm-btn"
                    class="px-5 py-2 bg-gray-200 text-gray-800 rounded-md shadow-sm hover:bg-gray-300">Cancel</button>
                <button id="confirm-action-btn"
                    class="px-5 py-2 bg-red-600 text-white rounded-md shadow-sm hover:bg-red-700">Yes, Do It</button>
            </div>
        </div>
    </div>

    <div id="projects-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full z-60 hidden items-center justify-center p-4">
        <div class="projects-panel w-full max-w-md rounded-lg bg-white p-4">
            <h3 class="text-lg font-semibold text-gray-900 mb-3">Projects</h3>

            <div class="flex flex-col gap-2 mb-3">
                <button id="new-project-btn"
                    class="w-full bg-accent-color text-white text-sm font-medium py-2 px-3 rounded">New Project</button>
                <button id="save-as-btn"
                    class="w-full bg-gray-100 text-gray-800 text-sm font-medium py-2 px-3 rounded">Save Current As
                    New</button>
            </div>

            <div id="projects-list-container"
                class="project-list max-h-64 overflow-y-auto border border-gray-200 rounded p-2 text-sm">
                <!-- Project items will be injected here -->
            </div>

            <button id="close-projects-modal-btn"
                class="mt-3 w-full border border-gray-300 text-gray-800 text-sm py-2 px-3 rounded">Close</button>
        </div>
    </div>

    <div id="project-name-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full z-60 hidden items-center justify-center p-4">
        <div class="p-6 border w-full max-w-sm shadow-lg rounded-xl bg-white">
            <h3 id="project-name-modal-title" class="text-lg leading-6 font-medium text-gray-900 mb-4">Save Project</h3>
            <input type="text" id="project-name-input" placeholder="Enter project name..." class="w-full">
            <div class="flex justify-end items-center mt-6 space-x-3">
                <button id="cancel-save-name-btn"
                    class="px-5 py-2 bg-gray-200 text-gray-800 rounded-md shadow-sm hover:bg-gray-300">Cancel</button>
                <button id="confirm-save-name-btn"
                    class="px-5 py-2 bg-accent-color text-white rounded-md shadow-sm hover:bg-accent-hover">Save</button>
            </div>
        </div>
    </div>

    <!-- PNG Export Options Modal -->
    <div id="png-export-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full z-60 hidden items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-900">PNG Export Options</h3>
                <button id="close-png-export-modal-btn" class="text-gray-500 hover:text-gray-700 px-2"></button>
            </div>

            <div class="space-y-4">
                <div>
                    <label for="png-scale-select" class="block text-sm font-medium text-gray-700 mb-2">
                        Resolution Scale
                    </label>
                    <select id="png-scale-select" class="w-full">
                        <option value="1">1x (Standard)</option>
                        <option value="2" selected>2x (High Quality)</option>
                        <option value="3">3x (Very High)</option>
                        <option value="4">4x (Ultra High)</option>
                        <option value="custom">Custom Scale</option>
                    </select>
                </div>

                <div id="custom-scale-container" class="hidden">
                    <label for="png-custom-scale" class="block text-sm font-medium text-gray-700 mb-2">
                        Custom Scale Factor (1-8)
                    </label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="png-custom-scale" min="1" max="8" step="0.5" value="2" class="flex-1">
                        <span id="png-custom-scale-value" class="text-sm font-medium min-w-[60px]">2x</span>
                    </div>
                    <div id="png-dimensions-preview" class="text-xs text-gray-500 mt-1">
                        Dimensions: 2000 x 2000 px
                    </div>
                </div>

                <div>
                    <label for="png-quality-preset" class="block text-sm font-medium text-gray-700 mb-2">
                        Quality Preset
                    </label>
                    <select id="png-quality-preset" class="w-full">
                        <option value="standard">Standard (2x)</option>
                        <option value="high" selected>High Quality (3x)</option>
                        <option value="very-high">Very High (4x)</option>
                        <option value="ultra">Ultra High (5x)</option>
                        <option value="maximum">Maximum (8x)</option>
                    </select>
                </div>

                <div class="pt-2 border-t border-gray-200">
                    <div id="png-export-info" class="text-sm text-gray-600 mb-4">
                        <p><strong>Output:</strong> <span id="png-output-size">2000 x 2000 px</span></p>
                        <p class="text-xs text-gray-500 mt-1">Higher scale = Better quality but larger file size</p>
                    </div>
                </div>
            </div>

            <div class="flex gap-3 mt-6">
                <button id="cancel-png-export-btn"
                    class="flex-1 bg-gray-100 text-gray-800 font-medium py-2 px-4 rounded hover:bg-gray-200">Cancel</button>
                <button id="confirm-png-export-btn"
                    class="flex-1 bg-green-600 text-white font-medium py-2 px-4 rounded hover:bg-green-700">Export
                    PNG</button>
            </div>
        </div>
    </div>

    <!-- Profile Name Input Modal -->
    <div id="profile-name-modal"
        class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full z-60 hidden items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 class="text-lg font-semibold text-gray-900 mb-4">Create New Profile</h3>
            <div class="space-y-4">
                <div>
                    <label for="profile-name-input" class="block text-sm font-medium text-gray-700 mb-2">
                        Profile Name
                    </label>
                    <input type="text" id="profile-name-input" placeholder="My Custom Profile"
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        maxlength="30">
                </div>
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="copy-current-settings-checkbox" checked
                        class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                    <label for="copy-current-settings-checkbox" class="text-sm text-gray-600">
                        Copy current settings to new profile
                    </label>
                </div>
            </div>
            <div class="flex gap-3 mt-6">
                <button id="cancel-profile-name-btn"
                    class="flex-1 bg-gray-100 text-gray-800 font-medium py-2 px-4 rounded hover:bg-gray-200">Cancel</button>
                <button id="confirm-profile-name-btn"
                    class="flex-1 bg-indigo-600 text-white font-medium py-2 px-4 rounded hover:bg-indigo-700">Create</button>
            </div>
        </div>
    </div>

    <!-- Toast notification -->
    <div id="toast-notification"
        class="fixed bottom-4 right-4 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg z-60 opacity-0 translate-x-full toast"
        style="display: none;">
        Settings Saved!
    </div>
    <script>
        // ============================================
        // PASSWORD PROTECTION & DEVICE FINGERPRINTING
        // ============================================
        (function () {
            const CORRECT_PASSWORD = '20188';
            const STORAGE_KEY_DEVICE = 'app_device_fingerprint';
            const STORAGE_KEY_AUTH = 'app_authenticated_devices';

            // Generate a unique device fingerprint
            function generateDeviceFingerprint() {
                const components = [
                    navigator.userAgent,
                    navigator.language,
                    navigator.hardwareConcurrency || 'unknown',
                    navigator.deviceMemory || 'unknown',
                    navigator.platform,
                    screen.width + 'x' + screen.height,
                    screen.colorDepth,
                    new Date().getTimezoneOffset(),
                    navigator.maxTouchPoints || 0,
                    !!window.sessionStorage,
                    !!window.localStorage,
                    !!window.indexedDB,
                    navigator.cookieEnabled
                ];

                // Simple hash function
                const str = components.join('|');
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return 'device_' + Math.abs(hash).toString(36);
            }

            // Check if current device is authenticated
            function isDeviceAuthenticated() {
                try {
                    const currentFingerprint = generateDeviceFingerprint();
                    const storedFingerprint = localStorage.getItem(STORAGE_KEY_DEVICE);
                    const authenticatedDevices = JSON.parse(localStorage.getItem(STORAGE_KEY_AUTH) || '[]');

                    // Check if this device fingerprint is in the authenticated list
                    return authenticatedDevices.includes(currentFingerprint);
                } catch (error) {
                    console.error('Error checking device authentication:', error);
                    return false;
                }
            }

            // Authenticate current device
            function authenticateDevice() {
                try {
                    const currentFingerprint = generateDeviceFingerprint();
                    const authenticatedDevices = JSON.parse(localStorage.getItem(STORAGE_KEY_AUTH) || '[]');

                    // Add current device to authenticated list if not already there
                    if (!authenticatedDevices.includes(currentFingerprint)) {
                        authenticatedDevices.push(currentFingerprint);
                        localStorage.setItem(STORAGE_KEY_AUTH, JSON.stringify(authenticatedDevices));
                    }

                    // Store current device fingerprint
                    localStorage.setItem(STORAGE_KEY_DEVICE, currentFingerprint);
                    return true;
                } catch (error) {
                    console.error('authenticateDevice: ERROR -', error);
                    return false;
                }
            }

            // Password verification
            function verifyPassword(password) {
                return password === CORRECT_PASSWORD;
            }

            // Initialize password protection
            function initPasswordProtection() {
                const passwordModal = document.getElementById('passwordModal');
                const passwordInput = document.getElementById('passwordInput');
                const passwordSubmitBtn = document.getElementById('passwordSubmitBtn');
                const passwordError = document.getElementById('passwordError');

                if (!passwordModal || !passwordInput || !passwordSubmitBtn || !passwordError) return;

                // Device needs authentication, show modal
                passwordModal.classList.add('show');
                passwordInput.focus();

                // Handle password submission
                const handleSubmit = () => {
                    const enteredPassword = passwordInput.value.trim();

                    if (!enteredPassword) {
                        passwordError.textContent = 'Please enter a password';
                        passwordInput.classList.add('error');
                        setTimeout(() => passwordInput.classList.remove('error'), 400);
                        return;
                    }

                    if (verifyPassword(enteredPassword)) {
                        // Correct password
                        if (authenticateDevice()) {
                            passwordError.textContent = '';
                            passwordInput.classList.remove('error');

                            // Success animation
                            passwordModal.style.transition = 'opacity 0.5s ease';
                            passwordModal.style.opacity = '0';

                            setTimeout(() => {
                                passwordModal.classList.remove('show');
                                passwordModal.style.opacity = '';
                                passwordModal.style.transition = '';
                            }, 500);
                        } else {
                            passwordError.textContent = 'Error saving authentication. Please try again.';
                            passwordInput.classList.add('error');
                        }
                    } else {
                        // Wrong password
                        passwordError.textContent = 'Incorrect password. Please try again.';
                        passwordInput.classList.add('error');
                        passwordInput.value = '';
                        passwordInput.focus();
                        setTimeout(() => passwordInput.classList.remove('error'), 400);
                    }
                };

                // Event listeners
                passwordSubmitBtn.addEventListener('click', handleSubmit);
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleSubmit();
                    }
                });

                // Clear error on input
                passwordInput.addEventListener('input', () => {
                    passwordError.textContent = '';
                    passwordInput.classList.remove('error');
                });
            }

            // Initialize password protection immediately
            // Start with modal hidden, only show if needed
            function checkAuth() {
                const passwordModal = document.getElementById('passwordModal');
                if (!passwordModal) return;

                // Check authentication immediately
                if (isDeviceAuthenticated()) {
                    // Already authenticated, keep modal hidden
                    passwordModal.classList.remove('show');
                } else {
                    // Not authenticated, show modal
                    initPasswordProtection();
                }
            }

            // Run checkAuth when DOM is ready (since we are inserting this script at the end, DOM should be ready)
            checkAuth();

            // Block all interactions until authenticated
            const blockInteraction = (e) => {
                if (isDeviceAuthenticated()) return;

                // Allow interaction with the password modal
                const passwordModal = document.getElementById('passwordModal');
                if (passwordModal && passwordModal.contains(e.target)) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();
                return false;
            };

            document.addEventListener('click', blockInteraction, true);
            document.addEventListener('keydown', blockInteraction, true);
            document.addEventListener('touchstart', blockInteraction, true);
        })();
        // ============================================
        // END PASSWORD PROTECTION
        // ============================================
        document.addEventListener('DOMContentLoaded', async () => {
            // --- DOM Elements ---
            const mainAppContainer = document.getElementById('main-app-container');
            const svgCanvas = document.getElementById('svg-canvas');
            const imageUpload = document.getElementById('image-upload');
            const svgUpload = document.getElementById('svg-upload');
            const importSvgBtn = document.getElementById('import-svg-btn');
            const opacitySlider = document.getElementById('opacity-slider');
            const lockImageCheckbox = document.getElementById('lock-image');
            const traceLockCheckbox = document.getElementById('trace-lock');
            const deleteImageBtn = document.getElementById('delete-image-btn');
            const strokeWidthSlider = document.getElementById('stroke-width-slider');
            const strokeWidthValue = document.getElementById('stroke-width-value');
            const toolButtons = document.querySelectorAll('.tool-btn');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const clearBtn = document.getElementById('clear-btn');
            const deleteFillPathsBtn = document.getElementById('delete-fill-paths-btn');
            const colorPaletteContainer = document.getElementById('color-palette-container');
            const exportBtn = document.getElementById('export-btn');
            const exportPngBtn = document.getElementById('export-png-btn');
            const loader = document.getElementById('loader');

            // PNG Export Options DOM Elements
            const pngExportModal = document.getElementById('png-export-modal');
            const closePngExportModalBtn = document.getElementById('close-png-export-modal-btn');
            const cancelPngExportBtn = document.getElementById('cancel-png-export-btn');
            const confirmPngExportBtn = document.getElementById('confirm-png-export-btn');
            const pngScaleSelect = document.getElementById('png-scale-select');
            const pngCustomScaleContainer = document.getElementById('custom-scale-container');
            const pngCustomScale = document.getElementById('png-custom-scale');
            const pngCustomScaleValue = document.getElementById('png-custom-scale-value');
            const pngDimensionsPreview = document.getElementById('png-dimensions-preview');
            const pngQualityPreset = document.getElementById('png-quality-preset');
            const pngOutputSize = document.getElementById('png-output-size');
            const canvasContainer = document.getElementById('canvas-container');
            const imageTools = document.getElementById('image-tools');
            const confirmModal = document.getElementById('confirm-modal');
            const confirmActionBtn = document.getElementById('confirm-action-btn');
            const cancelConfirmBtn = document.getElementById('cancel-confirm-btn');
            const confirmTitle = document.getElementById('confirm-title');
            const confirmMessage = document.getElementById('confirm-message');
            const openSidebarBtn = document.getElementById('open-sidebar-btn');
            const closeSidebarBtn = document.getElementById('close-sidebar-btn');
            const sidebar = document.getElementById('sidebar');
            const sidebarBackdrop = document.getElementById('sidebar-backdrop');
            const pencilModeSelect = document.getElementById('pencil-mode-select');
            const smoothnessSliderContainer = document.getElementById('smoothness-slider-container');
            const fixedNodesSliderContainer = document.getElementById('fixed-nodes-slider-container');
            const simplifySlider = document.getElementById('simplify-slider');
            const simplifyValue = document.getElementById('simplify-value');
            const pencilNodesSlider = document.getElementById('pencil-nodes-slider');
            const pencilNodesValue = document.getElementById('pencil-nodes-value');
            const toast = document.getElementById('toast-notification');

            // --- Color Picker DOM Elements ---
            const tempImageUpload = document.getElementById('temp-image-upload');
            const uploadTempImageBtn = document.getElementById('upload-temp-image-btn');
            const deleteTempImageBtn = document.getElementById('delete-temp-image-btn');

            // --- Color Reference Controls DOM Elements ---
            const colorRefControls = document.getElementById('color-ref-controls');
            const colorRefOpacitySlider = document.getElementById('color-ref-opacity-slider');
            const maskOpacitySlider = document.getElementById('mask-opacity-slider');
            const maskOpacityValue = document.getElementById('mask-opacity-value');
            const editColorRefBtn = document.getElementById('edit-color-ref-btn');
            const resetColorRefBtn = document.getElementById('reset-color-ref-btn');
            const saveColorRefBtn = document.getElementById('save-color-ref-btn');
            const refModeToggle = document.getElementById('ref-mode-toggle');

            // --- Project Management DOM Elements ---
            const saveProjectBtn = document.getElementById('save-project-btn');
            const manageProjectsBtn = document.getElementById('manage-projects-btn');
            const exportProjectBtn = document.getElementById('export-project-btn');
            const importProjectBtn = document.getElementById('import-project-btn');
            const projectFileUpload = document.getElementById('project-file-upload');
            const currentProjectNameEl = document.getElementById('current-project-name');
            const autosaveIntervalInput = document.getElementById('autosave-interval');
            const clearCacheBtn = document.getElementById('clear-cache-btn');
            const resetAppBtn = document.getElementById('reset-app-btn');
            const projectsModal = document.getElementById('projects-modal');
            const newProjectBtn = document.getElementById('new-project-btn');
            const saveAsBtn = document.getElementById('save-as-btn');
            const projectsListContainer = document.getElementById('projects-list-container');
            const closeProjectsModalBtn = document.getElementById('close-projects-modal-btn');
            const projectNameModal = document.getElementById('project-name-modal');
            const projectNameModalTitle = document.getElementById('project-name-modal-title');
            const projectNameInput = document.getElementById('project-name-input');
            const cancelSaveNameBtn = document.getElementById('cancel-save-name-btn');
            const confirmSaveNameBtn = document.getElementById('confirm-save-name-btn');
            // --- Zoom Slider DOM Elements ---
            const zoomSliderContainer = document.getElementById('zoom-slider-container');
            const zoomSlider = document.getElementById('zoom-slider');
            const stickyPencilToggle = document.getElementById('sticky-pencil-toggle');
            // --- Canvas Undo/Redo DOM Elements ---
            const canvasUndoRedoContainer = document.getElementById('canvas-undo-redo-container');
            const canvasUndoBtn = document.getElementById('canvas-undo-btn');
            const canvasRedoBtn = document.getElementById('canvas-redo-btn');
            const fillExportToggle = document.getElementById('fill-export-toggle');
            // --- NEW Magic Wand DOM Elements and Canvas ---
            const magicWandToolBtn = document.getElementById('magic-wand-tool');
            const paintBucketToolBtn = document.getElementById('paint-bucket-tool');
            const paintBucketShrinkSlider = document.getElementById('paint-bucket-shrink-slider');
            const paintBucketShrinkValue = document.getElementById('paint-bucket-shrink-value');
            const paintBucketShrinkContainer = document.getElementById('paint-bucket-shrink-container');
            const paintBucketShrinkMinusBtn = document.getElementById('paint-bucket-shrink-minus-btn');
            const paintBucketShrinkPlusBtn = document.getElementById('paint-bucket-shrink-plus-btn');
            const wetPaintToolBtn = document.getElementById('wet-paint-tool');
            const glossyEffectToolBtn = document.getElementById('glossy-effect-tool');
            const glitterEffectToolBtn = document.getElementById('glitter-effect-tool');
            const magicWand2ToolBtn = document.getElementById('magic-wand-2-tool');
            const multiWandToggleBtn = document.getElementById('multi-wand-toggle');
            const pencil2ToolBtn = document.getElementById('pencil-2-tool');
            const waterMixToolBtn = document.getElementById('water-mix-tool');
            const wandToggleBtn = document.getElementById('wand-toggle-btn');
            const toleranceSlider = document.getElementById('tolerance-slider');
            const toleranceValue = document.getElementById('tolerance-value');
            const allColorToleranceSlider = document.getElementById('all-color-tolerance-slider');
            const allColorToleranceValue = document.getElementById('all-color-tolerance-value');
            const deselectBtn = document.getElementById('deselect-btn');
            const antsCanvas = document.getElementById('marching-ants-canvas');
            const antsCtx = antsCanvas.getContext('2d', { willReadFrequently: true });

            // --- NEW Floating Pencil Slider DOM Elements ---
            const wandPencilSliderContainer = document.getElementById('wand-pencil-slider-container');
            const wandPencilSlider = document.getElementById('wand-pencil-slider');
            const wandPencilSliderValue = document.getElementById('wand-pencil-slider-value');
            const wandPencilMinusBtn = document.getElementById('wand-pencil-minus-btn');
            const wandPencilPlusBtn = document.getElementById('wand-pencil-plus-btn');

            // --- Selection Shrink Slider DOM Elements ---
            const wandShrinkSlider = document.getElementById('wand-shrink-slider');
            const wandShrinkSliderValue = document.getElementById('wand-shrink-slider-value');
            const wandShrinkMinusBtn = document.getElementById('wand-shrink-minus-btn');
            const wandShrinkPlusBtn = document.getElementById('wand-shrink-plus-btn');

            // --- NEW Floating History DOM Elements ---
            const wandHistoryContainer = document.getElementById('wand-history-container');
            const wandUndoBtn = document.getElementById('wand-undo-btn');
            const wandRedoBtn = document.getElementById('wand-redo-btn');

            // --- NEW Un-pick Color Button ---
            const unpickColorBtn = document.getElementById('unpick-color-btn');

            // --- NEW Opacity/Blur DOM Elements ---
            const strokeOpacitySlider = document.getElementById('stroke-opacity-slider');
            const strokeOpacityValue = document.getElementById('stroke-opacity-value');
            const strokeBlurSlider = document.getElementById('stroke-blur-slider');
            const strokeBlurValue = document.getElementById('stroke-blur-value');

            // --- NEW Snap Controls ---
            const snapToggle = document.getElementById('snap-toggle');
            const snapStrengthContainer = document.getElementById('snap-strength-container');
            const snapStrengthSlider = document.getElementById('snap-strength-slider');
            const snapStrengthValue = document.getElementById('snap-strength-value');

            // --- NEW: Glitter Settings DOM Elements ---
            const glitterDensitySlider = document.getElementById('glitter-density');
            const glitterDensityValue = document.getElementById('glitter-density-val');
            const glitterSizeSlider = document.getElementById('glitter-size');
            const glitterSizeValue = document.getElementById('glitter-size-val');
            const glitterStarCountSlider = document.getElementById('glitter-star-count');
            const glitterStarCountValue = document.getElementById('glitter-star-count-val');

            // --- FIX 2: Temp Stroke DOM Elements ---
            const tempStrokeToggle = document.getElementById('temp-stroke-toggle');
            const zeroOpacityStrokesToggle = document.getElementById('zero-opacity-strokes-toggle');
            const forceBlackStrokeToggle = document.getElementById('force-black-stroke-toggle');
            const blackOutlineModeToggle = document.getElementById('black-outline-mode-toggle');
            const deleteTempStrokesBtn = document.getElementById('delete-temp-strokes-btn');
            const showSelectionOutlineToggle = document.getElementById('show-selection-outline-toggle');

            // --- NEW: Auto Color Pick and Delete Fill Toggles ---
            const autoColorPickToggle = document.getElementById('auto-color-pick-toggle');
            const wandWToggle = document.getElementById('wand-w-toggle');
            const deleteFillBtn = document.getElementById('delete-fill-btn');
            const deleteImportedSvgBtn = document.getElementById('delete-imported-svg-btn');

            // --- NEW: Color Filter DOM Elements ---
            const colorFilterSelect = document.getElementById('color-filter-select');
            const luminosityControls = document.getElementById('luminosity-controls');
            const luminositySaturationSlider = document.getElementById('luminosity-saturation-slider');
            const luminositySaturationValue = document.getElementById('luminosity-saturation-value');
            const luminosityVibranceSlider = document.getElementById('luminosity-vibrance-slider');
            const luminosityVibranceValue = document.getElementById('luminosity-vibrance-value');

            // --- NEW: Preview Image DOM Elements ---
            const previewImageUpload = document.getElementById('preview-image-upload');
            const uploadPreviewImageBtn = document.getElementById('upload-preview-image-btn');
            const previewImageControls = document.getElementById('preview-image-controls');
            const togglePreviewImage = document.getElementById('toggle-preview-image');
            const deletePreviewImageBtn = document.getElementById('delete-preview-image-btn');
            const referencePreviewImage = document.getElementById('reference-preview-image');
            const pinImageBtn = document.getElementById('pin-image-btn');
            const pinIcon = document.getElementById('pin-icon');
            const pinFilledIcon = document.getElementById('pin-filled-icon');


            // --- NEW: Tool Shortcuts DOM Elements ---
            const toolShortcutsContainer = document.getElementById('tool-shortcuts-container');
            const shortcutWandBtn = document.getElementById('shortcut-wand-btn');
            const shortcutRefModeBtn = document.getElementById('shortcut-ref-mode-btn'); // NEW Ref Mode Shortcut
            const shortcutFillBtn = document.getElementById('shortcut-fill-btn');
            const shortcutPencilBtn = document.getElementById('shortcut-pencil-btn');
            const shortcutPanBtn = document.getElementById('shortcut-pan-btn');
            const shortcutShadeBtn = document.getElementById('shortcut-shade-btn'); // NEW Shade Mode
            const shortcutAutoFillBtn = document.getElementById('shortcut-auto-fill-btn'); // NEW Auto Fill
            const shortcutWetPaintBtn = document.getElementById('shortcut-wet-paint-btn'); // NEW Wet Paint
            const shortcutWaterMixBtn = document.getElementById('shortcut-water-mix-btn'); // NEW Water Mix
            const shortcutGlitterBtn = document.getElementById('shortcut-glitter-btn'); // NEW Glitter
            const shortcutDisableFiltersBtn = document.getElementById('shortcut-disable-filters-btn'); // NEW Disable Filters

            // --- NEW: Auto Stroke Path DOM Element ---
            const autoStrokePathToggle = document.getElementById('auto-stroke-path-toggle');
            const canvasAutoStrokeToggleBtn = document.getElementById('canvas-auto-stroke-toggle-btn');
            const canvasAutoRefOpacityToggleBtn = document.getElementById('canvas-auto-ref-opacity-toggle-btn');
            const autoStrokeStyleSelect = document.getElementById('auto-stroke-style-select');
            const autoStrokeDensitySlider = document.getElementById('auto-stroke-density-slider');
            const autoStrokeUturnSlider = document.getElementById('auto-stroke-uturn-slider');
            const autoStrokeUturnValue = document.getElementById('auto-stroke-uturn-value');

            // --- Shade Mode DOM Elements ---
            const shadeOpacitySlider = document.getElementById('shade-opacity-slider');
            const shadeOpacityValue = document.getElementById('shade-opacity-value');
            const shadeWidthSlider = document.getElementById('shade-width-slider');
            const shadeWidthValue = document.getElementById('shade-width-value');
            const shadeSmoothnessSlider = document.getElementById('shade-smoothness-slider');
            const shadeSmoothnessValue = document.getElementById('shade-smoothness-value');
            const shadeDarkenSlider = document.getElementById('shade-darken-slider');
            const shadeDarkenValue = document.getElementById('shade-darken-value');
            const shadeDarkenContainer = document.getElementById('shade-darken-container');

            // --- NEW: Bottom Left Undo/Redo DOM Elements ---
            const bottomLeftUndoBtn = document.getElementById('bottom-left-undo-btn');
            const bottomLeftRedoBtn = document.getElementById('bottom-left-redo-btn');
            const strokeWidthMinusBtn = document.getElementById('stroke-width-minus-btn');
            const strokeWidthPlusBtn = document.getElementById('stroke-width-plus-btn');
            const bottomLeftStrokeWidthValue = document.getElementById('bottom-left-stroke-width-value');

            // --- NEW: Fullscreen DOM Elements ---
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
            const fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');

            // --- NEW: Floating Color Palette DOM Elements ---
            const floatingColorPaletteToggle = document.getElementById('floating-color-palette-toggle');
            const shortcutSelectionVisibilityBtn = document.getElementById('shortcut-selection-visibility-btn');
            const selectionHiddenIcon = document.getElementById('selection-hidden-icon');
            const floatingColorPaletteContainer = document.getElementById('floating-color-palette-container');
            const floatingPaletteCloseBtn = document.getElementById('floating-palette-close-btn');
            const floatingCustomColorInput = document.getElementById('floating-custom-color-input');
            const floatingPaletteColors = document.getElementById('floating-palette-colors');

            // --- NEW: Background Image DOM Elements ---
            const bgImageUpload = document.getElementById('bg-image-upload');
            const uploadBgImageBtn = document.getElementById('upload-bg-image-btn');
            const bgImageControls = document.getElementById('bg-image-controls');
            const bgOpacitySlider = document.getElementById('bg-opacity-slider');
            const bgOpacityValue = document.getElementById('bg-opacity-value');
            const deleteBgImageBtn = document.getElementById('delete-bg-image-btn');

            let drawingLayer, maskedStrokesLayer, previewLayer, defs, imageMask, colorPicker;
            let colorPickerImage = null;
            let refModeImage = null; // Reference Mode overlay image

            // --- State Variables ---
            let db = null;
            let currentProjectId = null;
            let currentProjectName = 'Untitled Project';
            let isDirty = false;
            let autoSaveIntervalId = null;
            let currentTool = 'pencil';
            let currentColor = '#000000';
            let selectedBaseColor = '#000000';
            let currentStrokeWidth = 2;
            let currentStrokeOpacity = 1.0; // NEW
            let currentStrokeBlur = 0; // NEW
            let pathTolerance = 1.5;
            let fixedNodeCount = 10;
            let history = [];
            let historyIndex = -1;
            let drawingHistory = []; // NEW: Separate history for drawing actions
            let drawingHistoryIndex = -1;
            let selectionHistory = []; // NEW: Separate history for selection actions
            let selectionHistoryIndex = -1;
            let referenceImage = null;
            let currentSelectionClipPathId = null; // Track current selection clipPath ID
            let currentSelectionPathData = null; // Track current selection smooth path data

            // --- NEW: Background Image State ---
            let bgImageHref = null;
            let bgImageState = { opacity: 1.0, visible: true };
            let bgImageLayer = null;

            // --- NEW: Preview Image State ---
            let previewImageHref = null;
            let previewImageState = { x: 100, y: 100, width: 200, height: 200, baseWidth: 200, baseHeight: 200, visible: true, zoom: 1.0, panX: 0, panY: 0 };

            // --- NEW: Unified Pin System for All Images ---
            let pinnedImageStates = {
                tracingImage: null,     // For main tracing/reference image
                colorRefImage: null,    // For color reference image
                previewImage: null      // For preview image
            };
            let activeImageType = null; // Tracks which image is currently active/selected

            // --- NEW: Color Usage Tracking ---
            let colorUsageMap = new Map(); // Tracks color usage frequency 

            // --- Interaction State ---
            let viewBox = { x: 0, y: 0, w: 1000, h: 1000 };
            const activePointers = new Map();

            let lastPinchDist = null;
            let lastMidPoint = null;

            let panStartPoint = null;
            let interactionState = 'idle';

            let currentPath, points = [];

            const referenceImageCanvas = document.createElement('canvas');
            const referenceImageCtx = referenceImageCanvas.getContext('2d', { willReadFrequently: true });

            let stickyPencilActive = false;
            let isStickyDrawing = false;
            let isTempPencilActive = false;
            let wetPaintEnabled = false;
            let waterMixEnabled = false;
            let glossyEffectEnabled = false;
            let glitterEffectEnabled = false;
            let zeroOpacityStrokesEnabled = false; // Default: OFF
            let fillShrinkAmount = 0; // Amount to shrink the fill (in pixels)
            let autoColorPickMode = false; // Auto color pick mode for wand
            let wandWMode = false; // Wand W mode: select by black line boundaries instead of color
            let currentColorFilter = 'none'; // Current color filter: 'none', 'sepia', 'vintage', 'teal-orange', 'luminosity'
            let filterEnabled = false; // Whether filter is currently enabled
            let deleteFillOnExport = false; // Delete fills when exporting (deprecated, kept for settings compatibility)
            let importedSvgPaths = []; // Track imported SVG paths for deletion
            let savedTraceOpacity = 1.0; // Save trace opacity when wand is selected
            let forceBlackStrokeEnabled = false; // Force black stroke on export
            let blackOutlineModeEnabled = false; // Use black for outlines in ref mode
            let isSelectionVisible = true; // Toggle for selection outline visibility

            // --- NEW Snap State ---
            let snapToOutlineEnabled = false,
                snapStrength = 1.0; // default to very weak

            // --- NEW: Wet Paint Shadow Settings ---
            let wetPaintOuterShadowSize = 1.2;
            let wetPaintOuterShadowBlur = 0.35;
            let wetPaintInnerShadowSize = 0.5;
            let wetPaintInnerShadowBlur = 0.4;

            // --- NEW: Water Mix Shadow Settings ---
            let waterMixShadowSize = 0.6;
            let waterMixShadowBlur = 0.4;
            let waterMixShadowOpacity = 0.15;
            let waterMixStrength = 0.3;
            let waterMixHighlightEnabled = false;
            let waterMixHighlightOpacity = 0.5;
            let waterMixHighlightSize = 0.6;
            let waterMixHighlightBlur = 0.0;

            // --- NEW: Glitter Settings State ---
            let glitterDensity = 0.45;
            let glitterSize = 3.0;
            let glitterStarCount = 0.5;

            // --- NEW Mask Brush State ---
            let maskBrushSize = 20;
            let maskOpacity = 0.8; // Default to higher visibility
            let tempMaskPaths = [];
            let maskOverlayLayer = null;

            // --- Double Click/Touch Detection for Mode Switching ---
            let lastClickTime = 0;
            let lastClickX = 0;
            let lastClickY = 0;
            let doubleClickThreshold = 300; // milliseconds
            let doubleClickDistance = 20; // pixels

            // --- Color Picker State ---
            let tempColorImageHref = null;
            let colorRefImageState = { x: 0, y: 0, width: 1000, height: 1000, opacity: 1.0 };
            let isEditingColorRef = false;

            // --- Reference Mode State ---
            let refModeEnabled = false;
            let refModeCurrentColor = null; // Current color being used in ref mode
            let refModeColorTolerance = 50; // Color difference tolerance (0-255 per channel) - increased to ignore tiny differences
            let refModeInitialColor = null; // Initial color picked when starting to draw (for current path)
            let currentSelectionType = null; // 'wand-1' or 'wand-2'
            let autoStrokePathEnabled = true; // Auto stroke path mode
            let autoStrokeStyle = 'uniform'; // Auto stroke style: uniform, organic, scribble
            let autoStrokeDensity = 8; // Auto stroke density (spacing)
            let autoStrokeUturnMultiplier = 1.99; // Auto stroke u-turn step multiplier

            // --- Wand Button Draggable State ---
            let isWandBtnDragging = false;
            let hasWandBtnMoved = false; // NEW: Track if it was dragged or just clicked
            let wandBtnStartPointerPos = { x: 0, y: 0 }; // NEW: Pointer start for move detection
            let wandBtnStartOffset = { x: 0, y: 0 };
            let wandBtnManualPos = null;

            // --- Shade Mode State ---
            let isShadeMode = false;
            let mainSettingsBackup = null;
            let shadeSettings = {
                opacity: 0.5,
                width: 20,
                smoothness: 10,
                darkenAmount: 0.2
            };
            let mainColorBackup = null;

            // Helper to darken a hex color by a percentage (0-1)
            function getDarkenedColor(hex, amount) {
                // Remove # if present
                hex = hex.replace(/^#/, '');

                // Parse RGB
                let r = parseInt(hex.substring(0, 2), 16);
                let g = parseInt(hex.substring(2, 4), 16);
                let b = parseInt(hex.substring(4, 6), 16);

                // Multiply by (1 - amount)
                const factor = 1 - amount;
                r = Math.floor(r * factor);
                g = Math.floor(g * factor);
                b = Math.floor(b * factor);

                // Ensure bounds
                r = Math.max(0, Math.min(255, r));
                g = Math.max(0, Math.min(255, g));
                b = Math.max(0, Math.min(255, b));

                // Convert back to hex
                return '#' + [r, g, b].map(x => {
                    const h = x.toString(16);
                    return h.length === 1 ? '0' + h : h;
                }).join('');
            }

            function saveCurrentSettings(type = 'main') {
                if (type === 'main') {
                    // FULL SNAPSHOT: Save everything exactly as it is now (General state)
                    mainSettingsBackup = getSettings();
                } else {
                    // Update the persistent shade object with current transient values
                    shadeSettings.opacity = currentStrokeOpacity;
                    shadeSettings.width = currentStrokeWidth;
                    shadeSettings.smoothness = pathTolerance;
                    // darkenAmount is updated via its own listeners, so we preserve it
                }
            }

            function restoreCurrentSettings(type = 'main') {
                const settings = (type === 'main') ? mainSettingsBackup : shadeSettings;
                if (!settings) return;

                // Update global state - handle both snapshot format and shade settings format
                currentStrokeOpacity = settings.opacity ?? settings.strokeOpacity;
                currentStrokeWidth = settings.width ?? settings.strokeWidth;
                pathTolerance = settings.smoothness ?? settings.pathTolerance;

                // If restoring main, we can also restore the color
                if (type === 'main' && settings.color) {
                    selectedBaseColor = settings.color;
                    colorPicker.value = selectedBaseColor;
                    currentColor = selectedBaseColor;
                }

                // NEW: Restore Filter States when exiting Shade Mode
                if (type === 'main') {
                    if (settings.wetPaintEnabled !== undefined) wetPaintEnabled = settings.wetPaintEnabled;
                    if (settings.waterMixEnabled !== undefined) waterMixEnabled = settings.waterMixEnabled;
                    if (settings.glitterEffectEnabled !== undefined) glitterEffectEnabled = settings.glitterEffectEnabled;

                    // Update UI buttons
                    const wpBtn = document.getElementById('wet-paint-tool');
                    const wmBtn = document.getElementById('water-mix-tool');
                    const glBtn = document.getElementById('glitter-effect-tool');

                    if (wpBtn) wpBtn.classList.toggle('active', wetPaintEnabled);
                    if (wmBtn) wmBtn.classList.toggle('active', waterMixEnabled);
                    if (glBtn) glBtn.classList.toggle('active', glitterEffectEnabled);

                    updateEffectSettingsVisibility();
                    if (window.updateGlitterFilters) updateGlitterFilters();
                }

                // Update UI - Main Sidebar Sliders
                if (strokeOpacitySlider) {
                    strokeOpacitySlider.value = currentStrokeOpacity;
                    strokeOpacityValue.textContent = currentStrokeOpacity.toFixed(2);
                }
                if (strokeWidthSlider) {
                    strokeWidthSlider.value = currentStrokeWidth;
                    strokeWidthValue.textContent = `${currentStrokeWidth}px`;
                }
                if (simplifySlider) {
                    simplifySlider.value = pathTolerance;
                    simplifyValue.textContent = pathTolerance.toFixed(1);
                }

                // Update UI - Bottom Left/Shortcuts
                if (bottomLeftStrokeWidthValue) {
                    bottomLeftStrokeWidthValue.textContent = `${Math.round(currentStrokeWidth)}px`;
                }
                if (wandPencilSlider) {
                    wandPencilSlider.value = currentStrokeWidth;
                    wandPencilSliderValue.textContent = `${currentStrokeWidth}px`;
                }

                // Update UI - Shade Panel Sliders
                if (shadeOpacitySlider) {
                    shadeOpacitySlider.value = settings.opacity;
                    shadeOpacityValue.textContent = settings.opacity.toFixed(2);
                }
                if (shadeWidthSlider) {
                    shadeWidthSlider.value = settings.width;
                    shadeWidthValue.textContent = `${settings.width}px`;
                }
                if (shadeDarkenSlider && settings.darkenAmount !== undefined) {
                    shadeDarkenSlider.value = Math.round(settings.darkenAmount * 100);
                    shadeDarkenValue.textContent = `${Math.round(settings.darkenAmount * 100)}%`;
                }
                if (shadeSmoothnessSlider) {
                    shadeSmoothnessSlider.value = settings.smoothness;
                    shadeSmoothnessValue.textContent = settings.smoothness.toFixed(1);
                }
            }

            // --- PROJECTS CACHE ---
            let cachedProjects = null; // Cached projects data for instant modal opening

            // --- CLEANUP TRACKING ---
            let cleanupFunctions = []; // Track cleanup functions for proper disposal
            let memoryCheckInterval = null; // Periodic memory check interval

            // --- CACHING SYSTEM ---
            const CACHE = {
                wand: {}, // Cache wand selection masks by key (x,y,tolerance,imageHash)
                fills: {}, // Cache fill operations by key (x,y,color,tolerance,imageHash)
                strokes: {}, // Cache simplified stroke points by path element ID
                wetPaint: {}, // Cache wet paint filter bitmaps by filterId
                imageMasks: {}, // Cache image masks by imageHash
                svgParsed: null, // Cached parsed SVG document
                marchingAntsPath: null, // Cached marching ants path
                rasterCanvas: null, // OffscreenCanvas for raster operations
                rasterCtx: null, // Context for raster canvas
                refModeOutlines: null, // Cached ref mode outline data
                previewTransforms: null, // Cached preview image transforms
                svgRendered: null, // Cached rendered SVG as ImageData
                colorLookup: {}, // Fast color lookup table
                pathSimplified: {}, // Pre-simplified paths cache
                imageDataCache: {}, // Cached ImageData objects
                domQueries: {}, // Cached DOM query results
                computedStyles: {} // Cached computed styles
            };

            // --- SMART MEMORY & PERFORMANCE SYSTEM ---
            const SmartMemory = {
                maxHistoryStates: 10, // Reduced to 10 for simple/stable performance
                maxCacheEntries: 10, // Reduced to 10
                maxImageDataCache: 3, // Limit ImageData cache (very memory intensive)
                maxPathCacheEntries: 50, // Reduced to 50
                maxPointsPerPath: 5000, // Limit points per path to prevent memory issues
                cacheCleanupThreshold: 0.5, // Clean cache when 50% full

                // LRU cache for ImageData (most memory intensive)
                imageDataLRU: [],

                // Check and optimize memory usage
                checkMemory: function () {
                    // 1. Trim History - Enforce strictly
                    if (history.length > this.maxHistoryStates) {
                        history = history.slice(history.length - this.maxHistoryStates);
                        historyIndex = Math.min(historyIndex, history.length - 1);
                    }

                    // Trim specialized histories
                    if (drawingHistory.length > this.maxHistoryStates) {
                        drawingHistory = drawingHistory.slice(drawingHistory.length - this.maxHistoryStates);
                        drawingHistoryIndex = Math.min(drawingHistoryIndex, drawingHistory.length - 1);
                    }
                    if (selectionHistory.length > this.maxHistoryStates) {
                        selectionHistory = selectionHistory.slice(selectionHistory.length - this.maxHistoryStates);
                        selectionHistoryIndex = Math.min(selectionHistoryIndex, selectionHistory.length - 1);
                    }

                    // 2. Manage Cache Size with aggressive cleanup
                    this.trimCache(CACHE.wand);
                    this.trimCache(CACHE.fills);
                    this.trimPathCache(CACHE.pathSimplified);
                    this.trimImageDataCache(CACHE.imageDataCache);

                    // 3. Clear heavy temporary caches proactively
                    if (history.length >= this.maxHistoryStates) {
                        CACHE.svgRendered = null;
                        CACHE.marchingAntsPath = null; // Clear marching ants cache
                    }

                    // 4. Cleanup DOM if too complex
                    this.checkDOM();

                    // 5. Force garbage collection hint (if available)
                    if (window.gc && typeof window.gc === 'function') {
                        // Only call in development or if explicitly available
                    }
                },

                trimCache: function (cacheObj) {
                    const keys = Object.keys(cacheObj);
                    const threshold = Math.floor(this.maxCacheEntries * this.cacheCleanupThreshold);
                    if (keys.length > threshold) {
                        // Remove oldest 40% of entries when over threshold
                        const toRemove = keys.slice(0, Math.floor(keys.length * 0.4));
                        toRemove.forEach(k => delete cacheObj[k]);
                    }
                },

                trimPathCache: function (cacheObj) {
                    const keys = Object.keys(cacheObj);
                    if (keys.length > this.maxPathCacheEntries) {
                        // Remove oldest 50% when over limit
                        const toRemove = keys.slice(0, Math.floor(this.maxPathCacheEntries * 0.5));
                        toRemove.forEach(k => delete cacheObj[k]);
                    }
                },

                trimImageDataCache: function (cacheObj) {
                    const keys = Object.keys(cacheObj);
                    if (keys.length > this.maxImageDataCache) {
                        // Remove oldest entries (ImageData is very memory intensive)
                        const toRemove = keys.slice(0, keys.length - this.maxImageDataCache);
                        toRemove.forEach(k => {
                            // Properly dispose of ImageData
                            if (cacheObj[k] && cacheObj[k].imageData) {
                                cacheObj[k].imageData = null;
                            }
                            delete cacheObj[k];
                        });
                    }
                },

                // Optimize DOM: Check for too many paths
                checkDOM: function () {
                    if (drawingLayer && drawingLayer.children.length > 1500) {
                        // Suggest cleanup if DOM is getting too complex
                        // Could trigger auto-bake here in future
                    }
                },

                // Cleanup function for memory release
                cleanup: function () {
                    // Clear all caches
                    Object.keys(CACHE).forEach(key => {
                        if (typeof CACHE[key] === 'object' && CACHE[key] !== null && !Array.isArray(CACHE[key])) {
                            const cacheObj = CACHE[key];
                            if (key === 'imageDataCache') {
                                // Special cleanup for ImageData
                                Object.keys(cacheObj).forEach(k => {
                                    if (cacheObj[k] && cacheObj[k].imageData) {
                                        cacheObj[k].imageData = null;
                                    }
                                });
                            }
                            Object.keys(cacheObj).forEach(k => delete cacheObj[k]);
                        } else if (key !== 'rasterCanvas' && key !== 'rasterCtx') {
                            CACHE[key] = null;
                        }
                    });

                    // Clear history arrays
                    history = [];
                    drawingHistory = [];
                    selectionHistory = [];
                    historyIndex = -1;
                    drawingHistoryIndex = -1;
                    selectionHistoryIndex = -1;

                    // Clear points array
                    points = [];
                }
            };

            // Performance optimization: Debounce and throttle functions
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            function throttle(func, limit) {
                let inThrottle;
                return function (...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            }

            // Object pool for frequently created objects
            const objectPool = {
                points: [],
                getPoint: function () {
                    return this.points.pop() || { x: 0, y: 0 };
                },
                releasePoint: function (point) {
                    if (this.points.length < 100) { // Limit pool size
                        point.x = 0;
                        point.y = 0;
                        this.points.push(point);
                    }
                },
                paths: [],
                getPath: function () {
                    return this.paths.pop() || [];
                },
                releasePath: function (path) {
                    if (this.paths.length < 50) {
                        path.length = 0;
                        this.paths.push(path);
                    }
                }
            };

            // Fast color conversion cache
            const colorCache = {
                hexToRgb: new Map(),
                rgbToHex: new Map()
            };

            function fastHexToRgb(hex) {
                if (colorCache.hexToRgb.has(hex)) {
                    return colorCache.hexToRgb.get(hex);
                }
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                const rgb = result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
                colorCache.hexToRgb.set(hex, rgb);
                return rgb;
            }

            function fastRgbToHex(r, g, b) {
                const key = `${r},${g},${b}`;
                if (colorCache.rgbToHex.has(key)) {
                    return colorCache.rgbToHex.get(key);
                }
                const hex = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
                colorCache.rgbToHex.set(key, hex);
                return hex;
            }

            // Pre-compute and cache SVG rendering
            let svgRenderCache = null;
            let svgRenderCacheTimestamp = 0;

            function getCachedSvgRender() {
                if (svgRenderCache && Date.now() - svgRenderCacheTimestamp < 100) {
                    return svgRenderCache;
                }
                return null;
            }

            function cacheSvgRender(imageData) {
                svgRenderCache = imageData;
                svgRenderCacheTimestamp = Date.now();
            }

            // Cached DOM queries
            function getCachedQuery(selector, cacheKey) {
                if (!CACHE.domQueries[cacheKey]) {
                    CACHE.domQueries[cacheKey] = document.querySelector(selector);
                }
                return CACHE.domQueries[cacheKey];
            }

            // Clear DOM query cache when needed
            function clearDomQueryCache() {
                CACHE.domQueries = {};
            }

            // Optimized getBoundingClientRect with caching
            let cachedRect = null;
            let cachedRectTimestamp = 0;
            const RECT_CACHE_DURATION = 16; // ~60fps

            function getCachedBoundingRect(element) {
                const now = Date.now();
                if (cachedRect && (now - cachedRectTimestamp) < RECT_CACHE_DURATION) {
                    return cachedRect;
                }
                // Ensure element is connected before measuring
                if (!element.isConnected) return { left: 0, top: 0, width: 0, height: 0 };
                cachedRect = element.getBoundingClientRect();
                cachedRectTimestamp = now;
                return cachedRect;
            }

            // Pre-compute viewBox calculations
            let cachedViewBoxScale = null;
            function getViewBoxScale() {
                if (cachedViewBoxScale === null) {
                    cachedViewBoxScale = {
                        x: viewBox.x,
                        y: viewBox.y,
                        w: viewBox.w,
                        h: viewBox.h,
                        scaleX: canvasContainer.clientWidth / viewBox.w,
                        scaleY: canvasContainer.clientHeight / viewBox.h
                    };
                }
                return cachedViewBoxScale;
            }

            // Invalidate viewBox cache when viewBox changes
            function invalidateViewBoxCache() {
                cachedViewBoxScale = null;
            }

            // Initialize OffscreenCanvas for bitmap caching (fallback to regular canvas if not supported)
            let offscreenCanvas = null;
            let offscreenCtx = null;
            try {
                if (typeof OffscreenCanvas !== 'undefined') {
                    offscreenCanvas = new OffscreenCanvas(4096, 4096);
                    offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
                } else {
                    // Fallback to regular canvas
                    offscreenCanvas = document.createElement('canvas');
                    offscreenCanvas.width = 4096;
                    offscreenCanvas.height = 4096;
                    offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
                }
                CACHE.rasterCanvas = offscreenCanvas;
                CACHE.rasterCtx = offscreenCtx;
            } catch (e) {
                console.warn("OffscreenCanvas not supported, using regular canvas:", e);
                offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = 4096;
                offscreenCanvas.height = 4096;
                offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });
                CACHE.rasterCanvas = offscreenCanvas;
                CACHE.rasterCtx = offscreenCtx;
            }

            let longPressTimer = null;
            let isLongPress = false;
            const longPressDuration = 500; // ms

            // --- NEW Selection State ---
            let drawingLayerVersion = 0; // Version counter for drawing layer changes
            let renderCanvas = null; // Reusable canvas for SVG rendering
            let renderCtx = null; // Reusable context
            let selectionMask = null;
            let selectionMaskWidth = 0;
            let selectionMaskHeight = 0;
            let selectionPath = null;
            let selectionViewBox = null;
            let selectionBounds = null;
            let selectionShrinkAmount = 0; // Amount to shrink the selection (in pixels)
            let cachedShrunkMask = null; // Cached shrunk mask to avoid recalculating on every point check
            let antsAnimationId = null;

            // NEW: Performance optimization - throttle cache invalidation
            let lastCacheInvalidationTime = 0;
            const CACHE_INVALIDATION_THROTTLE_MS = 100; // Throttle to max once per 100ms

            // NEW: Debounce marching ants restart to prevent excessive restarts during pan/zoom
            let marchingAntsDebouncerId = null;
            const MARCHING_ANTS_DEBOUNCE_MS = 50;

            // --- NEW: Outline selection + auto-width pencil state ---
            let outlineSelectionMask = null; // Mask specifically for black outline selection (wand 2)
            let outlineSelectionWidth = 0;

            // --- NEW: Multi-Wand Mode State ---
            let multiWandMode = false; // Whether multi-wand mode is active
            let multiWandLongPressTimer = null; // Timer for detecting long press
            let multiWandLongPressThreshold = 500; // Long press threshold in milliseconds
            let multiWandIsLongPressing = false; // Track if long press is active
            let multiWandSavedTool = null; // Save the tool to restore after long press

            // --- CACHE MANAGEMENT FUNCTIONS ---
            function generateCacheKey(prefix, ...args) {
                return `${prefix}_${args.map(a => String(a)).join('_')}`;
            }

            function getImageHash(imageElement) {
                if (!imageElement) return 'noimage';
                const href = imageElement.getAttribute('href') || imageElement.getAttribute('xlink:href') || '';
                // Create a simple hash from image properties
                const width = imageElement.getAttribute('width') || '0';
                const height = imageElement.getAttribute('height') || '0';
                const x = imageElement.getAttribute('x') || '0';
                const y = imageElement.getAttribute('y') || '0';
                return `${href.substring(0, 50)}_${width}_${height}_${x}_${y}`.replace(/[^a-zA-Z0-9_]/g, '_');
            }

            function saveWandMaskToCache(x, y, tolerance, imageHash, mask, imageData, bounds, width, height) {
                const key = generateCacheKey('wand', x, y, tolerance, imageHash);
                CACHE.wand[key] = {
                    mask: mask ? new Uint8Array(mask) : null,
                    imageData: imageData ? new ImageData(
                        new Uint8ClampedArray(imageData.data),
                        imageData.width,
                        imageData.height
                    ) : null,
                    bounds: bounds ? { ...bounds } : null,
                    width: width || (imageData ? imageData.width : null),
                    height: height || (imageData ? imageData.height : null),
                    timestamp: Date.now()
                };
            }

            function getWandMaskFromCache(x, y, tolerance, imageHash) {
                const key = generateCacheKey('wand', x, y, tolerance, imageHash);
                const cached = CACHE.wand[key];
                if (cached) {
                    try {
                        let imageData = null;
                        if (cached.imageData) {
                            // Check if it's already an ImageData object or needs to be created
                            if (cached.imageData instanceof ImageData) {
                                imageData = cached.imageData;
                            } else if (cached.imageData.data && cached.imageData.width && cached.imageData.height) {
                                imageData = new ImageData(
                                    new Uint8ClampedArray(cached.imageData.data),
                                    cached.imageData.width,
                                    cached.imageData.height
                                );
                            }
                        }
                        return {
                            mask: cached.mask ? new Uint8Array(cached.mask) : null,
                            imageData: imageData,
                            bounds: cached.bounds ? { ...cached.bounds } : null,
                            width: cached.width || (imageData ? imageData.width : null),
                            height: cached.height || (imageData ? imageData.height : null)
                        };
                    } catch (e) {
                        console.warn("Failed to get wand mask from cache:", e);
                        return null;
                    }
                }
                return null;
            }

            function saveFillToCache(x, y, color, tolerance, imageHash, fillMask, fillPath) {
                const key = generateCacheKey('fill', x, y, color, tolerance, imageHash);
                CACHE.fills[key] = {
                    mask: fillMask ? new Uint8Array(fillMask) : null,
                    path: fillPath ? fillPath.cloneNode(true) : null,
                    timestamp: Date.now()
                };
            }

            function getFillFromCache(x, y, color, tolerance, imageHash) {
                const key = generateCacheKey('fill', x, y, color, tolerance, imageHash);
                const cached = CACHE.fills[key];
                if (cached) {
                    try {
                        let path = null;
                        if (cached.path) {
                            // Check if it's already an SVG element or needs to be parsed
                            if (cached.path.cloneNode) {
                                path = cached.path.cloneNode(true);
                            } else if (typeof cached.path === 'string') {
                                // It's HTML string, parse it
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(cached.path, 'image/svg+xml');
                                path = doc.querySelector('path');
                            }
                        }
                        return {
                            mask: cached.mask ? new Uint8Array(cached.mask) : null,
                            path: path
                        };
                    } catch (e) {
                        console.warn("Failed to get fill from cache:", e);
                        return null;
                    }
                }
                return null;
            }

            function saveStrokeToCache(pathElement, simplifiedPoints, pathData) {
                if (!pathElement) return;
                const pathId = pathElement.getAttribute('data-cache-id') || `path_${Date.now()}_${Math.random()}`;
                pathElement.setAttribute('data-cache-id', pathId);
                CACHE.strokes[pathId] = {
                    points: simplifiedPoints ? simplifiedPoints.map(p => ({ ...p })) : null,
                    pathData: pathData || null,
                    timestamp: Date.now()
                };
            }

            function getStrokeFromCache(pathElement) {
                if (!pathElement) return null;
                const pathId = pathElement.getAttribute('data-cache-id');
                if (!pathId) return null;
                const cached = CACHE.strokes[pathId];
                if (cached) {
                    return {
                        points: cached.points ? cached.points.map(p => ({ ...p })) : null,
                        pathData: cached.pathData || null
                    };
                }
                return null;
            }

            function saveWetPaintToCache(filterId, bitmap) {
                if (!filterId || !bitmap) return;
                CACHE.wetPaint[filterId] = {
                    bitmap: bitmap, // Store the bitmap/canvas reference
                    timestamp: Date.now()
                };
            }

            function getWetPaintFromCache(filterId) {
                if (!filterId) return null;
                return CACHE.wetPaint[filterId] ? CACHE.wetPaint[filterId].bitmap : null;
            }

            function saveSvgParseToCache(svgText, parsedDoc) {
                if (!svgText || !parsedDoc) return;
                CACHE.svgParsed = {
                    text: svgText,
                    doc: parsedDoc,
                    timestamp: Date.now()
                };
            }

            function getSvgParseFromCache(svgText) {
                if (CACHE.svgParsed && CACHE.svgParsed.text === svgText) {
                    return CACHE.svgParsed.doc.cloneNode(true);
                }
                return null;
            }

            function saveMarchingAntsPath(path, viewBox) {
                if (!path) return;
                try {
                    // Path2D cannot be cloned, so we store it directly
                    // Note: Path2D cannot be serialized, so it won't persist across page reloads
                    CACHE.marchingAntsPath = {
                        path: path, // Store Path2D directly (not serializable)
                        viewBox: viewBox ? { ...viewBox } : null,
                        timestamp: Date.now()
                    };
                } catch (e) {
                    console.warn("Failed to save marching ants path:", e);
                }
            }

            function getMarchingAntsPath() {
                if (CACHE.marchingAntsPath && CACHE.marchingAntsPath.path) {
                    try {
                        // Path2D cannot be cloned, return the stored path directly
                        return {
                            path: CACHE.marchingAntsPath.path,
                            viewBox: CACHE.marchingAntsPath.viewBox ?
                                { ...CACHE.marchingAntsPath.viewBox } : null
                        };
                    } catch (e) {
                        console.warn("Failed to get marching ants path:", e);
                        return null;
                    }
                }
                return null;
            }

            function renderFromCache(canvas, ctx, cacheKey, renderFn) {
                if (!canvas || !ctx) return false;

                // Try to get cached bitmap
                const cached = CACHE[cacheKey];
                if (cached && cached.bitmap) {
                    try {
                        ctx.drawImage(cached.bitmap, 0, 0);
                        return true;
                    } catch (e) {
                        console.warn("Failed to render from cache, recalculating:", e);
                    }
                }

                // If no cache or render failed, use render function and cache result
                if (renderFn) {
                    renderFn(ctx);

                    // Cache the result as bitmap
                    if (canvas.width > 0 && canvas.height > 0) {
                        try {
                            const bitmap = new ImageData(
                                ctx.getImageData(0, 0, canvas.width, canvas.height).data,
                                canvas.width,
                                canvas.height
                            );
                            if (!CACHE[cacheKey]) CACHE[cacheKey] = {};
                            CACHE[cacheKey].bitmap = bitmap;
                            CACHE[cacheKey].timestamp = Date.now();
                        } catch (e) {
                            console.warn("Failed to cache render result:", e);
                        }
                    }
                }

                return false;
            }

            // --- NEW: Snap Point to Outline Helper ---
            function snapPointToOutline(svgPt, mask, width, height, strength) {
                if (!selectionViewBox) return null;

                // Map SVG point to mask coordinates
                // Assuming mask covers the selectionViewBox (which is usually the full viewBox for Wand 2)
                const maskX = Math.floor((svgPt.x - selectionViewBox.x) * (width / selectionViewBox.w));
                const maskY = Math.floor((svgPt.y - selectionViewBox.y) * (height / selectionViewBox.h));

                if (maskX < 0 || maskX >= width || maskY < 0 || maskY >= height) return null;

                // Optimization: Check if already on an outline pixel
                if (mask[maskY * width + maskX] === 1) return svgPt;

                const normalizedStrength = Math.max(0, Math.min(1, strength / 10));

                if (!normalizedStrength) return null;

                const minRadius = 3;
                const maxRadius = 60;
                const radius = minRadius + (maxRadius - minRadius) * (normalizedStrength * normalizedStrength);

                let minDistSq = radius * radius;
                let bestX = -1, bestY = -1;

                // Search radius in mask pixels (approximate, assuming 1:1 aspect ratio for simplicity in search)
                // Ideally we should scale radius to mask pixels, but for now we assume roughly 1:1 or use the slider value as "mask pixels" directly
                // Since antsCanvas is usually high res, we might need to scale radius up if it's in SVG units?
                // The slider is 1-50. Let's treat it as mask pixels for now.

                // If radius is <= 0 then snapping is effectively OFF
                if (!radius || radius <= 0) return null;
                const r = Math.ceil(radius);
                const startY = Math.max(0, maskY - r);
                const endY = Math.min(height - 1, maskY + r);
                const startX = Math.max(0, maskX - r);
                const endX = Math.min(width - 1, maskX + r);

                for (let y = startY; y <= endY; y++) {
                    for (let x = startX; x <= endX; x++) {
                        if (mask[y * width + x] === 1) {
                            const dx = x - maskX;
                            const dy = y - maskY;
                            const distSq = dx * dx + dy * dy;
                            if (distSq <= minDistSq) {
                                minDistSq = distSq;
                                bestX = x;
                                bestY = y;
                            }
                        }
                    }
                }

                if (bestX !== -1) {
                    // Convert back to SVG coordinates
                    return {
                        x: selectionViewBox.x + (bestX + 0.5) * (selectionViewBox.w / width),
                        y: selectionViewBox.y + (bestY + 0.5) * (selectionViewBox.h / height)
                    };
                }

                return null;
            }

            // --- NEW: Estimate outline thickness around a given pixel in the selection mask ---
            function estimateOutlineThickness(mask, width, height, x, y) {
                const idx = y * width + x;
                if (!mask || mask[idx] !== 1) return 0;

                // Scan horizontally
                let left = x;
                while (left - 1 >= 0 && mask[y * width + (left - 1)] === 1) {
                    left--;
                }
                let right = x;
                while (right + 1 < width && mask[y * width + (right + 1)] === 1) {
                    right++;
                }
                const horiz = right - left + 1;

                // Scan vertically
                let top = y;
                while (top - 1 >= 0 && mask[(top - 1) * width + x] === 1) {
                    top--;
                }
                let bottom = y;
                while (bottom + 1 < height && mask[(bottom + 1) * width + x] === 1) {
                    bottom++;
                }
                const vert = bottom - top + 1;

                // Use the larger axis as a safe estimate of local thickness
                return Math.max(horiz, vert);
            }

            // --- NEW: Get Outline Center ---
            function getOutlineCenter(mask, width, height, x, y) {
                const idx = y * width + x;
                if (!mask || mask[idx] !== 1) return { x, y };

                // Scan horizontally
                let left = x;
                while (left - 1 >= 0 && mask[y * width + (left - 1)] === 1) left--;
                let right = x;
                while (right + 1 < width && mask[y * width + (right + 1)] === 1) right++;
                const centerX = (left + right) / 2;

                // Scan vertically
                let top = y;
                while (top - 1 >= 0 && mask[(top - 1) * width + x] === 1) top--;
                let bottom = y;
                while (bottom + 1 < height && mask[(bottom + 1) * width + x] === 1) bottom++;
                const centerY = (top + bottom) / 2;

                const widthH = right - left + 1;
                const heightV = bottom - top + 1;

                let newX = x;
                let newY = y;

                // Center on the axis that is "across" the line (smaller dimension)
                if (widthH < heightV) {
                    // Vertical-ish line -> center Horizontally
                    newX = centerX;
                } else {
                    // Horizontal-ish line -> center Vertically
                    newY = centerY;
                }

                // If roughly equal (blob/corner), center both
                if (Math.abs(widthH - heightV) < 2) {
                    newX = centerX;
                    newY = centerY;
                }

                return { x: newX, y: newY };
            }



            function clearCache(category = null) {
                if (category === null) {
                    // Clear all cache
                    CACHE.wand = {};
                    CACHE.fills = {};
                    CACHE.strokes = {};
                    CACHE.wetPaint = {};
                    CACHE.imageMasks = {};
                    CACHE.svgParsed = null;
                    CACHE.marchingAntsPath = null;
                    CACHE.refModeOutlines = null;
                    CACHE.previewTransforms = null;
                } else if (CACHE[category]) {
                    CACHE[category] = category === 'svgParsed' || category === 'marchingAntsPath' ||
                        category === 'refModeOutlines' || category === 'previewTransforms' ?
                        null : {};
                }
            }

            // Serialize cache for saving to project
            function serializeCache() {
                // SIMPLIFICATION: Do not persist heavy cache items (wand, fills, strokes) to DB.
                // This drastically reduces project size and prevents crashes.
                // We only keep lightweight state like transforms.
                return {
                    wand: {},
                    fills: {},
                    strokes: {},
                    wetPaint: {},
                    imageMasks: {},
                    svgParsed: null,
                    marchingAntsPath: null,
                    refModeOutlines: CACHE.refModeOutlines,
                    previewTransforms: CACHE.previewTransforms
                };
            }

            // Deserialize cache from project
            function deserializeCache(serialized) {
                if (!serialized) {
                    clearCache();
                    return;
                }

                // Clear existing cache
                clearCache();

                // Restore wand cache
                if (serialized.wand) {
                    for (const key in serialized.wand) {
                        try {
                            const cached = serialized.wand[key];
                            let imageData = null;
                            if (cached.imageData && cached.imageData.data && cached.imageData.width && cached.imageData.height) {
                                try {
                                    imageData = new ImageData(
                                        new Uint8ClampedArray(cached.imageData.data),
                                        cached.imageData.width,
                                        cached.imageData.height
                                    );
                                } catch (e) {
                                    console.warn("Failed to restore ImageData for wand cache key:", key, e);
                                }
                            }
                            CACHE.wand[key] = {
                                mask: cached.mask ? new Uint8Array(cached.mask) : null,
                                imageData: imageData,
                                bounds: cached.bounds,
                                timestamp: cached.timestamp
                            };
                        } catch (e) {
                            console.warn("Failed to restore wand cache for key:", key, e);
                        }
                    }
                }

                // Restore fills cache
                if (serialized.fills) {
                    for (const key in serialized.fills) {
                        const cached = serialized.fills[key];
                        if (cached.path) {
                            try {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(cached.path, 'image/svg+xml');
                                const pathElement = doc.querySelector('path');
                                if (pathElement) {
                                    CACHE.fills[key] = {
                                        mask: cached.mask ? new Uint8Array(cached.mask) : null,
                                        path: pathElement,
                                        timestamp: cached.timestamp
                                    };
                                }
                            } catch (e) {
                                console.warn("Failed to restore fill cache for key:", key, e);
                            }
                        }
                    }
                }

                // Restore strokes cache
                if (serialized.strokes) {
                    for (const key in serialized.strokes) {
                        CACHE.strokes[key] = serialized.strokes[key];
                    }
                }

                // Restore other cache items
                CACHE.svgParsed = serialized.svgParsed;
                // Note: marchingAntsPath contains Path2D which cannot be deserialized
                // It will be regenerated when selection is made
                CACHE.marchingAntsPath = null;
                CACHE.refModeOutlines = serialized.refModeOutlines;
                CACHE.previewTransforms = serialized.previewTransforms;
            }

            // --- SETUP ---
            async function initialSetup() {
                clearCache(); // Ensure clean start
                previewLayer = createSvgElement('g', { id: 'preview-layer' });
                drawingLayer = createSvgElement('g', { id: 'drawing-layer' });
                maskedStrokesLayer = createSvgElement('g', { id: 'masked-strokes-layer' });
                drawingLayer.appendChild(maskedStrokesLayer);

                colorPickerImage = createSvgElement('image', {
                    id: 'color-picker-image',
                    'visibility': 'hidden',
                    'opacity': '1.0',
                });

                refModeImage = createSvgElement('image', {
                    id: 'ref-mode-image',
                    'visibility': 'hidden',
                    'opacity': '1.0',
                });

                defs = document.getElementById('svg-canvas').querySelector('defs');
                imageMask = document.getElementById('image-mask');

                // NEW: Mask Brush Layer (Now inside independent high-z SVG)
                const maskOverlaySvg = document.getElementById('mask-overlay-svg');
                maskOverlayLayer = createSvgElement('g', { id: 'mask-overlay-layer', opacity: '0.8' });
                maskOverlaySvg.appendChild(maskOverlayLayer);

                // Ensure maskOverlaySvg has same viewBox as svgCanvas for coordinate synchronization
                maskOverlaySvg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
                maskOverlaySvg.setAttribute('preserveAspectRatio', 'none');

                bgImageLayer = createSvgElement('image', {
                    id: 'bg-image-layer',
                    'visibility': 'hidden',
                    'opacity': '1.0',
                    'preserveAspectRatio': 'xMidYMid slice' // Fill the canvas
                });

                // Append layers to SVG canvas
                // Order: bgImageLayer (very bottom), previewLayer, colorPickerImage, refModeImage, drawingLayer
                svgCanvas.append(bgImageLayer, previewLayer, colorPickerImage, refModeImage, drawingLayer);

                svgCanvas.style.zIndex = '10';
                antsCanvas.style.zIndex = '20';

                toleranceValue.textContent = toleranceSlider.value;

                wandPencilSlider.value = currentStrokeWidth;
                wandPencilSliderValue.textContent = `${currentStrokeWidth}px`;

                setupPalette();
                setupFloatingPalette();
                if (typeof setupRightPalette === 'function') {
                    setupRightPalette();
                }
                loadUiSettings();

                // Initialize settings profiles system
                initProfilesSystem();
                initProfileEventListeners();

                try {
                    await initDB();
                    // Pre-load projects for instant modal opening
                    try {
                        cachedProjects = await loadProjectsFromDB();
                    } catch (e) {
                        console.warn("Failed to pre-load projects:", e);
                        cachedProjects = [];
                    }
                    handleOpenProjectsModal();
                } catch (error) {
                    console.error("Failed to initialize DB:", error);
                    showToast("Error: Could not initialize project database.", true)
                }

                stickyPencilActive = stickyPencilToggle.checked;
                isTempPencilActive = tempStrokeToggle.checked;
                // Default zero opacity strokes to OFF (unchecked)
                zeroOpacityStrokesToggle.checked = false;
                zeroOpacityStrokesEnabled = false;

                forceBlackStrokeEnabled = forceBlackStrokeToggle.checked;
                forceBlackStrokeToggle.addEventListener('change', (e) => {
                    forceBlackStrokeEnabled = e.target.checked;
                    saveUiSettings();
                });

                blackOutlineModeEnabled = blackOutlineModeToggle.checked;
                blackOutlineModeToggle.addEventListener('change', (e) => {
                    blackOutlineModeEnabled = e.target.checked;
                    saveUiSettings();
                });

                // NEW: Set initial opacity/blur
                currentStrokeOpacity = parseFloat(strokeOpacitySlider.value);
                strokeOpacityValue.textContent = currentStrokeOpacity.toFixed(2);
                currentStrokeBlur = parseInt(strokeBlurSlider.value, 10);
                strokeBlurValue.textContent = currentStrokeBlur;

                // Initialize fill shrink
                fillShrinkAmount = parseInt(paintBucketShrinkSlider.value) || 0;
                paintBucketShrinkValue.textContent = `${fillShrinkAmount}px`;

                // Initialize Snap Controls
                if (snapToggle) {
                    snapToggle.addEventListener('change', (e) => {
                        snapToOutlineEnabled = e.target.checked;
                        snapStrengthContainer.style.display = snapToOutlineEnabled ? 'block' : 'none';
                        // Save settings (will be handled by getSettings/saveUiSettings if updated)
                        if (typeof saveUiSettings === 'function') saveUiSettings();
                    });
                }

                if (snapStrengthSlider) {
                    snapStrengthSlider.addEventListener('input', (e) => {
                        snapStrength = parseFloat(e.target.value);
                        if (snapStrengthValue) {
                            // Show one decimal if needed
                            snapStrengthValue.textContent = snapStrength % 1 === 0 ? `${snapStrength}px` : `${snapStrength.toFixed(1)}px`;
                        }
                        if (typeof saveUiSettings === 'function') saveUiSettings();
                    });
                }

                zoomSlider.addEventListener('input', handleSliderZoom);

                if (maskOpacitySlider) {
                    maskOpacitySlider.addEventListener('input', (e) => {
                        maskOpacity = parseInt(e.target.value) / 100;
                        maskOpacityValue.textContent = `${Math.round(maskOpacity * 100)}%`;
                        if (maskOverlayLayer) {
                            maskOverlayLayer.setAttribute('opacity', maskOpacity);
                        }
                    });
                }

                updateCanvasOverlays();
                updateEffectSettingsVisibility();
            }
            function showMainApp() {
                mainAppContainer.classList.remove('hidden');
                mainAppContainer.classList.add('flex');
                handleResize();
                updateCanvasCursor();
                updateCanvasOverlays(); // Ensure controls are visible on mobile/tablet
            }

            // --- DOUBLE CLICK/TOUCH MODE TOGGLE ---
            // Loop between Mask Brush and Pencil 2 modes
            function handleDoubleClickModeSwitch(e) {
                const now = Date.now();
                const rect = getCachedBoundingRect(svgCanvas);
                const currentX = Math.floor(e.clientX - rect.left);
                const currentY = Math.floor(e.clientY - rect.top);

                // Calculate distance from last click
                const distance = Math.sqrt(
                    Math.pow(currentX - lastClickX, 2) + Math.pow(currentY - lastClickY, 2)
                );

                // Check if this is a double-click
                if (now - lastClickTime < doubleClickThreshold && distance < doubleClickDistance) {
                    // This is a double-click - toggle between Mask Brush and Pencil 2
                    if (currentTool === 'mask-brush') {
                        // Switch from Mask Brush to Pencil 2
                        switchTool('pencil-2');
                        showToast('Switched to Pencil Stroke');
                        return true;
                    } else if (currentTool === 'pencil-2') {
                        // Switch from Pencil 2 back to Mask Brush
                        switchTool('mask-brush');
                        showToast('Switched to Mask Brush');
                        return true;
                    }
                }

                // Update last click time and position
                lastClickTime = now;
                lastClickX = currentX;
                lastClickY = currentY;
                return false;
            }

            // --- MULTI-WAND LONG PRESS DETECTION ---
            function startMultiWandLongPress(e) {
                if (!multiWandMode || multiWandIsLongPressing) return;

                multiWandLongPressTimer = setTimeout(() => {
                    multiWandIsLongPressing = true;
                    multiWandSavedTool = currentTool;

                    // Switch to pencil mode for drawing
                    switchTool('pencil');
                    showToast('Drawing Mode - Release to return to selection');

                    // Start drawing immediately
                    startDrawing(e);
                }, multiWandLongPressThreshold);
            }

            function endMultiWandLongPress(e) {
                if (multiWandLongPressTimer) {
                    clearTimeout(multiWandLongPressTimer);
                    multiWandLongPressTimer = null;
                }

                if (multiWandIsLongPressing) {
                    multiWandIsLongPressing = false;

                    // End drawing and restore original tool
                    if (currentTool === 'pencil') {
                        endDrawing();
                    }

                    if (multiWandSavedTool && (multiWandSavedTool === 'magic-wand' || multiWandSavedTool === 'magic-wand-2')) {
                        switchTool(multiWandSavedTool);
                    }
                    multiWandSavedTool = null;
                }
            }

            // --- CORE INTERACTION LOGIC ---
            function onPointerDown(e) {
                // Check for double-click mode switching (Wand 2 -> Mask Brush -> Pencil 2)
                if (handleDoubleClickModeSwitch(e)) {
                    return; // Exit if double-click mode switch was triggered
                }

                // NEW: Check if clicking on preview image (let it handle its own interaction)
                if (previewImageState.visible && referencePreviewImage.classList.contains('visible')) {
                    const containerRect = canvasContainer.getBoundingClientRect();
                    const localX = e.clientX - containerRect.left;
                    const localY = e.clientY - containerRect.top;

                    // Calculate actual image bounds with zoom/pan
                    const baseWidth = previewImageState.baseWidth || previewImageState.width;
                    const baseHeight = previewImageState.baseHeight || previewImageState.height;
                    const zoomedWidth = baseWidth * (previewImageState.zoom || 1.0);
                    const zoomedHeight = baseHeight * (previewImageState.zoom || 1.0);
                    const centerX = previewImageState.x + (previewImageState.baseWidth || previewImageState.width) / 2;
                    const centerY = previewImageState.y + (previewImageState.baseHeight || previewImageState.height) / 2;
                    const finalX = centerX - zoomedWidth / 2 + (previewImageState.panX || 0);
                    const finalY = centerY - zoomedHeight / 2 + (previewImageState.panY || 0);

                    // Check if mouse is over preview image
                    const isOnPreview = localX >= finalX && localX <= finalX + zoomedWidth &&
                        localY >= finalY && localY <= finalY + zoomedHeight;
                    if (isOnPreview) {
                        handlePreviewImagePointerDown(e);
                        return;
                    }
                }

                if (isEditingColorRef) {
                    e.preventDefault();
                    svgCanvas.setPointerCapture(e.pointerId);
                    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerId: e.pointerId });

                    if (activePointers.size === 2) {
                        interactionState = 'pinching';
                        const pointers = Array.from(activePointers.values());
                        lastPinchDist = getDistance(pointers[0], pointers[1]);
                        lastMidPoint = getMidPoint(pointers[0], pointers[1]);
                    } else if (activePointers.size === 1) {
                        interactionState = 'panning';
                        panStartPoint = { x: e.clientX, y: e.clientY };
                        svgCanvas.style.cursor = 'grabbing';
                    }
                    return;
                }

                // Track active image type when tracing image is clicked
                if (referenceImage && referenceImage.parentNode) {
                    activeImageType = 'tracingImage';
                    updatePinButtonState();
                }

                const isPencilLikeTool = (currentTool === 'pencil' || currentTool === 'pencil-2' || currentTool === 'mask-brush');
                const toolStickyActive = (isPencilLikeTool && stickyPencilActive && currentTool !== 'mask-brush');

                if (currentTool === 'magic-wand' && activePointers.size === 0) {
                    const rect = getCachedBoundingRect(svgCanvas);
                    const screenX = Math.floor(e.clientX - rect.left);
                    const screenY = Math.floor(e.clientY - rect.top);

                    if (multiWandMode) {
                        // In multi-wand mode, start long press detection
                        startMultiWandLongPress(e);
                        // Also perform wand selection immediately for continuous selection
                        runMagicWand(screenX, screenY);
                    } else {
                        runMagicWand(screenX, screenY);
                    }
                    return;
                }

                if (currentTool === 'magic-wand-2' && activePointers.size === 0) {
                    const rect = getCachedBoundingRect(svgCanvas);
                    const screenX = Math.floor(e.clientX - rect.left);
                    const screenY = Math.floor(e.clientY - rect.top);

                    if (multiWandMode) {
                        // In multi-wand mode, start long press detection
                        startMultiWandLongPress(e);
                        // Also perform wand selection immediately for continuous selection
                        runMagicWandOutline(screenX, screenY);
                    } else {
                        runMagicWandOutline(screenX, screenY);
                    }
                    return;
                }

                if (currentTool === 'paint-bucket' && activePointers.size === 0) {
                    const rect = getCachedBoundingRect(svgCanvas);
                    const screenX = Math.floor(e.clientX - rect.left);
                    const screenY = Math.floor(e.clientY - rect.top);
                    runPaintBucket(screenX, screenY);
                    return;
                }

                if (toolStickyActive && currentTool !== 'color-picker') {
                    e.preventDefault();
                    if (isStickyDrawing) {
                        isStickyDrawing = false;
                        if (isPencilLikeTool) endDrawing();
                        interactionState = 'idle';
                    } else {
                        isStickyDrawing = true;
                        if (isPencilLikeTool) startDrawing(e);
                        if (isPencilLikeTool) interactionState = 'drawing';
                    }
                    if (isStickyDrawing) {
                        svgCanvas.setPointerCapture(e.pointerId);
                        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerId: e.pointerId });
                    } else {
                        svgCanvas.releasePointerCapture(e.pointerId);
                        activePointers.delete(e.pointerId);
                    }
                    return;
                }

                clearTimeout(longPressTimer);
                isLongPress = false;

                longPressTimer = setTimeout(async () => {
                    if (activePointers.size === 1 && interactionState === 'idle' && tempColorImageHref) {
                        isLongPress = true;
                        try {
                            await activateColorPicker();
                            interactionState = 'picking';
                            panStartPoint = { x: e.clientX, y: e.clientY };
                        } catch (err) {
                            console.error("Color picker activation failed:", err);
                            isLongPress = false;
                        }
                    }
                }, longPressDuration);

                if (e.button === 2) {
                    e.preventDefault();
                }

                if (e.button !== 0 && activePointers.size === 0) return;
                e.preventDefault();
                svgCanvas.setPointerCapture(e.pointerId);
                activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerId: e.pointerId });

                if (activePointers.size === 2) {
                    interactionState = 'pinching';
                    const pointers = Array.from(activePointers.values());
                    lastPinchDist = getDistance(pointers[0], pointers[1]);
                    lastMidPoint = getMidPoint(pointers[0], pointers[1]);
                }
                else if (activePointers.size === 1) {
                    if (currentTool === 'pan' || e.button === 1) {
                        interactionState = 'panning';
                        panStartPoint = { x: e.clientX, y: e.clientY };
                        svgCanvas.style.cursor = 'grabbing';
                    } else if (isPencilLikeTool) {
                        interactionState = 'drawing';
                        startDrawing(e);
                    } else if (currentTool === 'eraser') {
                        interactionState = 'erasing';
                        handleEraserMove(e);
                    } else if (currentTool === 'color-picker') {
                        interactionState = 'picking';
                        panStartPoint = { x: e.clientX, y: e.clientY };
                    }
                }
            }
            function onPointerMove(e) {
                if (isEditingColorRef) {
                    if (!activePointers.has(e.pointerId)) return;
                    e.preventDefault();
                    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerId: e.pointerId });

                    if (interactionState === 'panning') {
                        panColorRef(e);
                    } else if (interactionState === 'pinching') {
                        pinchZoomColorRef();
                    }
                    return;
                }

                const isPencilLikeTool = (currentTool === 'pencil' || currentTool === 'pencil-2' || currentTool === 'mask-brush');
                const toolStickyActive = (isPencilLikeTool && stickyPencilActive && currentTool !== 'mask-brush');

                if (toolStickyActive && isStickyDrawing) {
                    if (isPencilLikeTool) draw(e);
                    return;
                }

                if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                if (!activePointers.has(e.pointerId)) return;
                e.preventDefault();
                activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerId: e.pointerId });

                switch (interactionState) {
                    case 'drawing': draw(e); break;
                    case 'panning':
                        if (!lockImageCheckbox.checked) pan(e);
                        break;
                    case 'pinching':
                        if (!lockImageCheckbox.checked) pinchZoom();
                        break;
                    case 'picking':
                        if (panStartPoint && Math.hypot(e.clientX - panStartPoint.x, e.clientY - panStartPoint.y) > 5) {
                            interactionState = 'panning';
                            svgCanvas.style.cursor = 'grab';
                            panColorRef(e);
                        }
                        break;
                    case 'erasing': handleEraserMove(e); break;
                }
            }
            function onPointerUp(e) {
                // Handle multi-wand long press end
                if (multiWandMode) {
                    endMultiWandLongPress(e);
                }

                if (isEditingColorRef) {
                    e.preventDefault();
                    svgCanvas.releasePointerCapture(e.pointerId);
                    activePointers.delete(e.pointerId);

                    if (interactionState === 'pinching') {
                        lastPinchDist = null;
                        lastMidPoint = null;
                    }
                    if (activePointers.size < 1) {
                        interactionState = 'idle';
                        panStartPoint = null;
                        updateCanvasCursor();
                    }
                    return;
                }

                const isPencilLikeTool = (currentTool === 'pencil' || currentTool === 'pencil-2' || currentTool === 'mask-brush');
                const toolStickyActive = (isPencilLikeTool && stickyPencilActive && currentTool !== 'mask-brush');

                if (toolStickyActive && isStickyDrawing) {
                    e.preventDefault();
                    svgCanvas.releasePointerCapture(e.pointerId);
                    activePointers.delete(e.pointerId);
                    return;
                }

                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isLongPress) {
                    e.preventDefault();
                    isLongPress = false;
                    if (interactionState === 'picking') {
                        pickColorAtPoint(getSVGPoint(e));
                    }
                }

                e.preventDefault();
                svgCanvas.releasePointerCapture(e.pointerId);

                if (interactionState === 'picking' && !isLongPress) {
                    pickColorAtPoint(getSVGPoint(e));
                }
                if (interactionState === 'drawing') endDrawing();
                if (interactionState === 'erasing' && e.pointerType === 'touch') { addHistoryState('drawing'); }

                activePointers.delete(e.pointerId);

                if (activePointers.size < 1) {
                    if (interactionState !== 'panning' || currentTool !== 'color-picker') {
                        updateCanvasCursor();
                    }
                    interactionState = 'idle';
                    panStartPoint = null;
                }
            }

            function onWheel(e) {
                if (isEditingColorRef) {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                    zoomColorRef(zoomFactor, getSVGPoint(e));
                    return;
                }

                if (lockImageCheckbox.checked || e.ctrlKey) return;
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                zoom(zoomFactor, getSVGPoint(e));
            }

            // --- INTERACTION HANDLERS ---
            function startDrawing(e) {
                if (selectionMask) {
                    // NEW: Allow Pencil 2 with Wand 2 to start outside selection (for smooth clipping)
                    const isWand2 = outlineSelectionMask && currentTool === 'pencil-2';
                    if (!isWand2 && !isPointInSelection(e) && currentTool !== 'mask-brush') {
                        currentPath = null;
                        points = [];
                        return;
                    }
                }

                // NEW: Mask Brush Logic
                if (currentTool === 'mask-brush') {
                    const pt = getSVGPoint(e);
                    points = [pt];
                    const pathAttrs = {
                        'stroke': 'blue', // User requested blue
                        'fill': 'none',
                        'stroke-width': maskBrushSize,
                        'stroke-linecap': 'round',
                        'stroke-linejoin': 'round',
                        // Higher visibility stroke opacity
                        'stroke-opacity': '0.8',
                        'style': 'pointer-events: none;'
                    };
                    currentPath = createSvgElement('path', pathAttrs);
                    maskOverlayLayer.appendChild(currentPath);
                    return;
                }

                const pt = getSVGPoint(e);
                points = [pt];

                // REF MODE: Pick color from reference image on first touch/click
                let strokeColor = currentColor;
                // Disabled automatic color picking in Ref Mode to ensure pencil color stays same as wand picked or manually picked
                /*
                if (refModeEnabled && currentTool === 'pencil' && tempColorImageHref) {
                    const pickedColor = pickColorFromRefMode(pt);
                    if (pickedColor) {
                        // Pick color on first touch - this becomes the initial color for this drawing
                        strokeColor = pickedColor;
                        refModeCurrentColor = pickedColor;
                        refModeInitialColor = pickedColor; // Store initial color for this path
                        selectColor(pickedColor); // Update UI color picker
                        colorUsageMap.set(pickedColor, (colorUsageMap.get(pickedColor) || 0) + 1);
                    } else {
                        // If we can't pick a color but have a ref mode color, use it
                        if (refModeCurrentColor) {
                            strokeColor = refModeCurrentColor;
                            refModeInitialColor = refModeCurrentColor;
                        }
                    }
                } else {
                    // Not in ref mode - clear initial color
                    refModeInitialColor = null;
                }
                */
                refModeInitialColor = null;

                // NEW: Add Opacity and Blur
                const isPencilLikeTool = (currentTool === 'pencil' || currentTool === 'pencil-2');
                const isWetPaintActive = wetPaintEnabled && isPencilLikeTool;
                const isWaterMixActive = waterMixEnabled && isPencilLikeTool;
                const isGlossyActive = glossyEffectEnabled && isPencilLikeTool;
                const isGlitterActive = glitterEffectEnabled && isPencilLikeTool;

                // Pencil 2 now uses the regular stroke width (no auto-detection)
                const strokeWidth = currentStrokeWidth;
                const pathAttrs = {
                    'stroke': strokeColor,
                    'fill': 'none',
                    'stroke-width': strokeWidth,
                    'stroke-linecap': 'round',
                    'stroke-linejoin': 'round',
                    'style': '',
                    'stroke-opacity': zeroOpacityStrokesEnabled ? 0 : currentStrokeOpacity // NEW: Apply zero opacity if toggle is on
                    // Note: pathLength is NOT set during drawing to prevent lag
                    // It will be set in endDrawing() after the path is finalized
                };

                const baseStyleParts = ['pointer-events: none;'];
                let effectFilterId = null;
                if (isWetPaintActive) {
                    effectFilterId = ensureWetPaintStrokeFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else if (isWaterMixActive) {
                    effectFilterId = ensureWaterMixFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else if (isGlossyActive) {
                    effectFilterId = ensureGlossyEffectFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else if (isGlitterActive) {
                    effectFilterId = ensureGlitterEffectFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else {
                    if (currentStrokeBlur > 0) { // NEW
                        pathAttrs['filter'] = `url(#blur-${currentStrokeBlur})`;
                    }
                }
                pathAttrs['style'] = baseStyleParts.join(' ');

                // NEW: Apply clipPath to individual path if selection is active
                if (selectionMask && currentSelectionClipPathId) {
                    pathAttrs['clip-path'] = `url(#${currentSelectionClipPathId})`;
                    // Store the selection ID so we can check if paths belong to same selection when merging
                    pathAttrs['data-selection-id'] = currentSelectionClipPathId;

                    // NEW: Store component ID to prevent merging across different closed shapes
                    const componentId = getComponentIdForSvgPoint(pt.x, pt.y);
                    if (componentId !== null) {
                        pathAttrs['data-component-id'] = componentId.toString();
                    }
                }

                // CHECK FOR TEMP STROKE TOGGLE
                if (isPencilLikeTool) {
                    const tempStrokeToggleBtn = document.getElementById('temp-stroke-toggle');
                    if (tempStrokeToggleBtn && tempStrokeToggleBtn.checked) {
                        pathAttrs['data-temp-stroke'] = 'true';
                    }
                }

                currentPath = createSvgElement('path', pathAttrs);

                // Save original opacity if zero opacity is enabled
                if (zeroOpacityStrokesEnabled) {
                    currentPath.setAttribute('data-original-opacity', currentStrokeOpacity.toString());
                }

                if (isWetPaintActive) {
                    currentPath.setAttribute('data-wet-paint-stroke', 'true');
                    if (effectFilterId) {
                        currentPath.setAttribute('data-wet-paint-filter', effectFilterId);
                    }
                } else if (isGlossyActive) {
                    currentPath.setAttribute('data-glossy-stroke', 'true');
                    if (effectFilterId) {
                        currentPath.setAttribute('data-glossy-filter', effectFilterId);
                    }
                } else if (isGlitterActive) {
                    currentPath.setAttribute('data-glitter-stroke', 'true');
                    if (effectFilterId) {
                        currentPath.setAttribute('data-glitter-filter', effectFilterId);
                    }
                } else if (isWaterMixActive) {
                    currentPath.setAttribute('data-water-mix-stroke', 'true');
                    if (effectFilterId) {
                        currentPath.setAttribute('data-water-mix-filter', effectFilterId);
                    }
                }

                const parentLayer = maskedStrokesLayer || drawingLayer;
                parentLayer.appendChild(currentPath);
            }

            function isPointInSelection(e) {
                if (!selectionMask || !selectionViewBox || !selectionMaskWidth || !selectionMaskHeight) {
                    return true;
                }

                const svgPoint = getSVGPoint(e);
                const relX = (svgPoint.x - selectionViewBox.x) / selectionViewBox.w;
                const relY = (svgPoint.y - selectionViewBox.y) / selectionViewBox.h;

                if (relX < 0 || relX > 1 || relY < 0 || relY > 1) {
                    return false;
                }

                const maskX = Math.floor(relX * selectionMaskWidth);
                const maskY = Math.floor(relY * selectionMaskHeight);

                if (maskX < 0 || maskX >= selectionMaskWidth || maskY < 0 || maskY >= selectionMaskHeight) {
                    return false;
                }

                if (!cachedShrunkMask) {
                    cachedShrunkMask = shrinkSelectionMask(selectionMask, selectionMaskWidth, selectionMaskHeight, selectionShrinkAmount);
                }

                const idx = maskY * selectionMaskWidth + maskX;
                return cachedShrunkMask[idx] === 1;
            }
            // Throttled path update for smooth rendering
            let pathUpdateRafId = null;
            let pendingPathUpdate = false;
            let lastPathUpdateTime = 0;
            const PATH_UPDATE_THROTTLE_MS = 16; // Throttle to ~60fps

            function updatePathAttribute() {
                if (!currentPath || points.length === 0) {
                    pendingPathUpdate = false;
                    return;
                }

                // Use cached path generation if available
                const pathCacheKey = `${points.length}_${points[0].x}_${points[0].y}_${points[points.length - 1].x}_${points[points.length - 1].y}`;
                let pathData;

                if (CACHE.pathSimplified[pathCacheKey]) {
                    pathData = generateLinearPath(CACHE.pathSimplified[pathCacheKey]);
                } else {
                    pathData = generateLinearPath(points);
                }

                currentPath.setAttribute('d', pathData);
                pendingPathUpdate = false;
                lastPathUpdateTime = Date.now();
            }

            function draw(e) {
                const isMasked = !!selectionMask;
                const isPencilLikeTool = (currentTool === 'pencil' || currentTool === 'pencil-2');

                if (isMasked && isPencilLikeTool) {
                    // NEW: For Wand 2 (outline selection), allow stroke to extend outside selection
                    // This ensures the full stroke is captured for smoothing, then clipped visually by SVG clipPath
                    const isWand2 = outlineSelectionMask && currentTool === 'pencil-2';

                    if (!isWand2) {
                        if (!isPointInSelection(e)) {
                            return;
                        } else if (!currentPath) {
                            startDrawing(e);
                            if (!currentPath) return;
                        }
                    } else {
                        // For Wand 2, we still need to ensure drawing is started if we are inside/near
                        if (!currentPath) {
                            // Try to start drawing. startDrawing has its own check, but we might want to relax it there too?
                            // For now, rely on startDrawing's check (must start inside).
                            startDrawing(e);
                            if (!currentPath) return;
                        }
                    }
                }
                // NEW: Mask Brush Logic
                if (currentTool === 'mask-brush') {
                    if (!currentPath) return;
                    const pt = getSVGPoint(e);
                    points.push(pt);

                    // Throttle path updates
                    if (!pendingPathUpdate) {
                        pendingPathUpdate = true;
                        if (pathUpdateRafId) cancelAnimationFrame(pathUpdateRafId);
                        pathUpdateRafId = requestAnimationFrame(() => {
                            updatePathAttribute();
                        });
                    }
                    return;
                }

                if (!currentPath) return;

                let pt = getSVGPoint(e);
                const rawPt = { x: pt.x, y: pt.y };

                // NEW: Snap to Outline Logic
                if (currentTool === 'pencil-2' && snapToOutlineEnabled && outlineSelectionMask && selectionViewBox) {
                    const snapped = snapPointToOutline(pt, outlineSelectionMask, selectionMaskWidth, selectionMaskHeight, snapStrength);
                    if (snapped) {
                        // Smart Snapping: Center stroke if it's thin relative to the outline
                        const maskX = Math.floor((snapped.x - selectionViewBox.x) * (selectionMaskWidth / selectionViewBox.w));
                        const maskY = Math.floor((snapped.y - selectionViewBox.y) * (selectionMaskHeight / selectionViewBox.h));

                        const thickness = estimateOutlineThickness(outlineSelectionMask, selectionMaskWidth, selectionMaskHeight, maskX, maskY);

                        let targetPt = snapped;

                        if (thickness > 0) {
                            const scaleX = selectionViewBox.w / selectionMaskWidth;
                            const scaleY = selectionViewBox.h / selectionMaskHeight;
                            const thicknessViewBox = thickness * ((scaleX + scaleY) * 0.5);

                            if (currentPath && !currentPath.hasAttribute('data-wand2-autofit-done')) {
                                if (currentStrokeWidth >= thicknessViewBox) {
                                    const fittedWidth = thicknessViewBox;
                                    currentStrokeWidth = fittedWidth;
                                    currentPath.setAttribute('stroke-width', fittedWidth);
                                    if (strokeWidthSlider) strokeWidthSlider.value = fittedWidth.toString();
                                    if (strokeWidthValue) strokeWidthValue.textContent = `${Math.round(fittedWidth)}px`;
                                    currentPath.setAttribute('data-wand2-autofit-done', '1');
                                }
                            }

                            const center = getOutlineCenter(outlineSelectionMask, antsCanvas.width, antsCanvas.height, maskX, maskY);
                            const centerPt = {
                                x: selectionViewBox.x + (center.x + 0.5) * (selectionViewBox.w / antsCanvas.width),
                                y: selectionViewBox.y + (center.y + 0.5) * (selectionViewBox.h / antsCanvas.height)
                            };

                            // Consider stroke "touching both sides" if width is close to outline thickness
                            const isTouchingBothSides = currentStrokeWidth >= thicknessViewBox * 0.9;

                            if (isTouchingBothSides) {
                                // Rail mode: force stroke to the exact center of the Wand 2 outline
                                targetPt = centerPt;
                                pt = targetPt;
                            } else {
                                // For thinner strokes, still center when they fit inside the outline
                                if (currentStrokeWidth <= thicknessViewBox) {
                                    targetPt = centerPt;
                                }

                                const normalizedStrength = Math.max(0, Math.min(1, snapStrength / 10));
                                const blend = normalizedStrength * normalizedStrength;

                                pt = {
                                    x: rawPt.x + (targetPt.x - rawPt.x) * blend,
                                    y: rawPt.y + (targetPt.y - rawPt.y) * blend
                                };
                            }
                        } else {
                            const normalizedStrength = Math.max(0, Math.min(1, snapStrength / 10));
                            const blend = normalizedStrength * normalizedStrength;

                            pt = {
                                x: rawPt.x + (targetPt.x - rawPt.x) * blend,
                                y: rawPt.y + (targetPt.y - rawPt.y) * blend
                            };
                        }
                    }
                }

                // REF MODE: Stop drawing if pencil moves to a significantly different color
                if (refModeEnabled && isPencilLikeTool && tempColorImageHref && refModeInitialColor) {
                    const pickedColor = pickColorFromRefMode(pt);
                    if (pickedColor) {
                        // Check if the color is significantly different from the initial color
                        if (!isColorSimilar(pickedColor, refModeInitialColor)) {
                            // Different color detected - stop drawing (don't add this point)
                            return;
                        }
                    } else {
                        // Can't pick color (outside image bounds) - stop drawing
                        return;
                    }
                }

                // Limit points array size to prevent memory issues
                if (points.length >= SmartMemory.maxPointsPerPath) {
                    // Keep first and last point, and sample middle points
                    const sampledPoints = [points[0]];
                    const sampleStep = Math.floor(points.length / (SmartMemory.maxPointsPerPath - 2));
                    for (let i = sampleStep; i < points.length - 1; i += sampleStep) {
                        sampledPoints.push(points[i]);
                    }
                    sampledPoints.push(points[points.length - 1]);
                    points = sampledPoints;
                }

                points.push(pt);

                // Throttle path updates using requestAnimationFrame for smooth rendering
                // Add additional throttling for heavy loads
                if (!pendingPathUpdate) {
                    pendingPathUpdate = true;
                    if (pathUpdateRafId) {
                        cancelAnimationFrame(pathUpdateRafId);
                    }
                    pathUpdateRafId = requestAnimationFrame(() => {
                        updatePathAttribute();
                        // Periodic memory check during drawing
                        if (points.length % 100 === 0) {
                            SmartMemory.checkMemory();
                        }
                    });
                }
            }

            function distanceBetweenPoints(a, b) {
                const dx = a.x - b.x;
                const dy = a.y - b.y;
                return Math.hypot(dx, dy);
            }

            function replaceMoveWithLine(d) {
                return d ? d.replace(/^M\s*/i, 'L ') : d;
            }

            function tryMergeWithNearbyPath(newPath, startPoint, endPoint) {
                if (!newPath || !drawingLayer) return false;
                const stroke = newPath.getAttribute('stroke') || '';
                const strokeWidth = newPath.getAttribute('stroke-width') || '';
                const strokeOpacity = newPath.getAttribute('stroke-opacity') || '';
                const filterAttr = newPath.getAttribute('filter') || '';
                const wetFilter = newPath.getAttribute('data-wet-paint-filter') || '';
                const isWetPaint = newPath.hasAttribute('data-wet-paint-stroke') || wetFilter !== '';

                // Get the selection ID for the new path - only merge paths from the same selection
                const newPathSelectionId = newPath.getAttribute('data-selection-id') || null;

                // NEW: For wet paint, only allow merging if they share a selection ID
                // This creates unified wet paint within selected areas
                if (isWetPaint && !newPathSelectionId) {
                    return false; // No selection = don't merge wet paint
                }

                // For wet paint within a selection, use a more generous threshold for better merging
                // For regular strokes, use standard threshold
                const baseThreshold = Math.max(5, (parseFloat(strokeWidth) || 0) * 2.5);
                // NEW: Wet paint in same selection gets 3x larger merge threshold for fluid blending
                const threshold = (isWetPaint && newPathSelectionId) ? baseThreshold * 3 : baseThreshold;

                const candidates = Array.from(drawingLayer.querySelectorAll('path')).filter(p => {
                    if (p === newPath) return false;
                    if (p.hasAttribute('data-temp-stroke')) return false;
                    // IMPORTANT: Only merge paths that belong to the same wand selection (or both have no selection)
                    const pSelectionId = p.getAttribute('data-selection-id') || null;
                    if (newPathSelectionId !== pSelectionId) return false; // Different selections - don't merge

                    // NEW: Check component ID - only merge strokes in the same closed shape
                    const newPathComponentId = newPath.getAttribute('data-component-id') || null;
                    const pComponentId = p.getAttribute('data-component-id') || null;
                    if (newPathSelectionId && (newPathComponentId !== pComponentId)) {
                        return false; // Different closed shapes within same selection - don't merge
                    }

                    // NEW: For Wand selections with outlineSelectionMask, prevent color bleeding between closed shapes
                    // Only allow merging if stroke colors match AND they're the same fill action within the selection
                    if (newPathSelectionId && outlineSelectionMask) {
                        const pStroke = p.getAttribute('stroke') || '';
                        if (pStroke !== stroke) return false; // Prevent cross-color merging in selections
                    }

                    // For wet paint, also check if any point along the path is close
                    if (isWetPaint) {
                        const pIsWetPaint = p.hasAttribute('data-wet-paint-stroke') || (p.getAttribute('data-wet-paint-filter') || '') !== '';
                        return (p.getAttribute('stroke') === stroke) && pIsWetPaint;
                    } else {
                        return (p.getAttribute('stroke') === stroke) &&
                            (p.getAttribute('stroke-width') === strokeWidth) &&
                            (p.getAttribute('stroke-opacity') === strokeOpacity) &&
                            ((p.getAttribute('filter') || '') === filterAttr) &&
                            ((p.getAttribute('data-wet-paint-filter') || '') === wetFilter);
                    }
                });

                let best = null;
                let bestMode = null; // 'append' or 'prepend'
                let bestDist = Infinity;

                for (const p of candidates) {
                    try {
                        const total = p.getTotalLength();
                        const candStart = p.getPointAtLength(0);
                        const candEnd = p.getPointAtLength(total);

                        // Check endpoint distances
                        const d1 = distanceBetweenPoints(startPoint, candEnd); // append to candidate
                        const d2 = distanceBetweenPoints(endPoint, candStart); // prepend to candidate

                        // For wet paint, also check if any point along the path is close
                        if (isWetPaint && total > 0) {
                            // Sample points along candidate path to find closest approach
                            const sampleCount = Math.min(10, Math.floor(total / 10));
                            for (let i = 0; i <= sampleCount; i++) {
                                const sampleLen = (total / sampleCount) * i;
                                const samplePoint = p.getPointAtLength(sampleLen);
                                const distToStart = distanceBetweenPoints(startPoint, samplePoint);
                                const distToEnd = distanceBetweenPoints(endPoint, samplePoint);
                                if (distToStart < bestDist && distToStart <= threshold) {
                                    best = p;
                                    bestMode = 'append';
                                    bestDist = distToStart;
                                }
                                if (distToEnd < bestDist && distToEnd <= threshold) {
                                    best = p;
                                    bestMode = 'prepend';
                                    bestDist = distToEnd;
                                }
                            }
                        }

                        // Standard endpoint checking
                        if (d1 < bestDist && d1 <= threshold) { best = p; bestMode = 'append'; bestDist = d1; }
                        if (d2 < bestDist && d2 <= threshold) { best = p; bestMode = 'prepend'; bestDist = d2; }
                    } catch (err) { }
                }

                if (!best || !bestMode) return false;

                const newD = newPath.getAttribute('d') || '';
                const bestD = best.getAttribute('d') || '';

                // NEW: Check collinearity for smooth merging
                let isCollinear = false;
                if (bestMode === 'append') {
                    // Check if best.end -> new.start -> new.next point are collinear
                    try {
                        const bestLen = best.getTotalLength();
                        const newLen = newPath.getTotalLength();
                        const bestEnd = best.getPointAtLength(bestLen);
                        const newStart = newPath.getPointAtLength(0);
                        const newNext = newLen > 0 ? newPath.getPointAtLength(Math.min(5, newLen)) : null;
                        if (newNext) {
                            isCollinear = checkIfCollinear(bestEnd, newStart, newNext, 1.5);
                        }
                    } catch (e) { }
                } else if (bestMode === 'prepend') {
                    // Check if new.end -> best.start -> best.next point are collinear
                    try {
                        const newLen = newPath.getTotalLength();
                        const bestLen = best.getTotalLength();
                        const newEnd = newLen > 0 ? newPath.getPointAtLength(newLen) : null;
                        const bestStart = best.getPointAtLength(0);
                        const bestNext = bestLen > 5 ? best.getPointAtLength(5) : null;
                        if (newEnd && bestNext) {
                            isCollinear = checkIfCollinear(newEnd, bestStart, bestNext, 1.5);
                        }
                    } catch (e) { }
                }

                if (bestMode === 'append') {
                    // Candidate end -> new start
                    const connectedNew = replaceMoveWithLine(newD);
                    if (isCollinear) {
                        // Direct merge: just append without extra line segment
                        best.setAttribute('d', `${bestD} ${connectedNew}`);
                    } else {
                        best.setAttribute('d', `${bestD} ${connectedNew}`);
                    }
                } else {
                    // New end -> candidate start
                    const connectedBest = replaceMoveWithLine(bestD);
                    if (isCollinear) {
                        // Direct merge: just append without extra line segment
                        best.setAttribute('d', `${newD} ${connectedBest}`);
                    } else {
                        best.setAttribute('d', `${newD} ${connectedBest}`);
                    }
                }

                // Update metadata on merged path
                try {
                    const len = best.getTotalLength().toFixed(2);
                    best.setAttribute('pathLength', len);
                    best.setAttribute('data-length', len);
                } catch (e) { }

                newPath.remove();
                return true;
            }
            function endDrawing() {
                // Cancel any pending path update animation frame
                if (pathUpdateRafId) {
                    cancelAnimationFrame(pathUpdateRafId);
                    pathUpdateRafId = null;
                }
                pendingPathUpdate = false;

                // Clear ref mode initial color when ending drawing
                if (refModeEnabled) {
                    refModeInitialColor = null;
                }

                // Clear cached shrunk mask when finishing drawing
                cachedShrunkMask = null;

                // NEW: Mask Brush Logic
                if (currentTool === 'mask-brush') {
                    if (points.length > 1 && currentPath) {
                        // Ensure the path data is fully updated and smoothed before storing
                        let pathData;
                        if (pencilModeSelect.value === 'smoothness') {
                            const scale = Math.sqrt(viewBox.w / canvasContainer.clientWidth);
                            const tolerance = pathTolerance * scale;
                            const simplifiedPoints = simplifyPath(points, tolerance);
                            pathData = generateSmoothPath(simplifiedPoints);
                        } else {
                            pathData = generateLinearPath(points);
                        }

                        currentPath.setAttribute('d', pathData);

                        // Store the path for masking
                        tempMaskPaths.push(currentPath.cloneNode(true));
                    } else if (currentPath) {
                        currentPath.remove();
                    }
                    currentPath = null;
                    points = [];
                    return;
                }

                if (points.length > 1 && currentPath) {
                    let pathData;
                    let simplifiedPoints;

                    if (pencilModeSelect.value === 'smoothness') {
                        const scale = Math.sqrt(viewBox.w / canvasContainer.clientWidth);
                        const tolerance = pathTolerance * scale;
                        simplifiedPoints = simplifyPath(points, tolerance);
                    } else {
                        simplifiedPoints = simplifyToFixedNodes(points, fixedNodeCount);
                    }

                    // NEW: Apply Mask Brush if exists
                    if (tempMaskPaths.length > 0) {
                        const maskId = `temp-mask-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
                        const maskEl = createSvgElement('mask', {
                            id: maskId,
                            maskUnits: 'userSpaceOnUse',
                            maskContentUnits: 'userSpaceOnUse'
                        });

                        // White background (reveal all) - Use huge rect to ensure coverage
                        const bg = createSvgElement('rect', {
                            x: -100000, y: -100000,
                            width: 200000, height: 200000,
                            fill: 'white'
                        });
                        maskEl.appendChild(bg);

                        // Black strokes (hide masked areas)
                        tempMaskPaths.forEach(p => {
                            const clone = p.cloneNode(true);
                            clone.setAttribute('stroke', 'black');
                            clone.setAttribute('stroke-opacity', '1');
                            clone.setAttribute('opacity', '1');
                            clone.setAttribute('fill', 'none');
                            maskEl.appendChild(clone);
                        });

                        defs.appendChild(maskEl);
                        currentPath.setAttribute('mask', `url(#${maskId})`);

                        // Clear mask brush strokes
                        tempMaskPaths = [];
                        maskOverlayLayer.innerHTML = '';
                    }

                    // NOTE: Removed trimming of points for "pencil-2" (wand 2 outline).
                    // Keeping the full simplifiedPoints allows the path data to be created
                    // exactly like the normal pencil tool while visual clipping is still
                    // handled by the SVG `clip-path`. This ensures animations or external
                    // mappings use the full stroke path rather than a truncated subset.

                    if (simplifiedPoints.length < 2) {
                        if (currentPath) currentPath.remove();
                        currentPath = null;
                        points = [];
                        return;
                    }
                    pathData = generateSmoothPath(simplifiedPoints);

                    currentPath.setAttribute('d', pathData);
                    currentPath.style.removeProperty('pointer-events');
                    // Normalize path length for external animation mapping and store actual length
                    try {
                        const len = currentPath.getTotalLength().toFixed(2);
                        currentPath.setAttribute('pathLength', len);
                        currentPath.setAttribute('data-length', len);
                    } catch (e) { }


                    // NEW: Optimization - Update filter with correct size class based on bounds
                    // This prevents lag on long paths by using tighter filter regions
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    for (const p of simplifiedPoints) {
                        if (p.x < minX) minX = p.x;
                        if (p.x > maxX) maxX = p.x;
                        if (p.y < minY) minY = p.y;
                        if (p.y > maxY) maxY = p.y;
                    }
                    const width = maxX - minX;
                    const height = maxY - minY;
                    const maxDim = Math.max(width, height);

                    let sizeClass = 'm';
                    if (maxDim < 150) sizeClass = 's';
                    else if (maxDim > 600) sizeClass = 'l';

                    // Extra optimization for huge paths
                    if (maxDim > 1200) sizeClass = 'xl';

                    // Re-apply filter with correct size class
                    if (wetPaintEnabled && (currentTool === 'pencil' || currentTool === 'pencil-2')) {
                        const filterId = ensureWetPaintStrokeFilter(currentStrokeBlur, sizeClass);
                        if (filterId) {
                            // Keep existing transforms/styles, just update filter
                            // We need to preserve other style properties if they exist
                            const existingStyle = currentPath.getAttribute('style') || '';
                            // Remove existing filter from style
                            const styleWithoutFilter = existingStyle.replace(/filter:\s*url\([^)]+\);?/, '').trim();
                            currentPath.setAttribute('style', `${styleWithoutFilter} filter: url(#${filterId});`);
                            currentPath.setAttribute('data-wet-paint-filter', filterId);
                        }
                    } else if (glossyEffectEnabled && (currentTool === 'pencil' || currentTool === 'pencil-2')) {
                        const filterId = ensureGlossyEffectFilter(currentStrokeBlur, sizeClass);
                        if (filterId) {
                            const existingStyle = currentPath.getAttribute('style') || '';
                            const styleWithoutFilter = existingStyle.replace(/filter:\s*url\([^)]+\);?/, '').trim();
                            currentPath.setAttribute('style', `${styleWithoutFilter} filter: url(#${filterId});`);
                            currentPath.setAttribute('data-glossy-filter', filterId);
                        }
                    } else if (glitterEffectEnabled && (currentTool === 'pencil' || currentTool === 'pencil-2')) {
                        const filterId = ensureGlitterEffectFilter(currentStrokeBlur, sizeClass);
                        if (filterId) {
                            const existingStyle = currentPath.getAttribute('style') || '';
                            const styleWithoutFilter = existingStyle.replace(/filter:\s*url\([^)]+\);?/, '').trim();
                            currentPath.setAttribute('style', `${styleWithoutFilter} filter: url(#${filterId});`);
                            currentPath.setAttribute('data-glitter-filter', filterId);
                        }
                    } else if (waterMixEnabled && (currentTool === 'pencil' || currentTool === 'pencil-2')) {
                        const filterId = ensureWaterMixFilter(currentStrokeBlur, sizeClass);
                        if (filterId) {
                            const existingStyle = currentPath.getAttribute('style') || '';
                            const styleWithoutFilter = existingStyle.replace(/filter:\s*url\([^)]+\);?/, '').trim();
                            currentPath.setAttribute('style', `${styleWithoutFilter} filter: url(#${filterId});`);
                            currentPath.setAttribute('data-water-mix-filter', filterId);
                        }
                    }

                    // --- FILTER PERFORMANCE OPTIMIZATION ---
                    // Hide heavy filters on canvas after drawing ends to prevent lag.
                    // They will be restored during export.
                    const style = currentPath.getAttribute('style') || '';
                    const filterMatch = style.match(/filter:\s*url\(#([^)]+)\)/);
                    if (filterMatch) {
                        const filterId = filterMatch[1];
                        if (filterId.includes('wet-paint') ||
                            filterId.includes('glitter') ||
                            filterId.includes('glossy') ||
                            filterId.includes('water-mix')) {

                            currentPath.setAttribute('data-cached-filter', `url(#${filterId})`);
                            const newStyle = style.replace(/filter:\s*url\(#[^)]+\);?/, '').trim();
                            currentPath.setAttribute('style', newStyle);
                        }
                    } else if (currentPath.hasAttribute('filter')) {
                        const filterAttr = currentPath.getAttribute('filter');
                        const filterAttrMatch = filterAttr.match(/url\(#([^)]+)\)/);
                        if (filterAttrMatch) {
                            const filterId = filterAttrMatch[1];
                            if (filterId.includes('wet-paint') ||
                                filterId.includes('glitter') ||
                                filterId.includes('glossy') ||
                                filterId.includes('water-mix')) {

                                currentPath.setAttribute('data-cached-filter', filterAttr);
                                currentPath.removeAttribute('filter');
                            }
                        }
                    }

                    // Save stroke to cache
                    saveStrokeToCache(currentPath, simplifiedPoints, pathData);

                    // NEW: Track color usage
                    const color = currentPath.getAttribute('stroke');
                    if (color) {
                        colorUsageMap.set(color, (colorUsageMap.get(color) || 0) + 1);
                    }

                    // CHECK FOR TEMP STROKE
                    if (currentPath.hasAttribute('data-temp-stroke')) {
                        // Temp strokes persist until deleted manually
                        // Do not add to history
                    } else {
                        addHistoryState('drawing');
                    }

                    // Periodic memory check after adding history
                    SmartMemory.checkMemory();
                } else if (currentPath) { currentPath.remove(); }
                currentPath = null;
                points = []; // Clear points array to free memory
            }

            function pan(e) {
                if (!panStartPoint || activePointers.size > 1) return;
                const currentPoint = { x: e.clientX, y: e.clientY };
                const dx = currentPoint.x - panStartPoint.x, dy = currentPoint.y - panStartPoint.y;
                const scale = viewBox.w / canvasContainer.clientWidth;
                viewBox.x -= dx * scale;
                viewBox.y -= dy * scale;
                panStartPoint = currentPoint;
                setViewBox();

                // NEW: Throttle cache invalidation to improve performance during pan
                const now = Date.now();
                if (now - lastCacheInvalidationTime > CACHE_INVALIDATION_THROTTLE_MS) {
                    CACHE.imageDataCache = {};
                    lastCacheInvalidationTime = now;
                }
                if (selectionPath) startMarchingAnts();
            }

            function pinchZoom() {
                if (activePointers.size !== 2 || !lastPinchDist || !lastMidPoint) return;

                const pointers = Array.from(activePointers.values());
                const newPinchDist = getDistance(pointers[0], pointers[1]);
                const newMidPoint = getMidPoint(pointers[0], pointers[1]);

                const zoomFactor = lastPinchDist / newPinchDist;
                const svgMidPoint = getSVGPoint(lastMidPoint);

                const dx = newMidPoint.x - lastMidPoint.x;
                const dy = newMidPoint.y - lastMidPoint.y;
                const scale = viewBox.w / canvasContainer.clientWidth;
                viewBox.x -= dx * scale;
                viewBox.y -= dy * scale;
                invalidateViewBoxCache(); // Invalidate cached viewBox calculations

                zoom(zoomFactor, svgMidPoint);

                lastPinchDist = newPinchDist;
                lastMidPoint = newMidPoint;
            }

            function zoom(zoomFactor, center) {
                viewBox.x = center.x - (center.x - viewBox.x) * zoomFactor;
                viewBox.y = center.y - (center.y - viewBox.y) * zoomFactor;
                viewBox.w *= zoomFactor;
                viewBox.h *= zoomFactor;
                setViewBox();

                // NEW: Throttle cache invalidation to improve performance during zoom
                const now = Date.now();
                if (now - lastCacheInvalidationTime > CACHE_INVALIDATION_THROTTLE_MS) {
                    CACHE.imageDataCache = {};
                    lastCacheInvalidationTime = now;
                }
                if (selectionPath) startMarchingAnts();
            }

            function panColorRef(e) {
                if (!panStartPoint || activePointers.size > 1 || !colorPickerImage) return;
                const currentPoint = { x: e.clientX, y: e.clientY };
                const dx = currentPoint.x - panStartPoint.x;
                const dy = currentPoint.y - panStartPoint.y;
                const scale = viewBox.w / canvasContainer.clientWidth;

                const currentX = parseFloat(colorPickerImage.getAttribute('x'));
                const currentY = parseFloat(colorPickerImage.getAttribute('y'));

                colorPickerImage.setAttribute('x', currentX + dx * scale);
                colorPickerImage.setAttribute('y', currentY + dy * scale);

                panStartPoint = currentPoint;
            }
            function pinchZoomColorRef() {
                if (activePointers.size !== 2 || !lastPinchDist || !lastMidPoint || !colorPickerImage) return;

                const pointers = Array.from(activePointers.values());
                const newPinchDist = getDistance(pointers[0], pointers[1]);
                const newMidPoint = getMidPoint(pointers[0], pointers[1]);

                const zoomFactor = lastPinchDist / newPinchDist;
                const svgMidPoint = getSVGPoint(lastMidPoint);

                const dx = newMidPoint.x - lastMidPoint.x;
                const dy = newMidPoint.y - lastMidPoint.y;
                const scale = viewBox.w / canvasContainer.clientWidth;

                let currentX = parseFloat(colorPickerImage.getAttribute('x'));
                let currentY = parseFloat(colorPickerImage.getAttribute('y'));
                let currentWidth = parseFloat(colorPickerImage.getAttribute('width'));
                let currentHeight = parseFloat(colorPickerImage.getAttribute('height'));

                currentX += dx * scale;
                currentY += dy * scale;

                const newWidth = currentWidth * zoomFactor;
                const newHeight = currentHeight * zoomFactor;
                const newX = svgMidPoint.x - (svgMidPoint.x - currentX) * zoomFactor;
                const newY = svgMidPoint.y - (svgMidPoint.y - currentY) * zoomFactor;

                colorPickerImage.setAttribute('x', newX);
                colorPickerImage.setAttribute('y', newY);
                colorPickerImage.setAttribute('width', newWidth);
                colorPickerImage.setAttribute('height', newHeight);

                lastPinchDist = newPinchDist;
                lastMidPoint = newMidPoint;
            }

            function zoomColorRef(zoomFactor, center) {
                if (!colorPickerImage) return;

                const currentX = parseFloat(colorPickerImage.getAttribute('x'));
                const currentY = parseFloat(colorPickerImage.getAttribute('y'));
                const currentWidth = parseFloat(colorPickerImage.getAttribute('width'));
                const currentHeight = parseFloat(colorPickerImage.getAttribute('height'));

                const newWidth = currentWidth * zoomFactor;
                const newHeight = currentHeight * zoomFactor;
                const newX = center.x - (center.x - currentX) * zoomFactor;
                const newY = center.y - (center.y - currentY) * zoomFactor;

                colorPickerImage.setAttribute('x', newX);
                colorPickerImage.setAttribute('y', newY);
                colorPickerImage.setAttribute('width', newWidth);
                colorPickerImage.setAttribute('height', newHeight);
            }

            function handleSliderZoom(e) {
                if (lockImageCheckbox.checked) {
                    const zoomPercent = 100000 / viewBox.w;
                    e.target.value = zoomPercent;
                    showToast("Pan/Zoom is locked.");
                    return;
                }
                const newWidth = 100000 / parseFloat(e.target.value);
                const newHeight = newWidth * (canvasContainer.clientHeight / canvasContainer.clientWidth);

                const centerX = viewBox.x + viewBox.w / 2;
                const centerY = viewBox.y + viewBox.h / 2;

                viewBox.w = newWidth;
                viewBox.h = newHeight;
                viewBox.x = centerX - newWidth / 2;
                viewBox.y = centerY - newHeight / 2;
                invalidateViewBoxCache(); // Invalidate cached viewBox calculations
                setViewBox();
                if (selectionPath) startMarchingAnts();
            }


            function handleEraserMove(e) {
                const pathToRemove = document.elementsFromPoint(e.clientX, e.clientY).find(el =>
                    el.tagName === 'path' &&
                    (el.parentElement.id === 'drawing-layer') &&
                    !el.hasAttribute('data-temp-stroke')
                );
                if (pathToRemove) {
                    pathToRemove.remove();
                    if (e.pointerType !== 'touch') addHistoryState('drawing');
                }
            }

            // --- UI & STATE ---
            function updateCanvasOverlays() {
                const isSidebarHidden = !sidebar.classList.contains('open');

                updateWandButtonPosition();

                // Always show controls on mobile/tablet, or when sidebar is hidden on desktop
                const isMobileOrTablet = window.matchMedia('(hover: none) and (pointer: coarse)').matches ||
                    window.matchMedia('(max-width: 768px)').matches;
                canvasUndoRedoContainer.classList.toggle('visible', isSidebarHidden || isMobileOrTablet);

                // Always ensure tool shortcuts and palette toggle are visible and functional on mobile/tablet
                if (isMobileOrTablet) {
                    // Force visibility of tool shortcuts
                    toolShortcutsContainer.style.opacity = '0.9';
                    toolShortcutsContainer.style.display = 'flex';
                    toolShortcutsContainer.style.visibility = 'visible';
                    toolShortcutsContainer.style.pointerEvents = 'all';

                    // Force visibility of color palette toggle
                    floatingColorPaletteToggle.style.opacity = '1';
                    floatingColorPaletteToggle.style.display = 'flex';
                    floatingColorPaletteToggle.style.visibility = 'visible';
                    floatingColorPaletteToggle.style.pointerEvents = 'all';

                    // Ensure shortcut buttons are clickable
                    if (shortcutWandBtn) {
                        shortcutWandBtn.style.pointerEvents = 'all';
                        shortcutWandBtn.style.touchAction = 'manipulation';
                    }
                    if (shortcutPencilBtn) {
                        shortcutPencilBtn.style.pointerEvents = 'all';
                        shortcutPencilBtn.style.touchAction = 'manipulation';
                    }
                    if (shortcutPanBtn) {
                        shortcutPanBtn.style.pointerEvents = 'all';
                        shortcutPanBtn.style.touchAction = 'manipulation';
                    }
                }
            }
            var autoRefOpacityEnabled = false;
            function switchTool(tool) {
                // Turn off multi-wand mode when switching away from wand tools
                if (multiWandMode && tool !== 'magic-wand' && tool !== 'magic-wand-2') {
                    multiWandMode = false;
                    multiWandToggleBtn.classList.remove('active');
                    // Clear any ongoing long press timer
                    if (multiWandLongPressTimer) {
                        clearTimeout(multiWandLongPressTimer);
                        multiWandLongPressTimer = null;
                    }
                    multiWandIsLongPressing = false;
                    multiWandSavedTool = null;
                }

                // NEW: Auto Ref Opacity Logic
                if (autoRefOpacityEnabled) {
                    if (tool === 'magic-wand') {
                        // Wand Selection -> 100% Opacity
                        colorRefImageState.opacity = 1.0;
                        colorRefOpacitySlider.value = '1.0';
                        if (colorPickerImage) colorPickerImage.setAttribute('opacity', '1.0');
                        if (refModeImage) refModeImage.setAttribute('opacity', '1.0');
                    } else if (tool === 'pencil' || tool === 'pencil-2') {
                        // Pencil Drawing -> 0% Opacity
                        colorRefImageState.opacity = 0.0;
                        colorRefOpacitySlider.value = '0.0';
                        if (colorPickerImage) colorPickerImage.setAttribute('opacity', '0.0');
                        if (refModeImage) refModeImage.setAttribute('opacity', '0.0');
                    }
                }

                if (currentTool === 'color-picker') {
                    deactivateColorPicker();
                }

                if (isEditingColorRef && tool !== 'pan') {
                    deactivateColorPicker();
                }

                // NEW: When switching to wand, save current opacity and set to 1.0
                if (tool === 'magic-wand' && referenceImage) {
                    savedTraceOpacity = parseFloat(opacitySlider.value) || 1.0;
                    opacitySlider.value = '1.0';
                    referenceImage.setAttribute('opacity', '1.0');
                }
                // NEW: When switching away from wand, restore saved opacity
                else if (currentTool === 'magic-wand' && tool !== 'magic-wand' && referenceImage) {
                    opacitySlider.value = savedTraceOpacity.toString();
                    referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                }

                const toolsThatRetainSelection = ['pencil', 'pencil-2', 'color-picker', 'magic-wand', 'magic-wand-2', 'paint-bucket', 'pan', 'mask-brush'];
                if (!toolsThatRetainSelection.includes(tool) && selectionMask) {
                    if (tool === 'eraser') {
                        deselect();
                    } else if (tool === 'magic-wand' || tool === 'magic-wand-2') {
                        // Don't deselect when switching to magic wand tools - allow reselection
                        // The deselection will happen when making a new selection
                        // Turn off filter when switching to magic-wand tools
                        toggleColorFilter(false);
                    }
                } else if (toolsThatRetainSelection.includes(tool) && selectionMask) {
                    startMarchingAnts();

                    // Manual Visibility Control: Only hide if the toggle is off
                    if (isSelectionVisible) {
                        antsCanvas.style.opacity = '1';
                        if (wandToggleBtn) wandToggleBtn.style.display = '';
                    } else {
                        antsCanvas.style.opacity = '0';
                        if (wandToggleBtn) wandToggleBtn.style.display = 'none';
                    }

                    // Ensure selection clip path is set up for drawing (Pencil & Pencil 2)
                    if ((tool === 'pencil' || tool === 'pencil-2') && selectionMask && selectionViewBox && antsCanvas) {
                        const width = antsCanvas.width;
                        const height = antsCanvas.height;
                        updateSelectionClipPath(selectionMask, width, height);
                    }
                }

                // Turn on filter when switching away from magic-wand tool if filter is selected and selection exists
                if (tool !== 'magic-wand' && tool !== 'magic-wand-2' && (currentTool === 'magic-wand' || currentTool === 'magic-wand-2') && selectionMask && currentColorFilter !== 'none') {
                    toggleColorFilter(true);
                }

                // Turn off filter when switching to magic-wand tool
                if ((tool === 'magic-wand' || tool === 'magic-wand-2') && currentTool !== 'magic-wand' && currentTool !== 'magic-wand-2') {
                    toggleColorFilter(false);
                }

                // Show/hide paint bucket shrink slider
                if (paintBucketShrinkContainer) {
                    paintBucketShrinkContainer.classList.toggle('hidden', tool !== 'paint-bucket');
                }
                updateEffectSettingsVisibility();

                if (tool === 'pan') {
                    zoomSliderContainer.classList.remove('hidden');
                    zoomSliderContainer.classList.add('flex');
                } else {
                    zoomSliderContainer.classList.add('hidden');
                    zoomSliderContainer.classList.remove('flex');
                }

                isStickyDrawing = false;

                currentTool = tool;
                toolButtons.forEach(btn => {
                    const isPrimaryTool = btn.id === `${tool}-tool`;
                    const isWetPaintToggle = btn.id === 'wet-paint-tool';
                    const isWaterMixToggle = btn.id === 'water-mix-tool';
                    const isGlossyToggle = btn.id === 'glossy-effect-tool';
                    const isGlitterToggle = btn.id === 'glitter-effect-tool';
                    if (isWetPaintToggle) {
                        btn.classList.toggle('active', wetPaintEnabled);
                    } else if (isWaterMixToggle) {
                        btn.classList.toggle('active', waterMixEnabled);
                    } else if (isGlossyToggle) {
                        btn.classList.toggle('active', glossyEffectEnabled);
                    } else if (isGlitterToggle) {
                        btn.classList.toggle('active', glitterEffectEnabled);
                    } else {
                        btn.classList.toggle('active', isPrimaryTool);
                    }
                });

                // NEW: Update shortcut buttons
                shortcutWandBtn.classList.toggle('active', tool === 'magic-wand' || tool === 'magic-wand-2');
                shortcutFillBtn.classList.toggle('active', tool === 'paint-bucket');
                shortcutPencilBtn.classList.toggle('active', tool === 'pencil' || tool === 'pencil-2');
                shortcutPanBtn.classList.toggle('active', tool === 'pan');
                if (document.getElementById('shortcut-mask-brush-btn')) {
                    document.getElementById('shortcut-mask-brush-btn').classList.toggle('active', tool === 'mask-brush');
                }
                if (shortcutShadeBtn) {
                    shortcutShadeBtn.classList.toggle('active', isShadeMode);
                }
                if (shortcutWetPaintBtn) {
                    shortcutWetPaintBtn.classList.toggle('active', tool === 'wet-paint');
                }
                if (shortcutWaterMixBtn) {
                    shortcutWaterMixBtn.classList.toggle('active', tool === 'water-mix');
                }
                if (shortcutGlitterBtn) {
                    shortcutGlitterBtn.classList.toggle('active', tool === 'glitter-effect');
                }

                editColorRefBtn.classList.toggle('active', isEditingColorRef);

                const pointerEventsTools = ['eraser', 'color-picker', 'magic-wand'];
                drawingLayer.querySelectorAll('path, [id^="baked-layer-"] path').forEach(p => {
                    const isTemp = p.hasAttribute('data-temp-stroke');
                    if (tool === 'eraser' && isTemp) {
                        p.style.pointerEvents = 'none';
                    } else {
                        p.style.pointerEvents = (pointerEventsTools.includes(tool)) ? 'all' : 'none';
                    }
                });

                // NEW: Show/hide unpick button
                unpickColorBtn.classList.toggle('hidden', tool !== 'color-picker');

                // NEW: Show/hide selection visibility shortcut
                if (shortcutSelectionVisibilityBtn) {
                    shortcutSelectionVisibilityBtn.classList.toggle('hidden', !selectionMask);
                }

                // NEW: Show/hide color palette
                if (tool === 'color-picker') {
                    updateColorPalette();
                } else {
                    const frequentColors = colorPaletteContainer.querySelector('.frequent-colors');
                    if (frequentColors) {
                        frequentColors.style.display = 'none';
                    }
                }

                updateCanvasCursor();
                saveUiSettings();
                updateCanvasOverlays();
            }
            function toggleWetPaint(forceState = null) {
                const nextState = (forceState !== null) ? !!forceState : !wetPaintEnabled;
                if (nextState === wetPaintEnabled) {
                    return;
                }
                // Disable other effects when enabling this one
                if (nextState) {
                    waterMixEnabled = false;
                    glossyEffectEnabled = false;
                    glitterEffectEnabled = false;
                    waterMixToolBtn.classList.remove('active');
                    glossyEffectToolBtn.classList.remove('active');
                    glitterEffectToolBtn.classList.remove('active');
                }
                wetPaintEnabled = nextState;
                wetPaintToolBtn.classList.toggle('active', wetPaintEnabled);
                if (wetPaintEnabled && currentTool !== 'pencil' && currentTool !== 'pencil-2') {
                    switchTool('pencil');
                } else {
                    updateCanvasCursor();
                }
                showToast(wetPaintEnabled ? "Wet Paint enabled." : "Wet Paint disabled.");
                updateEffectSettingsVisibility();
                saveUiSettings();
            }

            function updateEffectSettingsVisibility() {
                const isPencilLike = (currentTool === 'pencil' || currentTool === 'pencil-2');
                const wpSettings = document.getElementById('wet-paint-shadow-settings');
                const wmSettings = document.getElementById('water-mix-settings');
                const glSettings = document.getElementById('glitter-settings');

                if (wpSettings) wpSettings.classList.toggle('hidden', !wetPaintEnabled || !isPencilLike);
                if (wmSettings) wmSettings.classList.toggle('hidden', !waterMixEnabled || !isPencilLike);
                if (glSettings) glSettings.classList.toggle('hidden', !glitterEffectEnabled || !isPencilLike);
            }

            function toggleWaterMix(forceState = null) {
                const nextState = (forceState !== null) ? !!forceState : !waterMixEnabled;
                if (nextState === waterMixEnabled) return;

                // Disable other effects when enabling this one
                if (nextState) {
                    wetPaintEnabled = false;
                    glossyEffectEnabled = false;
                    glitterEffectEnabled = false;
                    wetPaintToolBtn.classList.remove('active');
                    glossyEffectToolBtn.classList.remove('active');
                    glitterEffectToolBtn.classList.remove('active');
                }

                waterMixEnabled = nextState;
                waterMixToolBtn.classList.toggle('active', waterMixEnabled);
                if (waterMixEnabled && currentTool !== 'pencil' && currentTool !== 'pencil-2') {
                    switchTool('pencil');
                } else {
                    updateCanvasCursor();
                }
                showToast(waterMixEnabled ? "Water Mix enabled." : "Water Mix disabled.");
                updateEffectSettingsVisibility();
                saveUiSettings();
            }
            function toggleGlossyEffect(forceState = null) {
                const nextState = (forceState !== null) ? !!forceState : !glossyEffectEnabled;
                if (nextState === glossyEffectEnabled) {
                    return;
                }
                // Disable other effects when enabling this one
                if (nextState) {
                    wetPaintEnabled = false;
                    waterMixEnabled = false;
                    glitterEffectEnabled = false;
                    wetPaintToolBtn.classList.remove('active');
                    waterMixToolBtn.classList.remove('active');
                    glitterEffectToolBtn.classList.remove('active');
                }
                glossyEffectEnabled = nextState;
                glossyEffectToolBtn.classList.toggle('active', glossyEffectEnabled);
                if (glossyEffectEnabled && currentTool !== 'pencil' && currentTool !== 'pencil-2') {
                    switchTool('pencil');
                } else {
                    updateCanvasCursor();
                }
                showToast(glossyEffectEnabled ? "Glossy effect enabled." : "Glossy effect disabled.");
                updateEffectSettingsVisibility();
                saveUiSettings();
            }

            function toggleGlitterEffect(forceState = null) {
                const nextState = (forceState !== null) ? !!forceState : !glitterEffectEnabled;
                if (nextState === glitterEffectEnabled) {
                    return;
                }
                // Disable other effects when enabling this one
                if (nextState) {
                    wetPaintEnabled = false;
                    waterMixEnabled = false;
                    glossyEffectEnabled = false;
                    wetPaintToolBtn.classList.remove('active');
                    waterMixToolBtn.classList.remove('active');
                    glossyEffectToolBtn.classList.remove('active');
                }
                glitterEffectEnabled = nextState;
                glitterEffectToolBtn.classList.toggle('active', glitterEffectEnabled);
                if (glitterEffectEnabled && currentTool !== 'pencil') {
                    switchTool('pencil');
                } else {
                    updateCanvasCursor();
                }
                showToast(glitterEffectEnabled ? "Glitter effect enabled." : "Glitter effect disabled.");
                updateEffectSettingsVisibility();
                saveUiSettings();
            }

            function updateCanvasCursor() {
                if (isEditingColorRef) {
                    svgCanvas.style.cursor = (interactionState === 'panning') ? 'grabbing' : 'grab';
                    return;
                }

                if (interactionState === 'panning' && (currentTool === 'pan' || currentTool === 'color-picker')) {
                    svgCanvas.style.cursor = 'grabbing';
                    return;
                }

                const cursors = {
                    pencil: 'crosshair',
                    pan: 'grab',
                    eraser: `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" fill="white"></rect></svg>') 12 12, auto`,
                    'color-picker': `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2"><path d="m16 13 5.223 3.482a.5.5 0 0 1 0 .869L16 20.833V13Z"/><path d="m4 13-1.106-.737a.5.5 0 0 0-.894.44V18.5c0 .276.224.5.5.5h13a.5.5 0 0 0 .5-.5v-4.833c0 .204-.124-.385-.31-.462L16 13H4Z"/><path d="m12 12 4-4"/></svg>') 4 18, auto`,
                    'magic-wand': `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2"><path d="M15 4V2"/><path d="M15 8V6"/><path d="M15 12V10"/><path d="M15 16V14"/><path d="M15 20V18"/><path d="M3 10l-1.65-1.65a.5.5 0 0 1 0-.7L3 6"/><path d="M21 10l1.65-1.65a.5.5 0 0 0 0-.7L21 6"/><path d="M12 2v6"/><path d="M6 6l-1.65-1.65a.5.5 0 0 1 0-.7L6 2"/><path d="M18 6l1.65-1.65a.5.5 0 0 0 0-.7L18 2"/><path d="M11.64 16.36a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28L4.05 7.71a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4L11.64 16.36z"/><path d="M18.83 14.17a1 1 0 0 1-1.28 1.28l-2.09-2.09a1 1 0 0 1-1.28-1.28l-2.94-6.56a1 1 0 0 1 1.28-1.28l6.56 2.94a1 1 0 0 1 .53 1.4l.22.53z"/></svg>') 4 4, auto`,
                    'paint-bucket': `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2"><path d="M19 11H5M19 11a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2M19 11V9a2 2 0 0 0-2-2M5 11V9a2 2 0 0 1 2-2m0 0V5a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2M7 7h10"/><path d="M12 2v2m0 4v2m0 4v2m0 4v2" stroke-width="1.5"/></svg>') 12 12, auto`,
                };

                if (currentTool === 'color-picker' && interactionState === 'idle') {
                    svgCanvas.style.cursor = cursors['color-picker'];
                } else {
                    svgCanvas.style.cursor = cursors[currentTool] || 'default';
                }
            }
            function setViewBox() {
                invalidateViewBoxCache(); // Invalidate cached viewBox calculations 
                svgCanvas.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);

                // IMPORTANT: Sync mask overlay SVG viewBox to match main canvas for coordinate synchronization
                const maskOverlaySvg = document.getElementById('mask-overlay-svg');
                if (maskOverlaySvg) {
                    maskOverlaySvg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
                }

                if (zoomSlider) {
                    const zoomPercent = (1000 / viewBox.w) * 100;
                    zoomSlider.value = Math.max(10, Math.min(1000, zoomPercent));
                }
            }
            function handleResize() {
                cachedRect = null; // Invalidate cached rect
                const { clientWidth, clientHeight } = canvasContainer;
                if (!clientWidth || !clientHeight) return;
                if (clientWidth === 0) return;

                // NEW: Check if size actually changed to prevent unnecessary selection clearing
                if (antsCanvas.width === clientWidth && antsCanvas.height === clientHeight) {
                    return;
                }

                // NEW: Clear selection if canvas is resized, as the pixel mask would become invalid
                if (selectionMask) {
                    cachedShrunkMask = null;
                }

                antsCanvas.width = clientWidth;
                antsCanvas.height = clientHeight;

                viewBox.h = viewBox.w * (clientHeight / clientWidth);
                setViewBox();

                if (selectionMask && selectionPath && selectionMaskWidth && selectionMaskHeight) {
                    selectionViewBox = { ...viewBox };
                    updateSelectionClipPath(selectionMask, selectionMaskWidth, selectionMaskHeight);
                    saveMarchingAntsPath(selectionPath, selectionViewBox);
                }

                if (selectionPath) {
                    startMarchingAnts();
                }

                // Update canvas overlays on resize to ensure shortcuts are visible on mobile
                updateCanvasOverlays();
            }
            // --- HISTORY (UNDO/REDO) ---
            function addHistoryState(actionType = 'drawing') {
                drawingLayerVersion++; // Increment version on state change
                isDirty = true;
                saveProjectBtn.disabled = false;
                const imageState = referenceImage ? { href: referenceImage.getAttribute('href'), width: referenceImage.getAttribute('width'), height: referenceImage.getAttribute('height'), x: referenceImage.getAttribute('x'), y: referenceImage.getAttribute('y'), opacity: referenceImage.getAttribute('opacity') } : null;

                const defsContent = defs.innerHTML;

                // MODIFICATION: Add color ref state to history
                const currentState = {
                    drawing: drawingLayer.innerHTML,
                    defs: defsContent,
                    image: imageState,
                    tempColorImageHref: tempColorImageHref,
                    colorRefImageState: { ...colorRefImageState }, // Store a copy
                    bgImageHref: bgImageHref, // NEW: Save background image href
                    bgImageState: { ...bgImageState }, // NEW: Save background image state
                    selectionMask: selectionMask ? new Uint8Array(selectionMask) : null,
                    selectionMaskWidth,
                    selectionMaskHeight,
                    selectionViewBox: selectionViewBox ? { ...selectionViewBox } : null,
                    selectionBounds: selectionBounds ? { ...selectionBounds } : null
                };

                // NEW: Add timestamp to state
                currentState.timestamp = Date.now();

                // NEW: Separate histories based on action type
                if (actionType === 'drawing') {
                    if (drawingHistoryIndex < drawingHistory.length - 1) {
                        drawingHistory = drawingHistory.slice(0, drawingHistoryIndex + 1);
                    }
                    // Strictly enforce history limit before adding
                    if (drawingHistory.length >= SmartMemory.maxHistoryStates) {
                        drawingHistory = drawingHistory.slice(1);
                        drawingHistoryIndex = Math.max(0, drawingHistoryIndex - 1);
                    }
                    drawingHistory.push(currentState);
                    drawingHistoryIndex++;
                } else if (actionType === 'selection') {
                    if (selectionHistoryIndex < selectionHistory.length - 1) {
                        selectionHistory = selectionHistory.slice(0, selectionHistoryIndex + 1);
                    }
                    // Strictly enforce history limit before adding
                    if (selectionHistory.length >= SmartMemory.maxHistoryStates) {
                        selectionHistory = selectionHistory.slice(1);
                        selectionHistoryIndex = Math.max(0, selectionHistoryIndex - 1);
                    }
                    selectionHistory.push(currentState);
                    selectionHistoryIndex++;
                }

                // Keep main history for full project state
                if (historyIndex < history.length - 1) { history = history.slice(0, historyIndex + 1); }

                // Strictly enforce history limit before adding
                if (history.length >= SmartMemory.maxHistoryStates) {
                    history = history.slice(1);
                    historyIndex = Math.max(0, historyIndex - 1);
                }

                history.push(currentState);
                historyIndex++;

                // SMART MEMORY: Optimize history and cache
                SmartMemory.checkMemory();

                updateUndoRedoButtons();
            }
            function applyHistoryState(state, preserveSelection = false) {
                interactionState = 'idle';
                if (!preserveSelection) {
                    deselect();
                }

                if (currentPath) currentPath.remove();
                currentPath = null;
                points = [];

                isStickyDrawing = false;
                isEditingColorRef = false;

                drawingLayer.innerHTML = state.drawing;

                // Re-link maskedStrokesLayer after innerHTML change
                maskedStrokesLayer = drawingLayer.querySelector('#masked-strokes-layer');
                if (!maskedStrokesLayer) {
                    // Fallback for older project versions or if layer was missing
                    maskedStrokesLayer = createSvgElement('g', { id: 'masked-strokes-layer' });
                    drawingLayer.appendChild(maskedStrokesLayer);
                }

                // Apply current Trace Lock state to the re-linked layer
                if (traceLockCheckbox.checked) {
                    maskedStrokesLayer.setAttribute('mask', 'url(#image-mask)');
                } else {
                    maskedStrokesLayer.removeAttribute('mask');
                }

                drawingLayerVersion++;
                defs.innerHTML = state.defs;

                imageMask = document.getElementById('image-mask');

                const currentImg = document.getElementById('reference-image');
                if (currentImg) currentImg.remove();

                if (state.image) {
                    referenceImage = createSvgElement('image', { ...state.image, id: 'reference-image' });
                    referenceImage.crossOrigin = "anonymous";
                    // Insert referenceImage before refModeImage (main image should be below ref overlay)
                    const insertBefore = refModeImage || drawingLayer;
                    svgCanvas.insertBefore(referenceImage, insertBefore);
                    const maskImage = createSvgElement('image', { ...state.image, filter: 'url(#trace-mask-filter)' });
                    maskImage.crossOrigin = "anonymous";
                    imageMask.appendChild(maskImage);
                    imageTools.classList.remove('hidden');
                    // Apply filter if enabled
                    if (filterEnabled && currentColorFilter !== 'none') {
                        applyColorFilter();
                    }
                } else {
                    referenceImage = null;
                    imageTools.classList.add('hidden');
                }

                // MODIFICATION: Restore color ref state
                tempColorImageHref = state.tempColorImageHref || null;
                colorRefImageState = state.colorRefImageState || { x: 0, y: 0, width: 1000, height: 1000, opacity: 1.0 };

                if (tempColorImageHref) {
                    deleteTempImageBtn.classList.remove('hidden');
                    colorRefControls.classList.remove('hidden');
                    colorRefOpacitySlider.value = colorRefImageState.opacity || 1.0;

                    // Actually load and display the color reference image
                    const img = new Image();
                    img.onload = () => {
                        try {
                            // Prepare the image for color picking by drawing it to canvas
                            referenceImageCtx.clearRect(0, 0, referenceImageCanvas.width, referenceImageCanvas.height);
                            referenceImageCanvas.width = img.width;
                            referenceImageCanvas.height = img.height;
                            referenceImageCtx.drawImage(img, 0, 0, img.width, img.height);

                            // Update color picker image if visible
                            if (colorPickerImage) {
                                colorPickerImage.setAttribute('href', tempColorImageHref);
                                colorPickerImage.setAttribute('width', colorRefImageState.width);
                                colorPickerImage.setAttribute('height', colorRefImageState.height);
                                colorPickerImage.setAttribute('x', colorRefImageState.x);
                                colorPickerImage.setAttribute('y', colorRefImageState.y);
                                colorPickerImage.setAttribute('opacity', colorRefImageState.opacity || 1.0);
                            }

                            // Update ref mode image if enabled
                            if (refModeEnabled && refModeImage) {
                                syncRefModeImage();
                            }

                            // Apply filter if enabled
                            if (filterEnabled && currentColorFilter !== 'none') {
                                applyColorFilter();
                            }
                        } catch (e) {
                            console.error("Error preparing color reference image:", e);
                        }
                    };
                    img.onerror = () => {
                        console.warn("Failed to load color reference image");
                    };
                    img.src = tempColorImageHref;
                } else {
                    deleteTempImageBtn.classList.add('hidden');
                    colorRefControls.classList.add('hidden');
                }

                // NEW: Restore background image state
                try {
                    bgImageHref = state.bgImageHref || null;
                    bgImageState = state.bgImageState || { opacity: 1.0, visible: true };
                    // Ensure opacity is a number to prevent crashes
                    if (typeof bgImageState.opacity !== 'number') bgImageState.opacity = 1.0;

                    if (bgImageHref) {
                        bgImageControls.classList.remove('hidden');
                        if (bgOpacitySlider) bgOpacitySlider.value = bgImageState.opacity;
                        if (bgOpacityValue) bgOpacityValue.textContent = bgImageState.opacity.toFixed(2);
                        updateBgImage();
                    } else {
                        bgImageControls.classList.add('hidden');
                        if (bgImageLayer) bgImageLayer.setAttribute('visibility', 'hidden');
                    }
                } catch (err) {
                    console.error("Error restoring background image state:", err);
                }
                // NEW: Restore selection if present and preserving
                if (preserveSelection && state.selectionMask) {
                    selectionMask = new Uint8Array(state.selectionMask);
                    selectionMaskWidth = state.selectionMaskWidth || selectionMaskWidth || antsCanvas.width;
                    selectionMaskHeight = state.selectionMaskHeight || selectionMaskHeight || antsCanvas.height;
                    selectionViewBox = state.selectionViewBox ? { ...state.selectionViewBox } : null;
                    selectionBounds = state.selectionBounds ? { ...state.selectionBounds } : null;
                    if (selectionMask && selectionViewBox && selectionMaskWidth && selectionMaskHeight) {
                        generateSelectionPath(selectionMask, selectionMaskWidth, selectionMaskHeight);
                        startMarchingAnts();
                        deselectBtn.classList.remove('hidden');
                        // CRITICAL: Regenerate clip path to prevent color bleeding
                        updateSelectionClipPath(selectionMask, selectionMaskWidth, selectionMaskHeight);
                    }
                } else if (!preserveSelection) {
                    // Clear selection if not preserving
                    selectionMask = null;
                    selectionMaskWidth = 0;
                    selectionMaskHeight = 0;
                    selectionViewBox = null;
                    selectionBounds = null;
                    cachedShrunkMask = null; // Clear cached shrunk mask
                    currentSelectionClipPathId = null;
                    if (antsAnimationId) {
                        cancelAnimationFrame(antsAnimationId);
                        antsAnimationId = null;
                    }
                    antsCtx.clearRect(0, 0, antsCanvas.width, antsCanvas.height);
                    deselectBtn.classList.add('hidden');
                    drawingLayer.removeAttribute('clip-path');
                }

                // Deactivate picker if it was active
                deactivateColorPicker();
                switchTool(currentTool); // Refresh tool state
            }


            // NEW: Smart undo/redo that respects separate histories
            function undo() {
                // If there's an active selection, only undo drawing actions
                if (selectionMask && drawingHistoryIndex > 0) {
                    drawingHistoryIndex--;
                    const state = drawingHistory[drawingHistoryIndex];
                    applyHistoryState(state, true);
                    return;
                }

                // Standard chronological undo using main history
                if (historyIndex > 0) {
                    historyIndex--;
                    const state = history[historyIndex];
                    applyHistoryState(state);

                    // Sync separate history indices
                    if (state.timestamp) {
                        while (drawingHistoryIndex >= 0 &&
                            drawingHistory[drawingHistoryIndex] &&
                            drawingHistory[drawingHistoryIndex].timestamp > state.timestamp) {
                            drawingHistoryIndex--;
                        }
                        while (selectionHistoryIndex >= 0 &&
                            selectionHistory[selectionHistoryIndex] &&
                            selectionHistory[selectionHistoryIndex].timestamp > state.timestamp) {
                            selectionHistoryIndex--;
                        }
                    }
                }
                updateUndoRedoButtons();
                isDirty = true;
                saveProjectBtn.disabled = false;
            }

            function redo() {
                // If there's an active selection, only redo drawing actions
                if (selectionMask && drawingHistoryIndex < drawingHistory.length - 1) {
                    drawingHistoryIndex++;
                    const state = drawingHistory[drawingHistoryIndex];
                    applyHistoryState(state, true);
                    return;
                }

                // Standard chronological redo
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    const state = history[historyIndex];
                    applyHistoryState(state);

                    // Sync separate history indices
                    if (state.timestamp) {
                        let dIndex = 0;
                        if (drawingHistoryIndex >= 0) dIndex = drawingHistoryIndex;
                        while (dIndex < drawingHistory.length && drawingHistory[dIndex].timestamp <= state.timestamp) {
                            dIndex++;
                        }
                        drawingHistoryIndex = dIndex - 1;

                        let sIndex = 0;
                        if (selectionHistoryIndex >= 0) sIndex = selectionHistoryIndex;
                        while (sIndex < selectionHistory.length && selectionHistory[sIndex].timestamp <= state.timestamp) {
                            sIndex++;
                        }
                        selectionHistoryIndex = sIndex - 1;
                    }
                }
                updateUndoRedoButtons();
                isDirty = true;
                saveProjectBtn.disabled = false;
            }

            function updateUndoRedoButtons() {
                let undoDisabled, redoDisabled;
                if (selectionMask) {
                    // If selection is active, check drawing history (Special Mode)
                    undoDisabled = drawingHistoryIndex <= 0;
                    redoDisabled = drawingHistoryIndex >= drawingHistory.length - 1;
                } else {
                    // Check main history (General Mode)
                    undoDisabled = historyIndex <= 0;
                    redoDisabled = historyIndex >= history.length - 1;
                }

                undoBtn.disabled = undoDisabled;
                redoBtn.disabled = redoDisabled;

                canvasUndoBtn.disabled = undoDisabled;
                canvasRedoBtn.disabled = redoDisabled;

                // NEW: Update floating history buttons
                wandUndoBtn.disabled = undoDisabled;
                wandRedoBtn.disabled = redoDisabled;

                // NEW: Update bottom left undo/redo buttons
                if (bottomLeftUndoBtn) bottomLeftUndoBtn.disabled = undoDisabled;
                if (bottomLeftRedoBtn) bottomLeftRedoBtn.disabled = redoDisabled;
            }
            function ensureWetPaintStrokeFilter(blurAmount, sizeClass = 'm') {
                const uniqueFilterId = `wet-paint-stroke-filter-${blurAmount}-${sizeClass}`;

                // Check if filter already exists in defs
                if (document.getElementById(uniqueFilterId)) {
                    return uniqueFilterId;
                }

                // Adaptive filter region based on size class
                // Optimized to minimize dirty rect size while preventing clipping
                let region = { x: '-15%', y: '-15%', width: '130%', height: '130%' }; // Default 'm'

                if (sizeClass === 's') {
                    // Small strokes need larger relative padding
                    region = { x: '-40%', y: '-40%', width: '180%', height: '180%' };
                } else if (sizeClass === 'l') {
                    // Large strokes need tight padding to reduce memory usage
                    region = { x: '-5%', y: '-5%', width: '110%', height: '110%' };
                } else if (sizeClass === 'xl') {
                    // Extra large strokes need very tight padding
                    region = { x: '-2%', y: '-2%', width: '104%', height: '104%' };
                }

                const filter = createSvgElement('filter', {
                    id: uniqueFilterId,
                    filterUnits: 'objectBoundingBox',
                    x: region.x, y: region.y, width: region.width, height: region.height,
                    'color-interpolation-filters': 'sRGB' // Force sRGB for faster processing (8-bit vs linear)
                });

                // Use the user-configurable shadow settings
                const outerShadowSize = typeof wetPaintOuterShadowSize !== 'undefined' ? wetPaintOuterShadowSize : 1.2;
                const outerShadowBlur = typeof wetPaintOuterShadowBlur !== 'undefined' ? wetPaintOuterShadowBlur : 0.35;
                const innerShadowSize = typeof wetPaintInnerShadowSize !== 'undefined' ? wetPaintInnerShadowSize : 0.5;
                const innerShadowBlur = typeof wetPaintInnerShadowBlur !== 'undefined' ? wetPaintInnerShadowBlur : 0.4;

                const baseBlur = blurAmount || 0;

                // Create the wet paint filter structure
                // Optimized for performance

                filter.innerHTML = `
                    <feGaussianBlur in="SourceAlpha" stdDeviation="${baseBlur + 0.1}" result="base_blur"/>
                    <feMorphology operator="dilate" radius="${outerShadowSize}" in="base_blur" result="thick"/>
                    <feGaussianBlur stdDeviation="${outerShadowBlur}" in="thick" result="blurred_thick"/>
                    <feFlood flood-color="black" flood-opacity="0.3" result="shadow_color"/>
                    <feComposite operator="in" in="shadow_color" in2="blurred_thick" result="outer_shadow"/>
                    
                    <feMorphology operator="erode" radius="${innerShadowSize}" in="SourceAlpha" result="thin"/>
                    <feGaussianBlur stdDeviation="${innerShadowBlur}" in="thin" result="blurred_thin"/>
                    <feCommon operator="xor" in="SourceAlpha" in2="blurred_thin" result="inner_edge"/>
                    <feFlood flood-color="white" flood-opacity="0.2" result="highlight_color"/>
                    <feComposite operator="in" in="highlight_color" in2="inner_edge" result="highlight"/>

                    <feMerge>
                        <feMergeNode in="outer_shadow"/>
                        <feMergeNode in="SourceGraphic"/>
                        <feMergeNode in="highlight"/>
                    </feMerge>
                `;

                defs.appendChild(filter);
                return uniqueFilterId;
            }

            function ensureWaterMixFilter(blurAmount) {
                const numericBlur = Number.isFinite(blurAmount) ? blurAmount : parseFloat(blurAmount) || 0;
                const clamped = Math.max(0, Math.min(5, Math.round(numericBlur)));
                const filterId = `water-mix-filter-${clamped}`;
                if (document.getElementById(filterId)) return filterId;

                const filter = createSvgElement('filter', {
                    id: filterId,
                    x: '-25%',
                    y: '-25%',
                    width: '150%',
                    height: '150%',
                    'color-interpolation-filters': 'sRGB'
                });

                // --- SUBTLE DIRECTIONAL SHADOW ---
                const shadowBlur = createSvgElement('feGaussianBlur', {
                    in: 'SourceAlpha',
                    stdDeviation: waterMixShadowBlur.toFixed(2),
                    result: 'shadowBlur'
                });

                const shadowOffset = createSvgElement('feOffset', {
                    in: 'shadowBlur',
                    dx: waterMixShadowSize.toFixed(2),
                    dy: (waterMixShadowSize * 1.2).toFixed(2),
                    result: 'offsetBlur'
                });

                const shadowColor = createSvgElement('feFlood', {
                    'flood-color': '#000000',
                    'flood-opacity': waterMixShadowOpacity.toFixed(2),
                    result: 'shadowColor'
                });

                const shadowComposite = createSvgElement('feComposite', {
                    in: 'shadowColor',
                    in2: 'offsetBlur',
                    operator: 'in',
                    result: 'shadow'
                });

                // --- WATER MIX BLENDING ---
                const softwareBlur = createSvgElement('feGaussianBlur', {
                    in: 'SourceGraphic',
                    stdDeviation: (waterMixStrength + clamped * 0.1).toFixed(2),
                    result: 'soften'
                });

                const finalMerge = createSvgElement('feMerge');
                finalMerge.appendChild(createSvgElement('feMergeNode', { in: 'shadow' }));
                finalMerge.appendChild(createSvgElement('feMergeNode', { in: 'soften' }));
                finalMerge.appendChild(createSvgElement('feMergeNode', { in: 'SourceGraphic' }));

                // --- OPTIONAL INNER HIGHLIGHT (Added last to be on top) ---
                if (waterMixHighlightEnabled) {
                    const highlightShift = createSvgElement('feOffset', {
                        in: 'SourceAlpha',
                        dx: waterMixHighlightSize.toFixed(2),
                        dy: (waterMixHighlightSize * 1.2).toFixed(2),
                        result: 'highlightOffset'
                    });

                    const highlightMask = createSvgElement('feComposite', {
                        in: 'SourceAlpha',
                        in2: 'highlightOffset',
                        operator: 'out',
                        result: 'highlightRim'
                    });

                    const highlightFlood = createSvgElement('feFlood', {
                        'flood-color': '#ffffff',
                        'flood-opacity': waterMixHighlightOpacity.toFixed(2),
                        result: 'highlightColor'
                    });

                    const highlightFinal = createSvgElement('feComposite', {
                        in: 'highlightColor',
                        in2: 'highlightRim',
                        operator: 'in',
                        result: 'highlight'
                    });

                    const highlightBlur = createSvgElement('feGaussianBlur', {
                        in: 'highlight',
                        stdDeviation: waterMixHighlightBlur.toFixed(2),
                        result: 'highlightSoft'
                    });

                    filter.append(highlightShift, highlightMask, highlightFlood, highlightFinal, highlightBlur);
                    finalMerge.appendChild(createSvgElement('feMergeNode', { in: 'highlightSoft' }));
                }

                filter.append(shadowBlur, shadowOffset, shadowColor, shadowComposite, softwareBlur, finalMerge);
                defs.appendChild(filter);
                return filterId;
            }

            function ensureGlossyEffectFilter(blurAmount, sizeClass = 'm') {
                const uniqueFilterId = `glossy-effect-filter-${blurAmount}-${sizeClass}`;
                if (document.getElementById(uniqueFilterId)) return uniqueFilterId;

                // Adaptive region - Tighter bounds for better performance
                let region = { x: '-15%', y: '-15%', width: '130%', height: '130%' }; // m
                if (sizeClass === 's') region = { x: '-40%', y: '-40%', width: '180%', height: '180%' };
                else if (sizeClass === 'l') region = { x: '-5%', y: '-5%', width: '110%', height: '110%' };
                else if (sizeClass === 'xl') region = { x: '-2%', y: '-2%', width: '104%', height: '104%' };

                const filter = createSvgElement('filter', {
                    id: uniqueFilterId,
                    filterUnits: 'objectBoundingBox',
                    x: region.x, y: region.y, width: region.width, height: region.height,
                    'color-interpolation-filters': 'sRGB'
                });

                filter.innerHTML = `
                    <feGaussianBlur in="SourceAlpha" stdDeviation="${blurAmount + 1}" result="blur"/>
                    <feSpecularLighting in="blur" surfaceScale="5" specularConstant="1" specularExponent="20" lighting-color="white" result="specular">
                        <fePointLight x="-5000" y="-10000" z="20000"/>
                    </feSpecularLighting>
                    <feComposite in="specular" in2="SourceAlpha" operator="in" result="specular"/>
                    <feComposite in="SourceGraphic" in2="specular" operator="arithmetic" k1="0" k2="1" k3="1" k4="0"/>
                `;

                defs.appendChild(filter);
                return uniqueFilterId;
            }



            // --- HELPERS ---
            function createSvgElement(tag, attributes) { const el = document.createElementNS('http://www.w3.org/2000/svg', tag); for (const key in attributes) el.setAttribute(key, attributes[key]); return el; }
            function getSVGPoint(e_or_point) {
                const pt = svgCanvas.createSVGPoint();
                pt.x = e_or_point.clientX ?? e_or_point.x;
                pt.y = e_or_point.clientY ?? e_or_point.y;
                return pt.matrixTransform(svgCanvas.getScreenCTM().inverse());
            }
            function getDistance(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
            function getMidPoint(p1, p2) { return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 }; }

            // --- PALETTE & COLOR ---
            function setupPalette() {
                colorPaletteContainer.innerHTML = '';

                const customSection = document.createElement('div');
                customSection.className = 'space-y-4';
                customSection.innerHTML = `<div><label for="color-picker" class="text-sm font-medium block">Custom Color</label><input type="color" id="color-picker" value="#000000" class="mt-1 w-full h-8 border-gray-300 rounded-md cursor-pointer"></div>`;
                colorPaletteContainer.appendChild(customSection);
                colorPicker = document.getElementById('color-picker');
                colorPicker.addEventListener('input', (e) => {
                    selectColor(e.target.value);
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                });
            }
            function selectColor(color) {
                selectedBaseColor = color;
                colorPicker.value = color;
                if (floatingCustomColorInput) {
                    floatingCustomColorInput.value = color;
                }
                currentColor = selectedBaseColor;
                updateCanvasCursor();
                saveUiSettings();
                updateFloatingPaletteActiveColor();
                if (typeof updateRightPaletteActiveColor === 'function') {
                    updateRightPaletteActiveColor();
                }

                // NEW: If color picker is active, deactivate it and switch to pencil
                if (colorPickerImage && colorPickerImage.getAttribute('visibility') === 'visible') {
                    deactivateColorPicker();
                    switchTool('pencil');
                    hideFloatingPalette(); // Auto-minimize palette
                }
            }
            // NEW: Update color palette with frequently used colors
            function updateColorPalette() {
                if (currentTool !== 'color-picker') return;

                // Get top 12 most used colors
                const sortedColors = Array.from(colorUsageMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 12)
                    .map(entry => entry[0]);

                // Add current color if not in list
                if (!sortedColors.includes(currentColor)) {
                    sortedColors.unshift(currentColor);
                    sortedColors.pop();
                }

                // Create palette HTML
                let paletteHTML = '<div class="space-y-2"><p class="text-sm font-semibold text-gray-700">Frequently Used Colors</p><div class="grid grid-cols-6 gap-2">';
                sortedColors.forEach(color => {
                    paletteHTML += `<div class="color-swatch w-full h-8 rounded border-2 border-gray-300 cursor-pointer hover:scale-110 transition-transform" style="background-color: ${color}" data-color="${color}" title="${color}"></div>`;
                });
                paletteHTML += '</div></div>';

                // Insert after custom color picker
                const customSection = colorPaletteContainer.querySelector('div');
                if (customSection) {
                    const existingPalette = colorPaletteContainer.querySelector('.frequent-colors');
                    if (existingPalette) {
                        existingPalette.outerHTML = paletteHTML;
                    } else {
                        const paletteDiv = document.createElement('div');
                        paletteDiv.className = 'frequent-colors';
                        paletteDiv.innerHTML = paletteHTML;
                        colorPaletteContainer.insertBefore(paletteDiv, customSection);
                    }

                    // Add click handlers
                    colorPaletteContainer.querySelectorAll('.color-swatch').forEach(swatch => {
                        swatch.addEventListener('click', () => {
                            selectColor(swatch.dataset.color);
                            colorPaletteContainer.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                            swatch.classList.add('active');
                        });
                    });
                }
            }

            // --- NEW: Floating Color Palette Functions ---
            function setupFloatingPalette() {
                // Populate with default colors - expanded list with many recommended colors
                // Check if mobile/tablet to show more colors
                const isMobileOrTablet = window.matchMedia('(hover: none) and (pointer: coarse)').matches ||
                    window.innerWidth <= 768;

                const defaultColors = [
                    // Basic colors
                    '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                    // Common colors
                    '#FFA500', '#800080', '#FFC0CB', '#A52A2A', '#808080', '#008000', '#000080', '#800000',
                    // Vibrant colors
                    '#FFD700', '#4B0082', '#FF1493', '#00CED1', '#32CD32', '#FF4500', '#1E90FF', '#DC143C',
                    // Pastels
                    '#8B008B', '#00FA9A', '#FF6347', '#40E0D0', '#EE82EE', '#F0E68C', '#DDA0DD', '#98FB98',
                    // More colors
                    '#F5DEB3', '#FF69B4', '#CD5C5C', '#9370DB', '#3CB371', '#7B68EE', '#00BFFF', '#FF8C00',
                    '#2E8B57', '#D2691E', '#5F9EA0', '#6495ED', '#DA70D6', '#BA55D3', '#8A2BE2', '#4169E1',
                    '#48D1CC', '#90EE90', '#9AFF9A', '#ADFF2F', '#7FFF00', '#7CFC00', '#228B22', '#006400',
                    '#8FBC8F', '#66CDAA', '#40E0D0', '#FF1493', '#FF69B4', '#FF6347', '#FF4500', '#FF8C00',
                    // Additional recommended colors for mobile/tablet
                    ...(isMobileOrTablet ? [
                        '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
                        '#F8B739', '#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6', '#1ABC9C', '#E67E22',
                        '#34495E', '#16A085', '#27AE60', '#2980B9', '#8E44AD', '#C0392B', '#D35400', '#7F8C8D',
                        '#95A5A6', '#BDC3C7', '#ECF0F1', '#F1C40F', '#E74C3C', '#3498DB', '#2ECC71', '#F39C12',
                        '#9B59B6', '#1ABC9C', '#E67E22', '#34495E', '#16A085', '#27AE60', '#2980B9', '#8E44AD',
                        '#C0392B', '#D35400', '#7F8C8D', '#95A5A6', '#BDC3C7', '#ECF0F1', '#F1C40F', '#E74C3C',
                        '#FFB6C1', '#FFA07A', '#FFDAB9', '#FFE4B5', '#FFF8DC', '#F0FFF0', '#F5FFFA', '#F0F8FF',
                        '#E6E6FA', '#FFF0F5', '#FFE4E1', '#FFF5EE', '#FDF5E6', '#FAF0E6', '#FAEBD7', '#FFEFD5',
                        '#FFEBCD', '#FFE4C4', '#FFDAB9', '#EEE8AA', '#F0E68C', '#BDB76B', '#9ACD32', '#6B8E23',
                        '#556B2F', '#808000', '#ADFF2F', '#7FFF00', '#7CFC00', '#00FF00', '#32CD32', '#00FA9A',
                        '#00CED1', '#48D1CC', '#40E0D0', '#00FFFF', '#00BFFF', '#1E90FF', '#0000FF', '#0000CD',
                        '#191970', '#4169E1', '#6495ED', '#7B68EE', '#9370DB', '#8A2BE2', '#9400D3', '#9932CC',
                        '#BA55D3', '#DA70D6', '#EE82EE', '#FF00FF', '#FF1493', '#C71585', '#DB7093', '#FF69B4',
                        '#FFB6C1', '#FFC0CB', '#DC143C', '#B22222', '#8B0000', '#A52A2A', '#CD5C5C', '#F08080',
                        '#FA8072', '#E9967A', '#FF7F50', '#FF6347', '#FF4500', '#FF8C00', '#FFA500', '#FFD700',
                        '#FFFF00', '#ADFF2F', '#7FFF00', '#7CFC00', '#00FF00', '#32CD32', '#00FA9A', '#00CED1'
                    ] : [])
                ];

                floatingPaletteColors.innerHTML = '';
                defaultColors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'floating-color-swatch';
                    swatch.style.backgroundColor = color;
                    swatch.dataset.color = color;
                    swatch.title = color;
                    swatch.addEventListener('click', () => {
                        selectColor(color);
                        // Auto-minimize palette after color selection
                        hideFloatingPalette();
                    });
                    floatingPaletteColors.appendChild(swatch);
                });

                updateFloatingPaletteActiveColor();
            }
            function updateFloatingPaletteActiveColor() {
                if (!floatingPaletteColors) return;
                floatingPaletteColors.querySelectorAll('.floating-color-swatch').forEach(swatch => {
                    if (swatch.dataset.color === currentColor) {
                        swatch.classList.add('active');
                    } else {
                        swatch.classList.remove('active');
                    }
                });
            }

            function setupRightPalette() {
                const rightPalette = document.getElementById('right-side-palette');
                const toggleBtn = document.getElementById('right-palette-toggle');
                const wrapper = document.getElementById('right-side-palette-wrapper');

                if (toggleBtn && wrapper) {
                    toggleBtn.addEventListener('click', () => {
                        wrapper.classList.toggle('collapsed');
                    });
                }

                if (!rightPalette) return;

                const colors = [
                    '#FFFFFF', '#E0E0E0', '#A9A9A9', '#708090', '#3A3A3A', '#000000',
                    '#FFF59D', '#FFFF00', '#FFC107', '#FFA000',
                    '#FFCC80', '#FF9800', '#F57C00',
                    '#FF7F7F', '#FF0000', '#8B0000', '#722F37',
                    '#FF69B4', '#FFB6C1', '#FF00FF', '#D598D8', '#8E4585',
                    '#E6CCFF', '#8A2BE2', '#800080', '#4B0082', '#2E0854',
                    '#9999FF', '#4169E1', '#0000FF', '#1E90FF', '#87CEEB', '#B3D9FF', '#000080', '#00008B',
                    '#00FFFF', '#B2FFFF', '#40E0D0', '#AFEEEE', '#008080', '#005F5F', '#0D7377',
                    '#98FF98', '#B6FF6A', '#7CFF00', '#00FF00', '#008000', '#006400', '#004D00', '#2E8B57', '#3CB371', '#66CDAA', '#9DB39D', '#7F8F7F', '#9ACD32', '#808000', '#6B8E23', '#2F4F1E',
                    '#A1887F', '#8B4513', '#5D4037'
                ];

                rightPalette.innerHTML = '';

                colors.forEach(colorHex => {
                    const swatch = document.createElement('div');
                    swatch.className = 'right-color-swatch';
                    swatch.style.backgroundColor = colorHex;
                    swatch.dataset.color = colorHex;
                    swatch.title = colorHex;

                    swatch.addEventListener('click', () => {
                        selectColor(colorHex);
                        updateRightPaletteActiveColor();
                    });

                    rightPalette.appendChild(swatch);
                });

                updateRightPaletteActiveColor();
            }

            function updateRightPaletteActiveColor() {
                const rightPalette = document.getElementById('right-side-palette');
                if (!rightPalette) return;

                rightPalette.querySelectorAll('.right-color-swatch').forEach(swatch => {
                    const normalizeHex = (hex) => {
                        if (!hex) return '';
                        if (hex === '#000' || hex === 'black') return '#000000';
                        if (hex === '#fff' || hex === 'white') return '#ffffff';
                        return (hex.startsWith('#') ? hex : '#' + hex).toLowerCase();
                    };

                    const dsColor = normalizeHex(swatch.dataset.color);
                    const selColor = normalizeHex(currentColor);

                    if (dsColor === selColor) {
                        swatch.classList.add('active');
                    } else {
                        swatch.classList.remove('active');
                    }
                });
            }

            function toggleFloatingPalette() {
                if (floatingColorPaletteContainer.classList.contains('visible')) {
                    hideFloatingPalette();
                } else {
                    showFloatingPalette();
                }
            }

            function showFloatingPalette() {
                floatingColorPaletteContainer.classList.add('visible');
                floatingColorPaletteToggle.classList.add('active');
                // Show undo/redo buttons near palette
                updateUndoRedoPosition();
                wandHistoryContainer.classList.add('visible');
            }

            function hideFloatingPalette() {
                floatingColorPaletteContainer.classList.remove('visible');
                floatingColorPaletteToggle.classList.remove('active');
                // Hide undo/redo buttons when palette is hidden
                wandHistoryContainer.classList.remove('visible');
            }

            function updateUndoRedoPosition() {
                if (!floatingColorPaletteContainer || !wandHistoryContainer) return;

                const paletteRect = floatingColorPaletteContainer.getBoundingClientRect();
                const canvasRect = canvasContainer.getBoundingClientRect();

                if (floatingColorPaletteContainer.classList.contains('visible')) {
                    // Position to the right of the palette
                    const paletteRight = paletteRect.right - canvasRect.left;
                    wandHistoryContainer.style.left = `${paletteRight + 8}px`;
                    wandHistoryContainer.style.bottom = '1rem';
                    wandHistoryContainer.style.top = 'auto';
                    wandHistoryContainer.style.right = 'auto';
                } else {
                    // Default position when palette is hidden
                    wandHistoryContainer.style.left = '11rem';
                    wandHistoryContainer.style.bottom = '1rem';
                    wandHistoryContainer.style.top = 'auto';
                    wandHistoryContainer.style.right = 'auto';
                }
            }

            // Update undo/redo position on window resize
            window.addEventListener('resize', () => {
                if (floatingColorPaletteContainer && floatingColorPaletteContainer.classList.contains('visible')) {
                    updateUndoRedoPosition();
                }
                // Update canvas overlays on resize (important for mobile orientation changes)
                updateCanvasOverlays();
            });
            // NEW: Preview Image Functions
            function handlePreviewImageUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    previewImageHref = event.target.result;
                    const img = new Image();
                    img.onload = () => {
                        const initialWidth = 200;
                        const initialHeight = (img.height / img.width) * initialWidth;
                        previewImageState = {
                            x: 100,
                            y: 100,
                            width: initialWidth,
                            height: initialHeight,
                            baseWidth: initialWidth,
                            baseHeight: initialHeight,
                            visible: true,
                            zoom: 1.0,
                            panX: 0,
                            panY: 0
                        };
                        // Reset pin state when new image is uploaded
                        pinnedImageStates.previewImage = null;
                        activeImageType = 'previewImage';
                        updatePinButtonState();
                        updatePreviewImage();
                        previewImageControls.classList.remove('hidden');
                        togglePreviewImage.checked = true;
                        showToast("Preview image loaded.");
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                previewImageUpload.value = null;
            }
            function updatePreviewImage() {
                if (!previewImageHref) {
                    referencePreviewImage.classList.add('hidden');
                    return;
                }

                referencePreviewImage.src = previewImageHref;

                // Apply zoom and pan transforms
                const baseWidth = previewImageState.baseWidth || previewImageState.width;
                const baseHeight = previewImageState.baseHeight || previewImageState.height;
                const zoomedWidth = baseWidth * (previewImageState.zoom || 1.0);
                const zoomedHeight = baseHeight * (previewImageState.zoom || 1.0);

                // Calculate center point for zoom (use base position)
                const centerX = previewImageState.x + (previewImageState.baseWidth || previewImageState.width) / 2;
                const centerY = previewImageState.y + (previewImageState.baseHeight || previewImageState.height) / 2;

                // Apply pan offset
                const finalX = centerX - zoomedWidth / 2 + (previewImageState.panX || 0);
                const finalY = centerY - zoomedHeight / 2 + (previewImageState.panY || 0);

                referencePreviewImage.style.left = `${finalX}px`;
                referencePreviewImage.style.top = `${finalY}px`;
                referencePreviewImage.style.width = `${zoomedWidth}px`;
                referencePreviewImage.style.height = `${zoomedHeight}px`;

                if (previewImageState.visible) {
                    referencePreviewImage.classList.remove('hidden');
                    referencePreviewImage.classList.add('visible');
                } else {
                    referencePreviewImage.classList.add('hidden');
                    referencePreviewImage.classList.remove('visible');
                }
            }

            function deletePreviewImage() {
                previewImageHref = null;
                previewImageState = { x: 100, y: 100, width: 200, height: 200, baseWidth: 200, baseHeight: 200, visible: true, zoom: 1.0, panX: 0, panY: 0 };
                referencePreviewImage.classList.add('hidden');
                previewImageControls.classList.add('hidden');
                togglePreviewImage.checked = false;
                pinnedImageStates.previewImage = null;
                activeImageType = null;
                updatePinButtonState();
                showToast("Preview image deleted.");
            }

            // NEW: Unified Pin/Unpin Functions for All Images
            function togglePinActiveImage() {
                // Determine which image is currently active
                determineActiveImageType();

                if (!activeImageType) {
                    showToast("No image is currently active. Please upload an image.");
                    return;
                }

                let currentState = null;
                let imageTypeName = '';

                // Get current state based on active image type
                switch (activeImageType) {
                    case 'tracingImage':
                        if (!referenceImage) {
                            showToast("No tracing image loaded.");
                            return;
                        }
                        currentState = {
                            x: parseFloat(referenceImage.getAttribute('x')) || 0,
                            y: parseFloat(referenceImage.getAttribute('y')) || 0,
                            width: parseFloat(referenceImage.getAttribute('width')) || 0,
                            height: parseFloat(referenceImage.getAttribute('height')) || 0,
                            opacity: parseFloat(referenceImage.getAttribute('opacity')) || 1.0,
                            viewBox: { ...viewBox }
                        };
                        imageTypeName = 'Tracing Image';
                        break;
                    case 'colorRefImage':
                        if (!tempColorImageHref) {
                            showToast("No color reference image loaded.");
                            return;
                        }
                        currentState = { ...colorRefImageState };
                        imageTypeName = 'Color Reference Image';
                        break;
                    case 'previewImage':
                        if (!previewImageHref) {
                            showToast("No preview image loaded.");
                            return;
                        }
                        currentState = { ...previewImageState };
                        imageTypeName = 'Preview Image';
                        break;
                }

                // Toggle pin state
                if (pinnedImageStates[activeImageType]) {
                    // Already pinned - restore to pinned position
                    applyPinnedState(activeImageType, pinnedImageStates[activeImageType]);
                    showToast(`${imageTypeName} restored to pinned position.`);
                } else {
                    // Not pinned - pin current position
                    pinnedImageStates[activeImageType] = JSON.parse(JSON.stringify(currentState));
                    showToast(`${imageTypeName} position pinned.`);
                }
                updatePinButtonState();
            }

            function determineActiveImageType() {
                // Check which image was most recently interacted with or is visible
                // Priority: Last clicked/actively being manipulated
                if (previewImageState.visible && referencePreviewImage.classList.contains('visible')) {
                    activeImageType = 'previewImage';
                } else if (referenceImage && referenceImage.parentNode) {
                    activeImageType = 'tracingImage';
                } else if (tempColorImageHref) {
                    activeImageType = 'colorRefImage';
                } else {
                    activeImageType = null;
                }
            }

            function applyPinnedState(imageType, pinnedState) {
                if (!pinnedState) return;

                switch (imageType) {
                    case 'tracingImage':
                        if (referenceImage) {
                            referenceImage.setAttribute('x', pinnedState.x);
                            referenceImage.setAttribute('y', pinnedState.y);
                            referenceImage.setAttribute('width', pinnedState.width);
                            referenceImage.setAttribute('height', pinnedState.height);
                            referenceImage.setAttribute('opacity', pinnedState.opacity);

                            if (pinnedState.viewBox) {
                                viewBox = { ...pinnedState.viewBox };
                                setViewBox();
                            }

                            // Update mask image too
                            const maskImg = imageMask.querySelector('image');
                            if (maskImg) {
                                maskImg.setAttribute('x', pinnedState.x);
                                maskImg.setAttribute('y', pinnedState.y);
                                maskImg.setAttribute('width', pinnedState.width);
                                maskImg.setAttribute('height', pinnedState.height);
                            }
                        }
                        break;
                    case 'colorRefImage':
                        colorRefImageState = JSON.parse(JSON.stringify(pinnedState));
                        if (colorRefOpacitySlider) {
                            colorRefOpacitySlider.value = pinnedState.opacity || 1.0;
                        }
                        updateCanvasOverlays();
                        break;
                    case 'previewImage':
                        previewImageState = JSON.parse(JSON.stringify(pinnedState));
                        updatePreviewImage();
                        break;
                }
            }

            function updatePinButtonState() {
                determineActiveImageType();
                if (activeImageType && pinnedImageStates[activeImageType]) {
                    pinIcon.classList.add('hidden');
                    pinFilledIcon.classList.remove('hidden');
                } else {
                    pinIcon.classList.remove('hidden');
                    pinFilledIcon.classList.add('hidden');
                }
            }

            let previewImageInteraction = null;
            let previewImageStartPos = null;

            function handlePreviewImagePointerDown(e) {
                if (!previewImageState.visible || !referencePreviewImage.classList.contains('visible')) return;

                // Track active image type
                activeImageType = 'previewImage';
                updatePinButtonState();

                const containerRect = canvasContainer.getBoundingClientRect();
                const localX = e.clientX - containerRect.left;
                const localY = e.clientY - containerRect.top;

                // Calculate actual image bounds with zoom/pan
                const baseWidth = previewImageState.baseWidth || previewImageState.width;
                const baseHeight = previewImageState.baseHeight || previewImageState.height;
                const zoomedWidth = baseWidth * (previewImageState.zoom || 1.0);
                const zoomedHeight = baseHeight * (previewImageState.zoom || 1.0);
                const centerX = previewImageState.x + (previewImageState.baseWidth || previewImageState.width) / 2;
                const centerY = previewImageState.y + (previewImageState.baseHeight || previewImageState.height) / 2;
                const finalX = centerX - zoomedWidth / 2 + (previewImageState.panX || 0);
                const finalY = centerY - zoomedHeight / 2 + (previewImageState.panY || 0);

                // Check if mouse is over preview image
                const isInImage = localX >= finalX && localX <= finalX + zoomedWidth &&
                    localY >= finalY && localY <= finalY + zoomedHeight;

                if (!isInImage) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                // Start panning
                previewImageInteraction = 'pan';
                referencePreviewImage.classList.add('moving');
                previewImageStartPos = { x: e.clientX, y: e.clientY };
                const startState = { ...previewImageState };

                const handleMove = (moveEvent) => {
                    if (!previewImageInteraction || previewImageInteraction !== 'pan') return;

                    const dx = moveEvent.clientX - previewImageStartPos.x;
                    const dy = moveEvent.clientY - previewImageStartPos.y;
                    previewImageState.panX = (startState.panX || 0) + dx;
                    previewImageState.panY = (startState.panY || 0) + dy;
                    updatePreviewImage();
                };

                const handleUp = (upEvent) => {
                    previewImageInteraction = null;
                    referencePreviewImage.classList.remove('moving');
                    document.removeEventListener('pointermove', handleMove);
                    document.removeEventListener('pointerup', handleUp);
                };

                document.addEventListener('pointermove', handleMove);
                document.addEventListener('pointerup', handleUp);
            }

            // Handle wheel zoom for preview image when mouse is over it
            function handlePreviewImageWheel(e) {
                if (!previewImageState.visible || !referencePreviewImage.classList.contains('visible')) return;

                // Check if mouse is over the preview image element
                const rect = referencePreviewImage.getBoundingClientRect();
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                if (mouseX >= rect.left && mouseX <= rect.right &&
                    mouseY >= rect.top && mouseY <= rect.bottom) {
                    e.preventDefault();
                    e.stopPropagation();

                    const containerRect = canvasContainer.getBoundingClientRect();
                    const localX = mouseX - containerRect.left;
                    const localY = mouseY - containerRect.top;

                    // Calculate current image bounds
                    const baseWidth = previewImageState.baseWidth || previewImageState.width;
                    const baseHeight = previewImageState.baseHeight || previewImageState.height;
                    const zoomedWidth = baseWidth * (previewImageState.zoom || 1.0);
                    const zoomedHeight = baseHeight * (previewImageState.zoom || 1.0);
                    const centerX = previewImageState.x + (previewImageState.baseWidth || previewImageState.width) / 2;
                    const centerY = previewImageState.y + (previewImageState.baseHeight || previewImageState.height) / 2;
                    const finalX = centerX - zoomedWidth / 2 + (previewImageState.panX || 0);
                    const finalY = centerY - zoomedHeight / 2 + (previewImageState.panY || 0);

                    // Zoom factor
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.1, Math.min(10, (previewImageState.zoom || 1.0) * zoomFactor));

                    // Zoom towards mouse position
                    const mouseXInImage = localX - finalX;
                    const mouseYInImage = localY - finalY;
                    const zoomRatio = newZoom / (previewImageState.zoom || 1.0);

                    // Adjust pan to keep zoom centered on mouse position
                    previewImageState.panX = (previewImageState.panX || 0) - (mouseXInImage - zoomedWidth / 2) * (zoomRatio - 1);
                    previewImageState.panY = (previewImageState.panY || 0) - (mouseYInImage - zoomedHeight / 2) * (zoomRatio - 1);
                    previewImageState.zoom = newZoom;

                    updatePreviewImage();
                }
            }
            // --- WET PAINT STROKE HELPERS ---
            function ensureWetPaintStrokeFilter(blurLevel = 0) {
                if (!defs) return null;
                const numericBlur = Number.isFinite(blurLevel) ? blurLevel : parseFloat(blurLevel) || 0;
                const clamped = Math.max(0, Math.min(5, Math.round(numericBlur)));
                const filterId = `wet-paint-stroke-filter-${clamped}`;
                const existing = defs.querySelector(`#${filterId}`);
                if (existing) return filterId;

                // REDUCED: Smaller spread/offset for tighter, lighter look
                const spread = wetPaintOuterShadowBlur + clamped * 0.15;
                const offset = wetPaintOuterShadowSize + clamped * 0.8;

                // OPTIMIZED: Reduce filter region from 200% to 150% to save memory/processing
                const filter = createSvgElement('filter', {
                    id: filterId,
                    x: '-25%',
                    y: '-25%',
                    width: '150%',
                    height: '150%',
                    'color-interpolation-filters': 'sRGB'
                });

                // --- OUTER SHADOW (Optimized) ---
                const shadowBlur = createSvgElement('feGaussianBlur', {
                    in: 'SourceAlpha',
                    stdDeviation: spread.toFixed(1),
                    result: 'shadowBlur'
                });

                const offsetNode = createSvgElement('feOffset', {
                    in: 'shadowBlur',
                    dx: offset.toFixed(1),
                    dy: (offset * 1.2).toFixed(1),
                    result: 'shadowOffset'
                });

                const shadowColor = createSvgElement('feFlood', {
                    'flood-color': '#000000',
                    'flood-opacity': '0.5',
                    result: 'shadowColor'
                });

                const shadowComposite = createSvgElement('feComposite', {
                    in: 'shadowColor',
                    in2: 'shadowOffset',
                    operator: 'in',
                    result: 'outerShadow'
                });

                // Mask outer shadow so it only shows OUTSIDE
                const finalShadow = createSvgElement('feComposite', {
                    in: 'outerShadow',
                    in2: 'SourceAlpha',
                    operator: 'out',
                    result: 'finalShadow'
                });

                // --- HIGHLIGHTS/WETNESS (Lite Version) ---
                // Removed complex inner shadow chain for performance ("Very Lite")
                // Use simplified specular lighting for the wet "tube" look

                const heightMap = createSvgElement('feGaussianBlur', {
                    in: 'SourceAlpha',
                    stdDeviation: Math.max(1.0, spread * 0.6).toFixed(1),
                    result: 'heightMap'
                });

                const specular = createSvgElement('feSpecularLighting', {
                    in: 'heightMap',
                    surfaceScale: '3', // Reduced surface scale for smoother, superior "lite" look
                    specularConstant: '0.9',
                    specularExponent: '25', // Broader, softer shine
                    'lighting-color': '#ffffff',
                    result: 'specular'
                });
                // Position light to give good top-left highlight
                specular.appendChild(createSvgElement('fePointLight', { x: '-1000', y: '-2000', z: '1000' }));

                const specularMasked = createSvgElement('feComposite', {
                    in: 'specular',
                    in2: 'SourceAlpha',
                    operator: 'in',
                    result: 'specularMasked'
                });

                // --- COMPOSITION ---
                const finalResult = createSvgElement('feMerge');
                finalResult.appendChild(createSvgElement('feMergeNode', { in: 'finalShadow' })); // Shadow Bottom
                finalResult.appendChild(createSvgElement('feMergeNode', { in: 'SourceGraphic' })); // Paint Body Middle
                finalResult.appendChild(createSvgElement('feMergeNode', { in: 'specularMasked' })); // Shine Top

                filter.append(shadowBlur, offsetNode, shadowColor, shadowComposite, finalShadow, heightMap, specular, specularMasked, finalResult);

                defs.appendChild(filter);
                return filterId;
            }

            // --- GLOSSY EFFECT FILTER ---
            function ensureGlossyEffectFilter(blurLevel = 0) {
                if (!defs) return null;
                const numericBlur = Number.isFinite(blurLevel) ? blurLevel : parseFloat(blurLevel) || 0;
                const clamped = Math.max(0, Math.min(5, Math.round(numericBlur)));
                const filterId = `glossy-effect-filter-${clamped}`;
                const existing = defs.querySelector(`#${filterId}`);
                if (existing) return filterId;

                const filter = createSvgElement('filter', {
                    id: filterId,
                    x: '-50%',
                    y: '-50%',
                    width: '200%',
                    height: '200%',
                    'color-interpolation-filters': 'sRGB'
                });

                // Create a smooth height map for realistic glossy surface
                const heightMap = createSvgElement('feGaussianBlur', {
                    in: 'SourceAlpha',
                    stdDeviation: '2.0',
                    result: 'heightMap'
                });

                // Primary specular highlight - bright and focused
                const specular1 = createSvgElement('feSpecularLighting', {
                    in: 'heightMap',
                    surfaceScale: '4',
                    specularConstant: '1.0',
                    specularExponent: '40',
                    'lighting-color': '#cccccc',
                    result: 'specular1'
                });
                specular1.appendChild(createSvgElement('fePointLight', { x: '-2000', y: '-2500', z: '6000' }));

                // Secondary specular highlight for depth
                const specular2 = createSvgElement('feSpecularLighting', {
                    in: 'heightMap',
                    surfaceScale: '3',
                    specularConstant: '0.8',
                    specularExponent: '25',
                    'lighting-color': '#ffffff',
                    result: 'specular2'
                });
                specular2.appendChild(createSvgElement('fePointLight', { x: '2500', y: '-1800', z: '5000' }));

                // Mask speculars to the stroke shape
                const specular1Masked = createSvgElement('feComposite', {
                    in: 'specular1',
                    in2: 'SourceAlpha',
                    operator: 'in',
                    result: 'specular1Masked'
                });

                const specular2Masked = createSvgElement('feComposite', {
                    in: 'specular2',
                    in2: 'SourceAlpha',
                    operator: 'in',
                    result: 'specular2Masked'
                });

                // Combine speculars and apply screen blend to preserve color
                const combinedSpecular = createSvgElement('feBlend', {
                    in: 'specular1Masked',
                    in2: 'specular2Masked',
                    mode: 'screen',
                    result: 'combinedSpecular'
                });

                const gloss = createSvgElement('feBlend', {
                    in: 'SourceGraphic',
                    in2: 'combinedSpecular',
                    mode: 'screen',
                    result: 'gloss'
                });

                // Shadow for depth
                const shadowBlur = createSvgElement('feGaussianBlur', {
                    in: 'SourceAlpha',
                    stdDeviation: '2.0',
                    result: 'shadowBlur'
                });

                const offsetNode = createSvgElement('feOffset', {
                    in: 'shadowBlur',
                    dx: '1',
                    dy: '1',
                    result: 'offsetNode'
                });

                const shadowColor = createSvgElement('feFlood', {
                    'flood-color': 'rgba(0, 0, 0, 0.5)',
                    'flood-opacity': '0.5',
                    result: 'shadowColor'
                });

                const shadow = createSvgElement('feComposite', {
                    in: 'shadowColor',
                    in2: 'offsetNode',
                    operator: 'in',
                    result: 'shadow'
                });

                const merge = createSvgElement('feMerge');
                merge.appendChild(createSvgElement('feMergeNode', { in: 'shadow' }));
                merge.appendChild(createSvgElement('feMergeNode', { in: 'SourceGraphic' }));

                filter.appendChild(heightMap);
                filter.appendChild(specular1);
                filter.appendChild(specular2);
                filter.appendChild(specular1Masked);
                filter.appendChild(specular2Masked);
                filter.appendChild(combinedSpecular);
                filter.appendChild(gloss);
                filter.appendChild(shadowBlur);
                filter.appendChild(offsetNode);
                filter.appendChild(shadowColor);
                filter.appendChild(shadow);
                filter.appendChild(merge);

                defs.appendChild(filter);
                return filterId;
            }
            // --- GLITTER EFFECT FILTER ---
            function ensureGlitterEffectFilter(blurAmount, sizeClass = 'm') {
                const uniqueFilterId = `glitter-effect-filter-${blurAmount}-${sizeClass}`;
                if (document.getElementById(uniqueFilterId)) return uniqueFilterId;

                // Adaptive region
                let region = { x: '-20%', y: '-20%', width: '140%', height: '140%' };

                const filter = createSvgElement('filter', {
                    id: uniqueFilterId,
                    filterUnits: 'objectBoundingBox',
                    x: region.x, y: region.y, width: region.width, height: region.height,
                    'color-interpolation-filters': 'sRGB'
                });

                // 1. Heavy Noise for Salt & Pepper
                // Use global glitterSize (inverted for frequency logic: higher size = larger grains = lower frequency)
                const baseFreq = (10.0 / glitterSize).toFixed(2);
                const noise = createSvgElement('feTurbulence', {
                    type: 'fractalNoise',
                    baseFrequency: baseFreq,
                    numOctaves: '3',
                    stitchTiles: 'stitch',
                    result: 'noise'
                });

                // 2. Base Texture (Grain): Modulate SourceGraphic with Noise
                const textureComposite = createSvgElement('feComposite', {
                    in: 'noise',
                    in2: 'SourceGraphic',
                    operator: 'arithmetic',
                    k1: '0',
                    k2: '0.6',
                    k3: '1',
                    k4: '-0.3',
                    result: 'texturedBase'
                });

                // 3. Salt (White) Mask
                // Use global glitterDensity (maps to threshold)
                const threshold = -(1.1 - glitterDensity).toFixed(2);
                const saltMatrix = createSvgElement('feColorMatrix', {
                    in: 'noise',
                    type: 'matrix',
                    values: `1 0 0 0 ${threshold}  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0`,
                    result: 'saltRaw'
                });

                // Convert positive saltRaw values to Opaque White
                const saltSparkles = createSvgElement('feColorMatrix', {
                    in: 'saltRaw',
                    type: 'matrix',
                    values: '0 0 0 0 1  0 0 0 0 1  0 0 0 0 1  255 0 0 0 0',
                    result: 'saltSparkles'
                });

                // 4. Pepper (Black) Mask
                const pepperThreshold = (glitterDensity * 0.8 + 0.1).toFixed(2);
                const pepperMatrix = createSvgElement('feColorMatrix', {
                    in: 'noise',
                    type: 'matrix',
                    values: `-1 0 0 0 ${pepperThreshold}  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0`,
                    result: 'pepperRaw'
                });

                // Convert positive pepperRaw values to Opaque Black
                const pepperSpecks = createSvgElement('feColorMatrix', {
                    in: 'pepperRaw',
                    type: 'matrix',
                    values: '0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  255 0 0 0 0',
                    result: 'pepperSpecks'
                });

                // 4b. Tiny Super-Sparkles (Stars)
                const starNoise = createSvgElement('feTurbulence', {
                    type: 'fractalNoise',
                    baseFrequency: '0.9', // Very high frequency for tiny star points
                    numOctaves: '1',
                    seed: '77',
                    result: 'starNoise'
                });

                const sThreshold = -(1.5 - (glitterStarCount * 1.1)).toFixed(3); // Star density control
                const starMatrix = createSvgElement('feColorMatrix', {
                    in: 'starNoise',
                    type: 'matrix',
                    values: `1 0 0 0 ${sThreshold}  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0`,
                    result: 'starRaw'
                });

                const starBlur = createSvgElement('feGaussianBlur', {
                    in: 'starRaw',
                    stdDeviation: '1.2',
                    result: 'starBlurred'
                });

                const starPoints = createSvgElement('feColorMatrix', {
                    in: 'starRaw',
                    type: 'matrix',
                    values: '0 0 0 0 1  0 0 0 0 1  0 0 0 0 1  1000 0 0 0 0',
                    result: 'starPoints'
                });

                const starGlow = createSvgElement('feColorMatrix', {
                    in: 'starBlurred',
                    type: 'matrix',
                    values: '1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 0.8 0',
                    result: 'starGlow'
                });

                // 4c. Specular Highlights (Premium 3D feel)
                const specLighting = createSvgElement('feSpecularLighting', {
                    in: 'noise',
                    surfaceScale: '5',
                    specularConstant: '1.2',
                    specularExponent: '35',
                    'lighting-color': '#ffffff',
                    result: 'specOut'
                });
                const specLight = createSvgElement('feDistantLight', {
                    azimuth: '225',
                    elevation: '40'
                });
                specLighting.appendChild(specLight);

                // 5. Merge Layers: Base -> Pepper -> Salt -> Specular -> StarGlow -> StarPoints
                const merge = createSvgElement('feMerge', { result: 'merged' });
                const baseNode = createSvgElement('feMergeNode', { in: 'texturedBase' });
                const pepperNode = createSvgElement('feMergeNode', { in: 'pepperSpecks' });
                const saltNode = createSvgElement('feMergeNode', { in: 'saltSparkles' });
                const specNode = createSvgElement('feMergeNode', { in: 'specOut' });
                const starGlowNode = createSvgElement('feMergeNode', { in: 'starGlow' });
                const starPointsNode = createSvgElement('feMergeNode', { in: 'starPoints' });

                // Order: Base is bottom. Then Pepper. Then Salt. Then Specular. Then Stars.
                merge.appendChild(baseNode);
                merge.appendChild(pepperNode);
                merge.appendChild(saltNode);
                merge.appendChild(specNode);
                merge.appendChild(starGlowNode);
                merge.appendChild(starPointsNode);

                // 6. Clip to SourceAlpha (Stroke Shape)
                // This ensures we only draw inside the stroke
                const finalComposite = createSvgElement('feComposite', {
                    in: 'merged',
                    in2: 'SourceAlpha',
                    operator: 'in',
                    result: 'final'
                });

                // Append all to filter
                filter.appendChild(noise);
                filter.appendChild(textureComposite);
                filter.appendChild(saltMatrix);
                filter.appendChild(saltSparkles);
                filter.appendChild(pepperMatrix);
                filter.appendChild(pepperSpecks);
                filter.appendChild(starNoise);
                filter.appendChild(starMatrix);
                filter.appendChild(starBlur);
                filter.appendChild(starPoints);
                filter.appendChild(starGlow);
                filter.appendChild(specLighting);
                filter.appendChild(merge);
                filter.appendChild(finalComposite);

                defs.appendChild(filter);
                return uniqueFilterId;
            }
            function updateGlitterFilters() {
                if (!defs) return;
                const filters = defs.querySelectorAll('filter[id^="glitter-effect-filter-"]');
                filters.forEach(filter => {
                    const noise = filter.querySelector('feTurbulence');
                    if (noise) {
                        const baseFreq = (10.0 / glitterSize).toFixed(2);
                        noise.setAttribute('baseFrequency', baseFreq);
                    }

                    const saltMatrix = filter.querySelector('feColorMatrix[result="saltRaw"]');
                    if (saltMatrix) {
                        const threshold = -(1.1 - glitterDensity).toFixed(2);
                        saltMatrix.setAttribute('values', `1 0 0 0 ${threshold}  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0`);
                    }

                    const pepperMatrix = filter.querySelector('feColorMatrix[result="pepperRaw"]');
                    if (pepperMatrix) {
                        const pepperThreshold = (glitterDensity * 0.8 + 0.1).toFixed(2);
                        pepperMatrix.setAttribute('values', `-1 0 0 0 ${pepperThreshold}  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0`);
                    }

                    const starMatrix = filter.querySelector('feColorMatrix[result="starRaw"]');
                    if (starMatrix) {
                        const sThreshold = -(1.5 - (glitterStarCount * 1.1)).toFixed(3);
                        starMatrix.setAttribute('values', `1 0 0 0 ${sThreshold}  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0`);
                    }
                });
            }

            // --- COLOR PICKER FUNCTIONS ---
            function handleTempImageUpload(e) {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    tempColorImageHref = event.target.result;

                    const img = new Image();
                    img.onload = () => {
                        const padding = 0.95, imgAspectRatio = img.width / img.height;
                        const canvasAspectRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
                        let width, height;
                        if (imgAspectRatio > canvasAspectRatio) { width = viewBox.w * padding; height = width / imgAspectRatio; } else { height = viewBox.h * padding; width = height * imgAspectRatio; }
                        const x = viewBox.x + (viewBox.w - width) / 2, y = viewBox.y + (viewBox.h - height) / 2;

                        colorRefImageState = { x, y, width, height, opacity: 1.0 };

                        colorRefOpacitySlider.value = 1.0;
                        colorRefControls.classList.remove('hidden');

                        // Sync ref mode image if enabled
                        if (refModeEnabled && referenceImage) {
                            syncRefModeImage();
                        }

                        updateCanvasOverlays();

                        addHistoryState('drawing'); // NEW: Add history state after upload
                    };
                    img.src = event.target.result;

                    showToast("Color Reference loaded.");
                    deleteTempImageBtn.classList.remove('hidden');
                };
                reader.readAsDataURL(file);
                tempImageUpload.value = null;
            }

            function handleDeleteTempImage(e) {
                if (e) e.preventDefault();
                if (!tempColorImageHref) return;
                document.querySelectorAll('.auto-stroke-overlay').forEach(el => el.remove());

                tempColorImageHref = null;
                pinnedImageStates.colorRefImage = null;
                if (activeImageType === 'colorRefImage') activeImageType = null;
                updatePinButtonState();

                if (currentTool === 'color-picker' || isEditingColorRef) {
                    deactivateColorPicker();
                    switchTool('pencil');
                }

                // Disable Ref Mode when color reference is deleted
                if (refModeEnabled) {
                    refModeToggle.checked = false;
                    disableRefMode();
                }

                showToast("Color Reference deleted.");
                deleteTempImageBtn.classList.add('hidden');
                colorRefControls.classList.add('hidden');
                updateCanvasOverlays();

                addHistoryState('drawing'); // NEW: Add history state after deletion
            }
            function activateColorPicker() {
                return new Promise((resolve, reject) => {
                    const imageToPickFrom = tempColorImageHref;

                    if (!imageToPickFrom) {
                        return reject(new Error("No color reference image to pick from"));
                    }

                    svgCanvas.style.zIndex = '30';
                    antsCanvas.style.zIndex = '5';

                    if (colorPickerImage.getAttribute('visibility') === 'visible' && !isEditingColorRef) {
                        return resolve();
                    }

                    const img = new Image();
                    img.onload = () => {
                        try {
                            referenceImageCtx.clearRect(0, 0, referenceImageCanvas.width, referenceImageCanvas.height);
                            referenceImageCanvas.width = img.width;
                            referenceImageCanvas.height = img.height;
                            referenceImageCtx.drawImage(img, 0, 0, img.width, img.height);

                            colorPickerImage.setAttribute('href', imageToPickFrom);
                            colorPickerImage.setAttribute('width', colorRefImageState.width);
                            colorPickerImage.setAttribute('height', colorRefImageState.height);
                            colorPickerImage.setAttribute('x', colorRefImageState.x);
                            colorPickerImage.setAttribute('y', colorRefImageState.y);
                            colorPickerImage.setAttribute('opacity', colorRefImageState.opacity);
                            colorPickerImage.setAttribute('visibility', 'visible');

                            colorRefOpacitySlider.value = colorRefImageState.opacity;

                            if (referenceImage) referenceImage.style.pointerEvents = 'none';

                            // NEW: Show floating color palette when color picker is active
                            showFloatingPalette();

                            resolve();
                        } catch (e) {
                            console.error("Error drawing image to canvas:", e);
                            showToast("Could not prepare color picker.", true);
                            reject(e);
                        }
                    };
                    img.onerror = () => {
                        showToast("Error loading image for picker.", true);
                        reject(new Error("Image load error"));
                    };
                    img.crossOrigin = "anonymous";
                    img.src = imageToPickFrom;
                });
            }

            function deactivateColorPicker() {
                if (referenceImage) referenceImage.style.pointerEvents = 'auto';

                isEditingColorRef = false;
                editColorRefBtn.classList.remove('active');
                editColorRefBtn.querySelector('span').textContent = 'Pan/Zoom Color Ref';

                if (colorPickerImage) {
                    colorPickerImage.setAttribute('visibility', 'hidden');
                }

                // NEW: Hide unpick button
                unpickColorBtn.classList.add('hidden');

                // NEW: Hide color palette when deactivating
                const frequentColors = colorPaletteContainer.querySelector('.frequent-colors');
                if (frequentColors) {
                    frequentColors.style.display = 'none';
                }
                // Note: Floating palette stays visible so user can still choose colors

                updateCanvasOverlays();

                svgCanvas.style.zIndex = '10';
                antsCanvas.style.zIndex = '20';
            }
            // --- BACKGROUND IMAGE FUNCTIONS ---
            function handleBgImageUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    bgImageHref = event.target.result;
                    const img = new Image();
                    img.onload = () => {
                        bgImageState = {
                            x: viewBox.x,
                            y: viewBox.y,
                            width: viewBox.w,
                            height: viewBox.h,
                            opacity: parseFloat(bgOpacitySlider.value) || 1.0,
                            visible: true
                        };
                        updateBgImage();
                        bgImageControls.classList.remove('hidden');
                        showToast("Background image loaded.");
                        addHistoryState('drawing');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                bgImageUpload.value = null;
            }

            function updateBgImage() {
                if (!bgImageHref || !bgImageLayer) {
                    if (bgImageLayer) bgImageLayer.setAttribute('visibility', 'hidden');
                    return;
                }

                bgImageLayer.setAttribute('href', bgImageHref);
                bgImageLayer.setAttribute('x', bgImageState.x ?? viewBox.x);
                bgImageLayer.setAttribute('y', bgImageState.y ?? viewBox.y);
                bgImageLayer.setAttribute('width', bgImageState.width ?? viewBox.w);
                bgImageLayer.setAttribute('height', bgImageState.height ?? viewBox.h);
                bgImageLayer.setAttribute('opacity', bgImageState.opacity);
                bgImageLayer.setAttribute('visibility', bgImageState.visible ? 'visible' : 'hidden');
            }

            function deleteBgImage() {
                bgImageHref = null;
                bgImageState = { opacity: 1.0, visible: true };
                if (bgImageLayer) bgImageLayer.setAttribute('visibility', 'hidden');
                bgImageControls.classList.add('hidden');
                showToast("Background image deleted.");
                addHistoryState('drawing');
            }
            function pickColorAtPoint(svgPoint) {
                if (!colorPickerImage || colorPickerImage.getAttribute('visibility') === 'hidden') {
                    deactivateColorPicker();
                    switchTool('pencil');
                    return;
                }

                const imgX = parseFloat(colorPickerImage.getAttribute('x'));
                const imgY = parseFloat(colorPickerImage.getAttribute('y'));
                const imgWidth = parseFloat(colorPickerImage.getAttribute('width'));
                const imgHeight = parseFloat(colorPickerImage.getAttribute('height'));

                const dataWidth = referenceImageCanvas.width;
                const dataHeight = referenceImageCanvas.height;

                if (svgPoint.x < imgX || svgPoint.x > imgX + imgWidth || svgPoint.y < imgY || svgPoint.y > imgY + imgHeight) {
                    deactivateColorPicker();
                    switchTool('pencil');
                    return;
                }

                const percentX = (svgPoint.x - imgX) / imgWidth;
                const percentY = (svgPoint.y - imgY) / imgHeight;

                const px = Math.floor(percentX * dataWidth);
                const py = Math.floor(percentY * dataHeight);

                if (px < 0 || px >= dataWidth || py < 0 || py >= dataHeight) {
                    deactivateColorPicker();
                    switchTool('pencil');
                    return;
                }

                try {
                    const pixelData = referenceImageCtx.getImageData(px, py, 1, 1).data;
                    const r = pixelData[0], g = pixelData[1], b = pixelData[2];
                    const hexColor = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();

                    // NEW: Track color usage when picking
                    colorUsageMap.set(hexColor, (colorUsageMap.get(hexColor) || 0) + 1);

                    selectColor(hexColor);
                    deactivateColorPicker();
                    switchTool('pencil');

                } catch (e) {
                    console.error("Error picking color:", e);
                    showToast("Could not pick color. Image may be cross-origin.", true);
                    deactivateColorPicker();
                    switchTool('pencil');
                }
            }

            // --- REFERENCE MODE FUNCTIONS ---
            function enableRefMode() {
                if (!tempColorImageHref || !referenceImage) {
                    showToast("Please upload both Main Image and Color Reference Image first.", true);
                    refModeToggle.checked = false;
                    refModeEnabled = false;
                    return;
                }

                // Sync reference image with main image position and size
                syncRefModeImage();

                // Show ref mode image
                if (refModeImage) {
                    refModeImage.setAttribute('visibility', 'visible');
                    refModeImage.setAttribute('opacity', colorRefImageState.opacity || 1.0);
                }

                showToast("Ref Mode enabled. Click on reference image to pick colors.");
                if (typeof shortcutRefModeBtn !== 'undefined' && shortcutRefModeBtn) {
                    shortcutRefModeBtn.classList.add('active');
                }
            }

            function disableRefMode() {
                if (refModeImage) {
                    refModeImage.setAttribute('visibility', 'hidden');
                }
                refModeCurrentColor = null;
                refModeInitialColor = null; // Clear initial color when disabling
                showToast("Ref Mode disabled.");
                if (typeof shortcutRefModeBtn !== 'undefined' && shortcutRefModeBtn) {
                    shortcutRefModeBtn.classList.remove('active');
                }
            }

            function syncRefModeImage() {
                if (!referenceImage || !tempColorImageHref || !refModeImage) return;

                // Get main image position and size
                const mainX = parseFloat(referenceImage.getAttribute('x') || 0);
                const mainY = parseFloat(referenceImage.getAttribute('y') || 0);
                const mainWidth = parseFloat(referenceImage.getAttribute('width') || 1000);
                const mainHeight = parseFloat(referenceImage.getAttribute('height') || 1000);

                // Set ref mode image to match main image
                refModeImage.setAttribute('href', tempColorImageHref);
                refModeImage.setAttribute('x', mainX);
                refModeImage.setAttribute('y', mainY);
                refModeImage.setAttribute('width', mainWidth);
                refModeImage.setAttribute('height', mainHeight);

                // Update color ref image state to match
                colorRefImageState.x = mainX;
                colorRefImageState.y = mainY;
                colorRefImageState.width = mainWidth;
                colorRefImageState.height = mainHeight;

                // Load image to canvas for color picking
                const img = new Image();
                img.onload = () => {
                    try {
                        referenceImageCtx.clearRect(0, 0, referenceImageCanvas.width, referenceImageCanvas.height);
                        referenceImageCanvas.width = img.width;
                        referenceImageCanvas.height = img.height;
                        referenceImageCtx.drawImage(img, 0, 0, img.width, img.height);
                    } catch (e) {
                        console.error("Error loading ref mode image to canvas:", e);
                    }
                };
                img.crossOrigin = "anonymous";
                img.src = tempColorImageHref;
            }

            function pickColorFromRefMode(svgPoint) {
                if (!refModeEnabled || !refModeImage || !tempColorImageHref) return null;

                const imgX = parseFloat(refModeImage.getAttribute('x'));
                const imgY = parseFloat(refModeImage.getAttribute('y'));
                const imgWidth = parseFloat(refModeImage.getAttribute('width'));
                const imgHeight = parseFloat(refModeImage.getAttribute('height'));

                const dataWidth = referenceImageCanvas.width;
                const dataHeight = referenceImageCanvas.height;

                if (svgPoint.x < imgX || svgPoint.x > imgX + imgWidth || svgPoint.y < imgY || svgPoint.y > imgY + imgHeight) {
                    return null;
                }

                const percentX = (svgPoint.x - imgX) / imgWidth;
                const percentY = (svgPoint.y - imgY) / imgHeight;

                const px = Math.floor(percentX * dataWidth);
                const py = Math.floor(percentY * dataHeight);

                if (px < 0 || px >= dataWidth || py < 0 || py >= dataHeight) {
                    return null;
                }

                try {
                    const pixelData = referenceImageCtx.getImageData(px, py, 1, 1).data;
                    const r = pixelData[0], g = pixelData[1], b = pixelData[2];
                    const hexColor = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
                    return hexColor;
                } catch (e) {
                    console.error("Error picking color from ref mode:", e);
                    return null;
                }
            }

            function isColorSimilar(color1, color2, tolerance = null) {
                if (!color1 || !color2) return false;
                if (color1 === color2) return true;

                const tol = tolerance !== null ? tolerance : refModeColorTolerance;

                // Parse hex colors
                const r1 = parseInt(color1.slice(1, 3), 16);
                const g1 = parseInt(color1.slice(3, 5), 16);
                const b1 = parseInt(color1.slice(5, 7), 16);

                const r2 = parseInt(color2.slice(1, 3), 16);
                const g2 = parseInt(color2.slice(3, 5), 16);
                const b2 = parseInt(color2.slice(5, 7), 16);

                // Check if all channels are within tolerance
                return Math.abs(r1 - r2) <= tol &&
                    Math.abs(g1 - g2) <= tol &&
                    Math.abs(b1 - b2) <= tol;
            }
            // --- IMAGE & SVG HANDLING ---
            function handleImageUpload(e) {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    deleteReferenceImage(false);
                    const img = new Image();
                    img.onload = () => {
                        const padding = 0.95, imgAspectRatio = img.width / img.height;
                        const canvasAspectRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
                        let width, height;
                        if (imgAspectRatio > canvasAspectRatio) { width = viewBox.w * padding; height = width / imgAspectRatio; } else { height = viewBox.h * padding; width = height * imgAspectRatio; }
                        const x = viewBox.x + (viewBox.w - width) / 2, y = viewBox.y + (viewBox.h - height) / 2;

                        referenceImage = createSvgElement('image', { href: event.target.result, width, height, x, y, opacity: opacitySlider.value, id: 'reference-image' });
                        referenceImage.crossOrigin = "anonymous";
                        // Insert referenceImage before refModeImage (main image should be below ref overlay)
                        const insertBefore = refModeImage || drawingLayer;
                        svgCanvas.insertBefore(referenceImage, insertBefore);

                        imageMask.innerHTML = '';
                        const maskImage = createSvgElement('image', { href: event.target.result, width, height, x, y, filter: 'url(#trace-mask-filter)' });
                        maskImage.crossOrigin = "anonymous";
                        imageMask.appendChild(maskImage);
                        imageTools.classList.remove('hidden');

                        // Reset pin state when new image is loaded
                        pinnedImageStates.tracingImage = null;
                        activeImageType = 'tracingImage';
                        updatePinButtonState();

                        // Apply filter if enabled
                        if (filterEnabled && currentColorFilter !== 'none') {
                            applyColorFilter();
                        }

                        // Sync ref mode image if enabled
                        if (refModeEnabled && tempColorImageHref) {
                            syncRefModeImage();
                        }

                        addHistoryState('drawing');
                    };
                    img.crossOrigin = "anonymous";
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }

            function deleteReferenceImage(addToHistory = true) {
                if (referenceImage) {
                    document.querySelectorAll('.auto-stroke-overlay').forEach(el => el.remove());
                    referenceImage.remove(); referenceImage = null; imageMask.innerHTML = '';
                    if (traceLockCheckbox.checked) {
                        traceLockCheckbox.checked = false;
                        if (maskedStrokesLayer) maskedStrokesLayer.removeAttribute('mask');
                        else drawingLayer.removeAttribute('mask');
                    }
                    imageTools.classList.add('hidden'); imageUpload.value = null;
                    pinnedImageStates.tracingImage = null;
                    if (activeImageType === 'tracingImage') activeImageType = null;
                    updatePinButtonState();

                    // Disable Ref Mode when main image is deleted
                    if (refModeEnabled) {
                        refModeToggle.checked = false;
                        disableRefMode();
                    }

                    if (tempColorImageHref) {
                        handleDeleteTempImage();
                    }

                    // Clear cache when image changes
                    clearCache('wand');
                    clearCache('fills');
                    clearCache('imageMasks');

                    if (addToHistory) { addHistoryState(); }
                }
            }
            function handleSvgImport(e) {
                const file = e.target.files[0];
                if (!file) return;

                loader.classList.remove('hidden');
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const svgText = event.target.result;

                        // Check cache first
                        let svgDoc = getSvgParseFromCache(svgText);
                        if (!svgDoc) {
                            // Parse and cache
                            const parser = new DOMParser();
                            svgDoc = parser.parseFromString(svgText, "image/svg+xml");
                            saveSvgParseToCache(svgText, svgDoc);
                        }

                        // Check for parsing errors
                        const parserError = svgDoc.querySelector('parsererror');
                        if (parserError) {
                            console.error('SVG parsing error:', parserError.textContent);
                            showToast('Error parsing SVG file.', true);
                            loader.classList.add('hidden');
                            svgUpload.value = '';
                            return;
                        }

                        const importedSvg = svgDoc.querySelector('svg');
                        if (!importedSvg) {
                            showToast('No SVG element found in file.', true);
                            loader.classList.add('hidden');
                            svgUpload.value = '';
                            return;
                        }

                        // Import defs (filters, masks, clipPaths, etc.)
                        const importedDefs = importedSvg.querySelector('defs');
                        if (importedDefs) {
                            // Clone all defs elements and add to our defs
                            const defsToImport = importedDefs.querySelectorAll('*');
                            defsToImport.forEach(defElement => {
                                // Check if element with same ID already exists
                                const existingId = defElement.getAttribute('id');
                                if (existingId && defs.querySelector(`#${existingId}`)) {
                                    // ID conflict - generate new unique ID
                                    const newId = `${existingId}-imported-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                    defElement.setAttribute('id', newId);

                                    // Update any references to the old ID in the imported SVG
                                    const allElements = svgDoc.querySelectorAll('*');
                                    allElements.forEach(el => {
                                        Array.from(el.attributes).forEach(attr => {
                                            if (attr.value && attr.value.includes(`url(#${existingId})`)) {
                                                el.setAttribute(attr.name, attr.value.replace(`url(#${existingId})`, `url(#${newId})`));
                                            }
                                        });
                                    });
                                }
                                defs.appendChild(defElement.cloneNode(true));
                            });
                        }

                        // Import reference image if it exists
                        const backgroundImageLayer = importedSvg.querySelector('#background-image-layer image');
                        if (backgroundImageLayer && !referenceImage) {
                            const imgHref = backgroundImageLayer.getAttribute('href') || backgroundImageLayer.getAttribute('xlink:href');
                            if (imgHref) {
                                const imgWidth = parseFloat(backgroundImageLayer.getAttribute('width') || '0');
                                const imgHeight = parseFloat(backgroundImageLayer.getAttribute('height') || '0');
                                const imgX = parseFloat(backgroundImageLayer.getAttribute('x') || '0');
                                const imgY = parseFloat(backgroundImageLayer.getAttribute('y') || '0');

                                if (imgWidth > 0 && imgHeight > 0) {
                                    referenceImage = createSvgElement('image', {
                                        href: imgHref,
                                        width: imgWidth,
                                        height: imgHeight,
                                        x: imgX,
                                        y: imgY,
                                        opacity: opacitySlider.value,
                                        id: 'reference-image'
                                    });
                                    referenceImage.crossOrigin = "anonymous";
                                    // Insert referenceImage before refModeImage (main image should be below ref overlay)
                                    const insertBefore = refModeImage || drawingLayer;
                                    svgCanvas.insertBefore(referenceImage, insertBefore);
                                    imageTools.classList.remove('hidden');
                                }
                            }
                        }

                        // Get the drawing layer from imported SVG (or use the main SVG if no layer found)
                        let importedDrawingLayer = importedSvg.querySelector('#drawing-layer');
                        if (!importedDrawingLayer) {
                            // Look for paths in groups or directly in SVG
                            importedDrawingLayer = importedSvg;
                        }

                        // Import all paths (both strokes and fills)
                        const importedPaths = importedDrawingLayer.querySelectorAll('path');
                        let importedCount = 0;
                        importedSvgPaths = []; // Reset imported paths tracking

                        importedPaths.forEach(p => {
                            const pathData = p.getAttribute('d');
                            if (!pathData) return; // Skip paths without data

                            // Create new path element
                            const newPath = createSvgElement('path');

                            // Copy all attributes from the imported path
                            Array.from(p.attributes).forEach(attr => {
                                // Skip data-temp-stroke as we don't want to import temp strokes
                                if (attr.name === 'data-temp-stroke') return;

                                // Handle namespace attributes (xlink:href -> href)
                                if (attr.name.startsWith('xlink:')) {
                                    const newName = attr.name.replace('xlink:', '');
                                    newPath.setAttribute(newName, attr.value);
                                } else {
                                    newPath.setAttribute(attr.name, attr.value);
                                }
                            });

                            // Mark as imported SVG path
                            newPath.setAttribute('data-imported-svg', 'true');

                            // Ensure required attributes have defaults if missing
                            if (!newPath.getAttribute('fill') && !newPath.getAttribute('stroke')) {
                                // If neither fill nor stroke, check if it's a fill path
                                const fill = p.getAttribute('fill');
                                if (fill && fill !== 'none') {
                                    newPath.setAttribute('fill', fill);
                                } else {
                                    // Default to stroke if no fill
                                    newPath.setAttribute('stroke', p.getAttribute('stroke') || '#000000');
                                    newPath.setAttribute('stroke-width', p.getAttribute('stroke-width') || '2');
                                    newPath.setAttribute('fill', 'none');
                                }
                            }

                            // Update filter/clip-path references if IDs were changed
                            const filterAttr = newPath.getAttribute('filter');
                            if (filterAttr && filterAttr.includes('url(#')) {
                                // Filter reference should already be updated, but double-check
                                const filterId = filterAttr.match(/url\(#([^)]+)\)/);
                                if (filterId && !defs.querySelector(`#${filterId[1]}`)) {
                                    // Filter not found, remove the reference
                                    newPath.removeAttribute('filter');
                                }
                            }

                            const clipPathAttr = newPath.getAttribute('clip-path');
                            if (clipPathAttr && clipPathAttr.includes('url(#')) {
                                const clipPathId = clipPathAttr.match(/url\(#([^)]+)\)/);
                                if (clipPathId && !defs.querySelector(`#${clipPathId[1]}`)) {
                                    newPath.removeAttribute('clip-path');
                                }
                            }

                            // Import groups if path is in a group with mask
                            const parentGroup = p.parentElement;
                            if (parentGroup && parentGroup.tagName === 'g' && parentGroup.getAttribute('mask')) {
                                // Create a new group with the mask
                                const maskAttr = parentGroup.getAttribute('mask');
                                const newGroup = createSvgElement('g');
                                newGroup.setAttribute('mask', maskAttr);
                                newGroup.setAttribute('data-imported-svg-group', 'true');
                                newGroup.appendChild(newPath);
                                // For imported masked groups, we'll keep them in drawingLayer 
                                // but before maskedStrokesLayer if possible
                                if (maskedStrokesLayer) {
                                    drawingLayer.insertBefore(newGroup, maskedStrokesLayer);
                                } else {
                                    drawingLayer.appendChild(newGroup);
                                }
                                importedSvgPaths.push(newGroup); // Track the group
                            } else {
                                // Check if it's a fill path
                                const fill = newPath.getAttribute('fill');
                                const stroke = newPath.getAttribute('stroke');
                                const isFillPath = fill && fill !== 'none' && (!stroke || stroke === 'none');

                                if (isFillPath && maskedStrokesLayer) {
                                    drawingLayer.insertBefore(newPath, maskedStrokesLayer);
                                } else if (maskedStrokesLayer) {
                                    maskedStrokesLayer.appendChild(newPath);
                                } else {
                                    drawingLayer.appendChild(newPath);
                                }
                                importedSvgPaths.push(newPath); // Track the path
                            }

                            importedCount++;
                        });

                        // Also import any groups that contain paths (for masked fills)
                        const importedGroups = importedDrawingLayer.querySelectorAll('g[mask]');
                        importedGroups.forEach(g => {
                            const groupPaths = g.querySelectorAll('path');
                            if (groupPaths.length > 0) {
                                const maskAttr = g.getAttribute('mask');
                                const maskId = maskAttr.match(/url\(#([^)]+)\)/);
                                if (maskId && defs.querySelector(`#${maskId[1]}`)) {
                                    // Mask exists, create group
                                    const newGroup = createSvgElement('g');
                                    newGroup.setAttribute('mask', maskAttr);

                                    groupPaths.forEach(p => {
                                        const pathData = p.getAttribute('d');
                                        if (!pathData) return;

                                        const newPath = createSvgElement('path');
                                        Array.from(p.attributes).forEach(attr => {
                                            if (attr.name.startsWith('xlink:')) {
                                                newPath.setAttribute(attr.name.replace('xlink:', ''), attr.value);
                                            } else {
                                                newPath.setAttribute(attr.name, attr.value);
                                            }
                                        });
                                        newGroup.appendChild(newPath);
                                    });

                                    drawingLayer.appendChild(newGroup);
                                }
                            }
                        });

                        // Update viewBox if imported SVG has one and it's different
                        const importedViewBox = importedSvg.getAttribute('viewBox');
                        if (importedViewBox) {
                            const [x, y, w, h] = importedViewBox.split(/\s+/).map(parseFloat);
                            if (!isNaN(x) && !isNaN(y) && !isNaN(w) && !isNaN(h)) {
                                // Optionally adjust viewBox - for now, we'll keep the current one
                                // but could add option to use imported viewBox
                            }
                        }

                        addHistoryState('drawing');
                        loader.classList.add('hidden');
                        showToast(`Imported ${importedCount} path(s) from SVG.`, false);

                        // Show delete imported SVG button if paths were imported
                        if (importedCount > 0 && deleteImportedSvgBtn) {
                            deleteImportedSvgBtn.classList.remove('hidden');
                        }

                        svgUpload.value = '';

                    } catch (error) {
                        console.error('Error importing SVG:', error);
                        showToast('Error importing SVG file.', true);
                        loader.classList.add('hidden');
                        svgUpload.value = '';
                    }
                };
                reader.onerror = () => {
                    showToast('Error reading SVG file.', true);
                    loader.classList.add('hidden');
                    svgUpload.value = '';
                };
                reader.readAsText(file);
            }

            // --- PATH DRAWING & SIMPLIFICATION ---
            function simplifyPath(points, tolerance) {
                // Cache key for path simplification
                if (points.length <= 2) return points;
                const cacheKey = `${points.length}_${tolerance}_${points[0].x}_${points[0].y}_${points[points.length - 1].x}_${points[points.length - 1].y}`;
                if (CACHE.pathSimplified[cacheKey]) {
                    return CACHE.pathSimplified[cacheKey];
                }

                const sqTolerance = tolerance * tolerance;

                // Use a stack to avoid recursion (Iterative Ramer-Douglas-Peucker)
                const stack = [0, points.length - 1];
                const keepIndex = new Set();
                keepIndex.add(0);
                keepIndex.add(points.length - 1);

                while (stack.length > 0) {
                    const end = stack.pop();
                    const start = stack.pop();

                    let maxDistSq = 0;
                    let index = -1;

                    const pStart = points[start];
                    const pEnd = points[end];
                    const dx = pEnd.x - pStart.x;
                    const dy = pEnd.y - pStart.y;
                    const lineLenSq = dx * dx + dy * dy;

                    for (let i = start + 1; i < end; i++) {
                        const p = points[i];
                        let dSq;

                        if (lineLenSq === 0) {
                            dSq = (p.x - pStart.x) ** 2 + (p.y - pStart.y) ** 2;
                        } else {
                            let t = ((p.x - pStart.x) * dx + (p.y - pStart.y) * dy) / lineLenSq;
                            if (t < 0) t = 0;
                            else if (t > 1) t = 1;

                            const closestX = pStart.x + t * dx;
                            const closestY = pStart.y + t * dy;
                            dSq = (p.x - closestX) ** 2 + (p.y - closestY) ** 2;
                        }

                        if (dSq > maxDistSq) {
                            maxDistSq = dSq;
                            index = i;
                        }
                    }

                    if (maxDistSq > sqTolerance) {
                        keepIndex.add(index);
                        stack.push(start, index);
                        stack.push(index, end);
                    }
                }

                const result = [];
                for (let i = 0; i < points.length; i++) {
                    if (keepIndex.has(i)) {
                        result.push(points[i]);
                    }
                }

                // Cache result with stricter limit
                if (Object.keys(CACHE.pathSimplified).length < SmartMemory.maxPathCacheEntries) {
                    CACHE.pathSimplified[cacheKey] = result;
                } else {
                    // Evict oldest entries if cache is full
                    SmartMemory.trimPathCache(CACHE.pathSimplified);
                    // Try again after cleanup
                    if (Object.keys(CACHE.pathSimplified).length < SmartMemory.maxPathCacheEntries) {
                        CACHE.pathSimplified[cacheKey] = result;
                    }
                }
                return result;
            }
            function simplifyToFixedNodes(points, count) { if (count < 2 || points.length < 2) return [points[0], points[points.length - 1]]; let totalLength = 0; const segmentLengths = []; for (let i = 1; i < points.length; i++) { const dist = getDistance(points[i - 1], points[i]); segmentLengths.push(dist); totalLength += dist; } const newPoints = [points[0]]; const interval = totalLength / (count - 1); let accumulatedLength = 0; let targetLength = interval; let segmentIndex = 0; while (targetLength < totalLength && newPoints.length < count - 1) { while (accumulatedLength + segmentLengths[segmentIndex] < targetLength) { accumulatedLength += segmentLengths[segmentIndex]; segmentIndex++; } const remaining = targetLength - accumulatedLength; const ratio = segmentLengths[segmentIndex] === 0 ? 0 : remaining / segmentLengths[segmentIndex]; const p1 = points[segmentIndex]; const p2 = points[segmentIndex + 1]; const newX = p1.x + (p2.x - p1.x) * ratio; const newY = p1.y + (p2.y - p1.y) * ratio; newPoints.push({ x: newX, y: newY }); targetLength += interval; } newPoints.push(points[points.length - 1]); return newPoints; }
            function perpendicularDistance(point, lineStart, lineEnd) { let dx = lineEnd.x - lineStart.x, dy = lineEnd.y - lineStart.y; if (dx === 0 && dy === 0) return Math.hypot(point.x - lineStart.x, point.y - lineStart.y); const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (dx * dx + dy * dy); let closestPoint; if (t < 0) closestPoint = lineStart; else if (t > 1) closestPoint = lineEnd; else closestPoint = { x: lineStart.x + t * dx, y: lineStart.y + t * dy }; return Math.hypot(point.x - closestPoint.x, point.y - closestPoint.y); }
            function generateSmoothPath(pathPoints) {
                if (!pathPoints || pathPoints.length < 1) return "";
                if (pathPoints.length < 2) return `M${pathPoints[0].x},${pathPoints[0].y}`;
                if (pathPoints.length === 2) return `M${pathPoints[0].x},${pathPoints[0].y} L${pathPoints[1].x},${pathPoints[1].y}`;

                // Advanced Catmull-Rom spline interpolation for perfectly smooth curves
                // LITE VERSION: Optimized for performance and small file size
                let pathData = `M${pathPoints[0].x},${pathPoints[0].y}`;

                // Helper function to calculate Catmull-Rom control points
                const getCatmullRomPoint = (p0, p1, p2, p3, t) => {
                    const t2 = t * t;
                    const t3 = t2 * t;

                    return {
                        x: 0.5 * ((2 * p1.x) +
                            (-p0.x + p2.x) * t +
                            (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                            (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                        y: 0.5 * ((2 * p1.y) +
                            (-p0.y + p2.y) * t +
                            (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                            (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)
                    };
                };

                // Adaptive segment resolution based on point distance for optimal quality
                // OPTIMIZED for LITE PATHS: Reduced segment counts significantly
                const getAdaptiveSegments = (p1, p2) => {
                    const distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    // drastically reduced segments for lighter paths
                    if (distance > 200) return 15; // Was 50
                    if (distance > 100) return 10; // Was 40
                    if (distance > 50) return 8;   // Was 30
                    if (distance > 20) return 5;   // Was 20
                    if (distance > 10) return 4;   // Was 15
                    return 2;                      // Was 10
                };

                // Generate smooth curve through all points with adaptive resolution
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const p0 = pathPoints[Math.max(0, i - 1)];
                    const p1 = pathPoints[i];
                    const p2 = pathPoints[i + 1];
                    const p3 = pathPoints[Math.min(pathPoints.length - 1, i + 2)];

                    const segments = getAdaptiveSegments(p1, p2);

                    // Add curve segment
                    for (let t = 0; t <= 1; t += 1 / segments) {
                        const point = getCatmullRomPoint(p0, p1, p2, p3, t);
                        if (t > 0) { // Skip the first point to avoid duplicates
                            // Round to 1 decimal place to save space (Lite)
                            pathData += ` L${Math.round(point.x * 10) / 10},${Math.round(point.y * 10) / 10}`;
                        }
                    }
                }

                return pathData;
            }

            function generateLinearPath(pathPoints) {
                if (!pathPoints || pathPoints.length < 1) return "";
                // Optimization: Round to 1 decimal place to reduce SVG path string size
                const r = (n) => Math.round(n * 10) / 10;

                let pathData = `M${r(pathPoints[0].x)},${r(pathPoints[0].y)}`;
                for (let i = 1; i < pathPoints.length; i++) {
                    pathData += ` L${r(pathPoints[i].x)},${r(pathPoints[i].y)}`;
                }
                return pathData;
            }

            function generateSmoothPathWithPenLifts(points, jumpThreshold) {
                if (!points || points.length < 2) return generateLinearPath(points);
                const r = (n) => Math.round(n * 10) / 10;
                let pathData = `M${r(points[0].x)},${r(points[0].y)}`;
                for (let i = 1; i < points.length; i++) {
                    const p1 = points[i - 1];
                    const p2 = points[i];
                    const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    if (dist > jumpThreshold) {
                        pathData += ` M${r(p2.x)},${r(p2.y)}`;
                    } else {
                        pathData += ` L${r(p2.x)},${r(p2.y)}`;
                    }
                }
                return pathData;
            }

            function catmullRomResample(points, interval) {
                if (points.length < 2) return points;
                const resampled = [points[0]];
                let lastP = points[0];
                let acc = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = points[Math.max(0, i - 1)], p1 = points[i], p2 = points[i + 1], p3 = points[Math.min(points.length - 1, i + 2)];
                    const d = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    if (d < 0.1) continue;
                    const steps = Math.max(1, Math.ceil(d / (interval * 0.5)));
                    for (let j = 1; j <= steps; j++) {
                        const t = j / steps, t2 = t * t, t3 = t2 * t;
                        const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3);
                        const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
                        const p = { x, y };
                        const seg = Math.hypot(p.x - lastP.x, p.y - lastP.y);
                        acc += seg;
                        if (acc >= interval) { resampled.push(p); acc = 0; }
                        lastP = p;
                    }
                }
                if (resampled.length < 2) resampled.push(points[points.length - 1]);
                return resampled;
            }

            // --- MAGIC WAND FUNCTIONS ---
            // Improved color difference calculation for better precision
            // Uses weighted RGB distance that better matches human perception
            function colorDifference(c1, c2) {
                const r = c1[0] - c2[0];
                const g = c1[1] - c2[1];
                const b = c1[2] - c2[2];
                // Use weighted Euclidean distance (human eye is more sensitive to green)
                // This provides more accurate color matching
                return Math.sqrt(2 * r * r + 4 * g * g + 3 * b * b);
            }

            // Precise color difference using Delta E (CIE76) in LAB space
            // This matches human perception much better than RGB distance
            function preciseColorDifference(c1, c2) {
                // Optimization: Quick RGB Manhattan check first
                // If the sum of absolute differences is very large, LAB difference will certainly be large
                const dr = Math.abs(c1[0] - c2[0]);
                const dg = Math.abs(c1[1] - c2[1]);
                const db = Math.abs(c1[2] - c2[2]);

                // If Manhattan distance > 120, return a large value to skip expensive LAB conversion
                if (dr + dg + db > 120) return 1000;

                // Convert RGB to LAB color space for perceptual accuracy
                const lab1 = rgbToLab(c1[0], c1[1], c1[2]);
                const lab2 = rgbToLab(c2[0], c2[1], c2[2]);

                // Calculate Delta E (CIE76) - Euclidean distance in LAB space
                const dL = lab1[0] - lab2[0];
                const dAut = lab1[1] - lab2[1];
                const dBut = lab1[2] - lab2[2];

                return Math.sqrt(dL * dL + dAut * dAut + dBut * dBut);
            }

            // Check if a pixel is a black/dark boundary (outline)
            // Uses luminance and edge detection for unclear images
            function isBlackBoundary(data, idx, width, height, threshold = 45) {
                const colorIdx = idx * 4;
                const a = data[colorIdx + 3];

                // Must be opaque
                if (a < 128) return false;

                const r = data[colorIdx];
                const g = data[colorIdx + 1];
                const b = data[colorIdx + 2];

                // Calculate luminance (perceived brightness)
                const luminance1000 = r * 299 + g * 587 + b * 114;
                const threshold1000 = threshold * 1000;

                // Base check: Extremely dark pixels (true blacks) are always boundaries
                if (luminance1000 <= 30000) { // Luma < 30
                    return true;
                }

                const x = idx % width;
                const y = (idx / width) | 0;

                // Secondary check: Dark pixels that are also edges
                // This allows catching dark colored outlines (brown, blue, etc.) without catching flat dark fills
                if (luminance1000 <= 120000) { // Up to Luma 120 (mid-dark)
                    if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                        const nIndices = [idx - width, idx - 1, idx + 1, idx + width];
                        let maxGradient = 0;
                        const currentLuma = luminance1000;

                        for (let i = 0; i < 4; i++) {
                            const nIdx = nIndices[i];
                            const nColorIdx = nIdx * 4;
                            const nLuma = data[nColorIdx] * 299 + data[nColorIdx + 1] * 587 + data[nColorIdx + 2] * 114;
                            const gradient = Math.abs(currentLuma - nLuma);
                            if (gradient > maxGradient) maxGradient = gradient;
                        }

                        // Strong contrast transition indicates a boundary line rather than a flat fill
                        // Adaptive threshold for gradient: darker pixels need less gradient to be boundaries
                        const gradientThreshold = (luminance1000 < 60000) ? 50000 : 90000;
                        if (maxGradient > gradientThreshold) {
                            return true;
                        }

                        // Local minimum check: is this pixel darker than its neighbors? (Ridge detection)
                        let isLocalMinimum = true;
                        for (let i = 0; i < 4; i++) {
                            const nIdx = nIndices[i];
                            const nLuma = data[nIdx * 4] * 299 + data[nIdx * 4 + 1] * 587 + data[nIdx * 4 + 2] * 114;
                            if (nLuma < currentLuma - 2000) { // If any neighbor is significantly darker, this isn't the core boundary
                                isLocalMinimum = false;
                                break;
                            }
                        }
                        if (isLocalMinimum && luminance1000 < threshold1000 + 15000) {
                            return true;
                        }
                    }
                }
                return false;
            }

            // OPTIMIZATION: Pre-compute sRGB to Linear RGB lookup table for performance
            const sRGB_Linear_LUT = new Float32Array(256);
            for (let i = 0; i < 256; i++) {
                const v = i / 255;
                sRGB_Linear_LUT[i] = v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
            }

            // Convert RGB to LAB color space (Optimized)
            function rgbToLab(r, g, b) {
                // Use LUT for Linear RGB conversion
                const rLin = sRGB_Linear_LUT[r];
                const gLin = sRGB_Linear_LUT[g];
                const bLin = sRGB_Linear_LUT[b];

                // Convert to XYZ (using D65 illuminant)
                let x = (rLin * 0.4124564 + gLin * 0.3575761 + bLin * 0.1804375) / 0.95047;
                let y = (rLin * 0.2126729 + gLin * 0.7151522 + bLin * 0.0721750);
                let z = (rLin * 0.0193339 + gLin * 0.1191920 + bLin * 0.9503041) / 1.08883;

                // Convert to LAB
                // Optimization: Pre-calculate threshold and coefficients
                const epsilon = 0.008856;
                const kappa = 903.3;

                const fx = x > epsilon ? Math.cbrt(x) : (kappa * x + 16) / 116;
                const fy = y > epsilon ? Math.cbrt(y) : (kappa * y + 16) / 116;
                const fz = z > epsilon ? Math.cbrt(z) : (kappa * z + 16) / 116;

                const L = (116 * fy) - 16;
                const A = 500 * (fx - fy);
                const B = 200 * (fy - fz);

                return [L, A, B];
            }
            // Shrink/erode the selection mask by removing pixels at the edges
            function shrinkSelectionMask(mask, width, height, shrinkAmount) {
                if (!mask) return mask;
                if (shrinkAmount === 0) return mask;

                let currentMask = new Uint8Array(mask); // Copy input
                let nextMask = new Uint8Array(mask.length);

                if (shrinkAmount > 0) {
                    // Shrink (erosion): Remove pixels at the edges
                    for (let i = 0; i < shrinkAmount; i++) {
                        // Clear next mask
                        nextMask.fill(0);

                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const idx = y * width + x;
                                if (currentMask[idx] === 1) {
                                    // Check neighbors inline to avoid array allocation
                                    let keep = true;
                                    // Up
                                    if (y > 0 && currentMask[idx - width] !== 1) keep = false;
                                    // Down
                                    else if (y < height - 1 && currentMask[idx + width] !== 1) keep = false;
                                    // Left
                                    else if (x > 0 && currentMask[idx - 1] !== 1) keep = false;
                                    // Right
                                    else if (x < width - 1 && currentMask[idx + 1] !== 1) keep = false;
                                    // Edges are removed
                                    else if (x === 0 || x === width - 1 || y === 0 || y === height - 1) keep = false;

                                    if (keep) nextMask[idx] = 1;
                                }
                            }
                        }
                        // Swap buffers
                        const temp = currentMask;
                        currentMask = nextMask;
                        nextMask = temp;
                    }
                } else {
                    // Expand (dilation): Add pixels at the edges
                    const expandAmount = Math.abs(shrinkAmount);
                    for (let i = 0; i < expandAmount; i++) {
                        // Initialize next mask with current mask (additive)
                        nextMask.set(currentMask);

                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                const idx = y * width + x;
                                if (currentMask[idx] === 1) {
                                    // Expand to neighbors inline
                                    if (y > 0) nextMask[idx - width] = 1;
                                    if (y < height - 1) nextMask[idx + width] = 1;
                                    if (x > 0) nextMask[idx - 1] = 1;
                                    if (x < width - 1) nextMask[idx + 1] = 1;
                                }
                            }
                        }
                        // Swap buffers
                        const temp = currentMask;
                        currentMask = nextMask;
                        nextMask = temp;
                    }
                }

                return currentMask;
            }

            // --- NEW: Connected Component Labeling for Stroke Merge Control ---
            // Cache for connected component labels per selection
            let selectionComponentLabels = null;
            let selectionComponentCount = 0;

            // Compute connected components using flood fill (4-connectivity)
            function computeSelectionComponents(mask, width, height) {
                if (!mask) return null;

                const labels = new Int32Array(mask.length);
                labels.fill(-1); // -1 means unvisited/not in selection

                let currentLabel = 0;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        if (mask[idx] === 1 && labels[idx] === -1) {
                            // Found unvisited selected pixel - flood fill with current label
                            floodFillComponent(mask, labels, width, height, x, y, currentLabel);
                            currentLabel++;
                        }
                    }
                }

                return { labels, count: currentLabel };
            }

            function floodFillComponent(mask, labels, width, height, startX, startY, label) {
                const stack = [[startX, startY]];

                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const idx = y * width + x;

                    // Skip if out of bounds, not selected, or already labeled
                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    if (mask[idx] !== 1) continue;
                    if (labels[idx] !== -1) continue;

                    // Label this pixel
                    labels[idx] = label;

                    // Add 4-connected neighbors
                    stack.push([x - 1, y]); // left
                    stack.push([x + 1, y]); // right
                    stack.push([x, y - 1]); // up
                    stack.push([x, y + 1]); // down
                }
            }

            // ============================================
            // CLOSED SHAPE DETECTION & VALIDATION
            // Real-time detection of valid closed SVG paths
            // ============================================

            /**
             * Detect if a clicked point is within a closed SVG shape
             * Returns true if the path ends with Z/z (closed path)
             */
            function isClosedSVGPath(svgElement) {
                if (!svgElement) return false;

                const tagName = svgElement.tagName.toLowerCase();
                if (tagName === 'path') {
                    const pathData = svgElement.getAttribute('d');
                    if (!pathData) return false;
                    // Check if path ends with Z or z (closed path indicator)
                    const trimmed = pathData.trim();
                    return /[Zz]\s*$/.test(trimmed);
                } else if (['circle', 'ellipse', 'rect', 'polygon', 'polyline'].includes(tagName)) {
                    // Circles, ellipses, and rects are always closed
                    return true;
                }
                return false;
            }

            /**
             * Validate if a point is inside a closed shape using SVG geometry
             * Uses isPointInPath() for precise geometry checking
             */
            function validatePointInPath(x, y, svgElement) {
                if (!svgElement) return false;

                try {
                    // Get the SVG element's bounding box and transform matrix
                    const bbox = svgElement.getBBox();
                    const matrix = svgElement.getScreenCTM();

                    if (!bbox || !matrix) return false;

                    // For path elements, use the native SVG isPointInPath if available
                    if (svgElement.tagName.toLowerCase() === 'path') {
                        // Create a temporary canvas context for isPointInPath
                        const canvas = document.createElement('canvas');
                        canvas.width = 1;
                        canvas.height = 1;
                        const ctx = canvas.getContext('2d');

                        // Try to use SVG's native point-in-path detection
                        if (typeof SVGGeometryElement !== 'undefined' && svgElement instanceof SVGGeometryElement) {
                            // Transform the point to SVG coordinate space
                            const pt = antsCanvas.createSVGPoint();
                            pt.x = x;
                            pt.y = y;
                            const transformedPt = pt.matrixTransform(matrix.inverse());
                            return svgElement.isPointInPath(transformedPt.x, transformedPt.y);
                        }
                    }

                    // Fallback: Check if point is within bounding box
                    const transformedPoint = antsCanvas.createSVGPoint();
                    transformedPoint.x = x;
                    transformedPoint.y = y;
                    const inversePt = transformedPoint.matrixTransform(matrix.inverse());

                    return inversePt.x >= bbox.x && inversePt.x <= bbox.x + bbox.width &&
                        inversePt.y >= bbox.y && inversePt.y <= bbox.y + bbox.height;
                } catch (e) {
                    console.warn('Point validation failed:', e);
                    return false;
                }
            }

            /**
             * Generate zoom-independent invisible coverage boxes for a closed shape
             * Works directly in SVG coordinate space (not affected by canvas zoom)
             */
            function generateZoomIndependentBoxes(mask, width, height, viewBox, strokeWidth) {
                if (!mask || !viewBox || !width || !height) return [];

                // Calculate scale factors from canvas to SVG coordinate space
                const scaleX = viewBox.w / width;
                const scaleY = viewBox.h / height;

                // Find bounds in pixel space
                let minX = width, minY = height, maxX = -1, maxY = -1;
                for (let i = 0; i < mask.length; i++) {
                    if (mask[i] === 1) {
                        const x = i % width;
                        const y = (i / width) | 0;
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }

                if (maxX < 0) return [];

                // Convert bounds to SVG coordinate space
                const svgMinX = viewBox.x + (minX * scaleX);
                const svgMinY = viewBox.y + (minY * scaleY);
                const svgMaxX = viewBox.x + (maxX * scaleX);
                const svgMaxY = viewBox.y + (maxY * scaleY);

                const svgWidth = svgMaxX - svgMinX;
                const svgHeight = svgMaxY - svgMinY;

                // Create 3x3 grid of boxes that cover the shape
                const boxes = [];
                const boxWidth = svgWidth / 3;
                const boxHeight = svgHeight / 3;

                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        const x = svgMinX + (col * boxWidth);
                        const y = svgMinY + (row * boxHeight);
                        boxes.push({
                            x: x,
                            y: y,
                            w: boxWidth,
                            h: boxHeight,
                            row: row,
                            col: col,
                            id: `box-${row}-${col}`
                        });
                    }
                }

                return boxes;
            }

            /**
             * Validate coverage boxes using isPointInPath
             * Ensures boxes stay inside the shape without gaps or overlaps
             */
            function validateCoverageBoxes(boxes, mask, width, height) {
                if (!boxes || !mask) return boxes;

                const validatedBoxes = [];

                for (const box of boxes) {
                    // Sample points within the box to check if they're in the mask
                    const samples = [];
                    const sampleCount = 5; // 5x5 grid of sample points

                    for (let si = 0; si < sampleCount; si++) {
                        for (let sj = 0; sj < sampleCount; sj++) {
                            const fx = si / (sampleCount - 1);
                            const fy = sj / (sampleCount - 1);
                            const px = Math.round(box.x + (fx * box.w));
                            const py = Math.round(box.y + (fy * box.h));

                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                samples.push(mask[py * width + px] === 1);
                            }
                        }
                    }

                    // If majority of samples are in the mask, keep the box
                    const inMaskCount = samples.filter(s => s).length;
                    if (inMaskCount / samples.length > 0.5) {
                        validatedBoxes.push(box);
                    }
                }

                return validatedBoxes;
            }

            // ============================================
            // SMART SNAKE FILLER ENGINE (Virtual Artist v4)
            // "Smart Snake"  Fixed Pen Size + Continuous Path
            // Zig-zag raster fill with directional variety
            // Zoom-Independent + isPointInPath Validation
            // ============================================

            /**
             * SmartSnakeFiller  "Smart Snake" Engine
             * RULES:
             *  1. NEVER change stroke width. Uses the user's currentStrokeWidth.
             *  2. Single continuous path: Outline  Zone 1  Zone 2    Zone 9.
             *  3. 3x3 "Invisible Box" grid for mapping, 10x10 micro-grid sensors per zone.
             *  4. Directional variety per zone (horizontal, vertical, diagonal zig-zag).
             *  5. stepSize = strokeWidth * 0.99 (1% overlap, 99% white area).
             *  6. Boundary Protection: fill path inset by strokeWidth/2 from edges.
             *  7. Big Box Splitting: wide zones split into left/right sub-sections.
             *  8. S-Curve zone order: 123, 654, 789 (boustrophedon).
             *  9. Zoom Independence: All coordinates calculated in true SVG space.
             *  10. Coverage Validation: Using isPointInPath for geometry accuracy.
             */
            class SmartSnakeFiller {
                constructor(mask, width, height, strokeWidth, viewBox, zoomLevel) {
                    this.mask = mask;
                    this.width = width;
                    this.height = height;
                    // Zoom Independence: Store viewBox and zoom level
                    this.viewBox = viewBox || { x: 0, y: 0, w: width, h: height };
                    this.zoomLevel = zoomLevel || 1.0;

                    // FIXED pen size  never auto-changed
                    // Adjust stroke width based on zoom for visual consistency
                    this.baseStrokeWidth = Math.max(1, strokeWidth);
                    this.strokeWidth = this.baseStrokeWidth; // Use base width directly (zoom affects rendering, not fill pattern)

                    this.stepSize = this.strokeWidth * 0.99; // 1% micro-overlap: 99% white area coverage
                    // Boundary Protection: safety inset = half the pen width
                    this.safetyInset = Math.max(0, Math.floor(this.strokeWidth / 2));

                    // Pre-compute zoom-independent scale factors
                    this.scaleX = this.viewBox.w / width;
                    this.scaleY = this.viewBox.h / height;

                    this.insetMask = this._buildInsetMask();
                    this.bounds = this._computeBounds();
                    this.mainBox = this._computeMainBox();
                    this.zones = [];       // 9 zones (3x3)
                    this.microCells = [];   // 9 arrays of 100 cells each (10x10 sensors)
                    this._buildGrid();
                    // Pre-select a fill direction for each zone (variety)
                    this.zoneDirections = this._assignZoneDirections();
                    // Vertical Snake zone order: Col1 TB, Col2 BT, Col3 TB
                    // Pattern: 1,4,7  8,5,2  3,6,9 (0-based: 0,3,6  7,4,1  2,5,8)
                    this.zoneOrder = [0, 3, 6, 7, 4, 1, 2, 5, 8];
                }

                // --- ZOOM-INDEPENDENT COORDINATE CONVERSION ---
                toSvgX(pixelX) {
                    return this.viewBox.x + (pixelX * this.scaleX);
                }

                toSvgY(pixelY) {
                    return this.viewBox.y + (pixelY * this.scaleY);
                }

                toPixelX(svgX) {
                    return Math.round((svgX - this.viewBox.x) / this.scaleX);
                }

                toPixelY(svgY) {
                    return Math.round((svgY - this.viewBox.y) / this.scaleY);
                }

                // --- Layer 1: Bounding Box ---
                _computeBounds() {
                    let minX = this.width, minY = this.height, maxX = -1, maxY = -1;
                    for (let i = 0; i < this.mask.length; i++) {
                        if (this.mask[i] === 1) {
                            const x = i % this.width;
                            const y = (i / this.width) | 0;
                            if (x < minX) minX = x;
                            if (x > maxX) maxX = x;
                            if (y < minY) minY = y;
                            if (y > maxY) maxY = y;
                        }
                    }
                    if (maxX < 0) return null;
                    return { minX, minY, maxX, maxY };
                }

                _computeMainBox() {
                    if (!this.bounds) return null;
                    const bw = this.bounds.maxX - this.bounds.minX + 1;
                    const bh = this.bounds.maxY - this.bounds.minY + 1;
                    return {
                        x: this.bounds.minX,
                        y: this.bounds.minY,
                        w: bw,
                        h: bh
                    };
                }

                // --- Layer 2 & 3: 33 Zones, each with 1010 Micro Cells (sensors) ---
                _buildGrid() {
                    if (!this.mainBox) return;
                    const zoneW = this.mainBox.w / 3;
                    const zoneH = this.mainBox.h / 3;

                    for (let zr = 0; zr < 3; zr++) {
                        for (let zc = 0; zc < 3; zc++) {
                            const zoneIdx = zr * 3 + zc;
                            const zx = this.mainBox.x + zc * zoneW;
                            const zy = this.mainBox.y + zr * zoneH;
                            this.zones[zoneIdx] = { x: zx, y: zy, w: zoneW, h: zoneH };

                            const cells = [];
                            const cellW = zoneW / 10;
                            const cellH = zoneH / 10;
                            for (let cr = 0; cr < 10; cr++) {
                                for (let cc = 0; cc < 10; cc++) {
                                    const cx = zx + cc * cellW + cellW / 2;
                                    const cy = zy + cr * cellH + cellH / 2;
                                    const active = this._isCellActive(cx, cy, cellW, cellH);
                                    cells.push({
                                        row: cr, col: cc,
                                        cx, cy, w: cellW, h: cellH,
                                        active
                                    });
                                }
                            }
                            this.microCells[zoneIdx] = cells;
                        }
                    }
                }

                _isCellActive(cx, cy, cellW, cellH) {
                    const offsets = [
                        [0, 0], [-0.3, -0.3], [0.3, -0.3], [-0.3, 0.3], [0.3, 0.3],
                        [-0.15, 0], [0.15, 0], [0, -0.15], [0, 0.15]
                    ];
                    for (const [ox, oy] of offsets) {
                        const sx = Math.round(cx + ox * cellW);
                        const sy = Math.round(cy + oy * cellH);
                        if (sx >= 0 && sx < this.width && sy >= 0 && sy < this.height) {
                            if (this.mask[sy * this.width + sx] === 1) return true;
                        }
                    }
                    return false;
                }

                // --- Boundary Protection: eroded mask for fill paths ---
                _buildInsetMask() {
                    const inset = this.safetyInset;
                    if (inset <= 0) return this.mask; // no erosion needed
                    const w = this.width, h = this.height;
                    const eroded = new Uint8Array(w * h);
                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            if (this.mask[y * w + x] !== 1) continue;
                            // Check if all pixels within `inset` radius are also in mask
                            let safe = true;
                            for (let dy = -inset; dy <= inset && safe; dy++) {
                                for (let dx = -inset; dx <= inset && safe; dx++) {
                                    const nx = x + dx, ny = y + dy;
                                    if (nx < 0 || nx >= w || ny < 0 || ny >= h ||
                                        this.mask[ny * w + nx] !== 1) {
                                        safe = false;
                                    }
                                }
                            }
                            if (safe) eroded[y * w + x] = 1;
                        }
                    }
                    return eroded;
                }

                _isInMask(x, y) {
                    const ix = x | 0, iy = y | 0;
                    if (ix < 0 || ix >= this.width || iy < 0 || iy >= this.height) return false;
                    return this.mask[iy * this.width + ix] === 1;
                }

                // Fill path uses the inset (eroded) mask for boundary protection
                _isInSafeMask(x, y) {
                    const ix = x | 0, iy = y | 0;
                    if (ix < 0 || ix >= this.width || iy < 0 || iy >= this.height) return false;
                    return this.insetMask[iy * this.width + ix] === 1;
                }

                // --- Assign fill direction per zone (randomized for each shape) ---
                _assignZoneDirections() {
                    const dirs = ['horizontal', 'vertical', 'diagonal'];
                    const assignments = [];

                    // Randomly select fill direction for each zone
                    // This ensures different shapes have completely different stroke angles
                    for (let z = 0; z < 9; z++) {
                        // Random index: 0, 1, or 2
                        const pick = Math.floor(Math.random() * 3);
                        assignments.push(dirs[pick]);
                    }
                    return assignments;
                }

                // --- Detect if shape is "small" and should use inner outline strategy ---
                _isSmallShape() {
                    if (!this.bounds) return false;

                    // Count total pixels in the shape
                    let pixelCount = 0;
                    for (let i = 0; i < this.mask.length; i++) {
                        if (this.mask[i] === 1) pixelCount++;
                    }

                    // Size threshold: if pixel count is below (strokeWidth^2 * 12), treat as small
                    // This scales with pen size for consistency
                    const sizeThreshold = Math.max(200, Math.pow(this.strokeWidth, 2) * 12);
                    return pixelCount < sizeThreshold;
                }

                // --- Generate inner outline stroke (contour line tracing inside boundary) ---
                // Maintains the stroke grouping sequence: 1,4,7  2,5,8  3,6,9
                _generateInnerOutline() {
                    if (!this.bounds) return [];

                    const w = this.width, h = this.height;
                    const insetDist = Math.max(1, Math.floor(this.strokeWidth * 0.5));

                    // Build an erosion of the mask (inset boundary by strokeWidth/2)
                    const erodedMask = new Uint8Array(w * h);
                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            if (this.mask[y * w + x] !== 1) continue;

                            // Check if all pixels within inset distance are in mask
                            let safe = true;
                            for (let dy = -insetDist; dy <= insetDist && safe; dy++) {
                                for (let dx = -insetDist; dx <= insetDist && safe; dx++) {
                                    const nx = x + dx, ny = y + dy;
                                    if (nx < 0 || nx >= w || ny < 0 || ny >= h ||
                                        this.mask[ny * w + nx] !== 1) {
                                        safe = false;
                                    }
                                }
                            }
                            if (safe) erodedMask[y * w + x] = 1;
                        }
                    }

                    // Find the contour of the eroded mask (inner boundary)
                    const contourPx = [];
                    for (let y = this.bounds.minY; y <= this.bounds.maxY; y++) {
                        for (let x = this.bounds.minX; x <= this.bounds.maxX; x++) {
                            const idx = y * w + x;
                            if (erodedMask[idx] !== 1) continue;

                            // A point is on the contour if it has a non-eroded neighbor
                            let isContour = false;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = x + dx, ny = y + dy;
                                    if (nx < 0 || nx >= w || ny < 0 || ny >= h ||
                                        erodedMask[ny * w + nx] !== 1) {
                                        isContour = true;
                                        break;
                                    }
                                }
                                if (isContour) break;
                            }

                            if (isContour) contourPx.push({ x, y });
                        }
                    }

                    if (contourPx.length === 0) return [];

                    // Order contour points via nearest neighbor (chain them together)
                    const used = new Uint8Array(contourPx.length);
                    const ordered = [contourPx[0]];
                    used[0] = 1;

                    for (let n = 1; n < contourPx.length; n++) {
                        const last = ordered[ordered.length - 1];
                        let bestIdx = -1, bestDist = Infinity;

                        for (let j = 0; j < contourPx.length; j++) {
                            if (used[j]) continue;
                            const d = Math.abs(contourPx[j].x - last.x) + Math.abs(contourPx[j].y - last.y);
                            if (d < bestDist) { bestDist = d; bestIdx = j; }
                            if (d <= 1) break;
                        }

                        if (bestIdx < 0 || bestDist > 10) break;
                        used[bestIdx] = 1;
                        ordered.push(contourPx[bestIdx]);
                    }

                    // Close the loop
                    if (ordered.length > 3) ordered.push({ ...ordered[0] });

                    // Apply stroke grouping sequence while tracing the contour
                    // Pattern: 1,4,7  2,5,8  3,6,9 (maintaining original zone order logic)
                    const step = Math.max(1, Math.floor(this.strokeWidth * 0.3));
                    const sampled = [];

                    // Create grouped segments following the zone order pattern
                    const groupSequence = [
                        [0, 3, 6],  // Group 1: zones 1,4,7
                        [7, 4, 1],  // Group 2: zones 2,5,8 (reversed for S-curve)
                        [2, 5, 8]   // Group 3: zones 3,6,9
                    ];

                    // Distribute contour points across groups with pattern logic
                    const pointsPerGroup = Math.ceil(ordered.length / 3);

                    for (let g = 0; g < 3; g++) {
                        const startIdx = g * pointsPerGroup;
                        const endIdx = Math.min((g + 1) * pointsPerGroup, ordered.length);

                        for (let i = startIdx; i < endIdx; i += step) {
                            sampled.push(ordered[i]);
                        }

                        // Ensure final point of group is included
                        if (endIdx > startIdx && (endIdx - 1) % step !== 0) {
                            sampled.push(ordered[endIdx - 1]);
                        }
                    }

                    return sampled;
                }

                // --- Stage A: Perimeter Trace (shape outline) ---
                tracePerimeter() {
                    if (!this.bounds) return [];
                    const w = this.width, h = this.height, mask = this.mask;
                    const edgePx = [];
                    for (let y = this.bounds.minY; y <= this.bounds.maxY; y++) {
                        for (let x = this.bounds.minX; x <= this.bounds.maxX; x++) {
                            const idx = y * w + x;
                            if (mask[idx] !== 1) continue;
                            if (x === 0 || x === w - 1 || y === 0 || y === h - 1 ||
                                mask[idx - 1] === 0 || mask[idx + 1] === 0 ||
                                mask[idx - w] === 0 || mask[idx + w] === 0) {
                                edgePx.push({ x, y });
                            }
                        }
                    }
                    if (edgePx.length === 0) return [];

                    // Nearest-neighbor chain ordering
                    const used = new Uint8Array(edgePx.length);
                    const ordered = [edgePx[0]];
                    used[0] = 1;
                    for (let n = 1; n < edgePx.length; n++) {
                        const last = ordered[ordered.length - 1];
                        let bestIdx = -1, bestDist = Infinity;
                        for (let j = 0; j < edgePx.length; j++) {
                            if (used[j]) continue;
                            const d = Math.abs(edgePx[j].x - last.x) + Math.abs(edgePx[j].y - last.y);
                            if (d < bestDist) { bestDist = d; bestIdx = j; }
                            if (d <= 1) break;
                        }
                        if (bestIdx < 0 || bestDist > 5) break;
                        used[bestIdx] = 1;
                        ordered.push(edgePx[bestIdx]);
                    }
                    // Close the loop
                    if (ordered.length > 3) ordered.push({ ...ordered[0] });

                    // Subsample based on stroke width
                    const step = Math.max(1, Math.floor(this.strokeWidth * 0.4));
                    const sampled = [];
                    for (let i = 0; i < ordered.length; i += step) {
                        sampled.push(ordered[i]);
                    }
                    if (sampled.length > 1 && sampled[sampled.length - 1] !== ordered[ordered.length - 1]) {
                        sampled.push(ordered[ordered.length - 1]);
                    }
                    return sampled;
                }

                /**
                 * Raster-fill a rectangular sub-region clipped to the safe (inset) mask.
                 * Uses SHARP "Square Turn" U-turns at boundaries:
                 *   - Draw straight to the boundary edge (exact limit)
                 *   - Move vertically/horizontally along the edge to the next row
                 *   - Draw straight back into the shape
                 * No curves on turns  all lineTo for perfect corner coverage.
                 * ScanLimit = edge of safe mask (already inset by strokeWidth/2).
                 */
                _rasterFillRect(xMin, xMax, yMin, yMax, dir) {
                    // U-turn step multiplier: adjustable by user via settings slider
                    const step = (dir === 'diagonal') ? this.stepSize * 1.4142 * autoStrokeUturnMultiplier : this.stepSize * autoStrokeUturnMultiplier;
                    const pts = [];

                    if (dir === 'horizontal') {
                        // Collect all scan rows with their mask extents
                        const rows = [];
                        for (let y = yMin; y <= yMax; y += step) {
                            const iy = Math.round(y);
                            let left = -1, right = -1;
                            for (let x = xMin; x <= xMax; x++) {
                                if (this._isInSafeMask(x, iy)) {
                                    if (left < 0) left = x;
                                    right = x;
                                }
                            }
                            if (left >= 0) rows.push({ y: iy, left, right });
                        }

                        // Build sharp square-turn zig-zag path
                        for (let i = 0; i < rows.length; i++) {
                            const row = rows[i];
                            if (i % 2 === 0) {
                                // Left  Right: start at exact left edge, end at exact right edge
                                pts.push({ x: row.left, y: row.y });
                                pts.push({ x: row.right, y: row.y });
                            } else {
                                // Right  Left: start at exact right edge, end at exact left edge
                                pts.push({ x: row.right, y: row.y });
                                pts.push({ x: row.left, y: row.y });
                            }
                            // Square turn: next row starts where this row ended
                            // The vertical edge move is implicit by having the next push at
                            // the same X but different Y  a straight lineTo, no curve.
                        }
                    } else if (dir === 'vertical') {
                        // Collect all scan columns with their mask extents
                        const cols = [];
                        for (let x = xMin; x <= xMax; x += step) {
                            const ix = Math.round(x);
                            let top = -1, bottom = -1;
                            for (let y = yMin; y <= yMax; y++) {
                                if (this._isInSafeMask(ix, y)) {
                                    if (top < 0) top = y;
                                    bottom = y;
                                }
                            }
                            if (top >= 0) cols.push({ x: ix, top, bottom });
                        }

                        // Build sharp square-turn zig-zag path
                        for (let i = 0; i < cols.length; i++) {
                            const col = cols[i];
                            if (i % 2 === 0) {
                                // Top  Bottom
                                pts.push({ x: col.x, y: col.top });
                                pts.push({ x: col.x, y: col.bottom });
                            } else {
                                // Bottom  Top
                                pts.push({ x: col.x, y: col.bottom });
                                pts.push({ x: col.x, y: col.top });
                            }
                        }
                    } else {
                        // Diagonal 45  collect valid diagonal sweeps
                        const diagLen = (xMax - xMin) + (yMax - yMin);
                        const diags = [];
                        for (let d = 0; d <= diagLen; d += step) {
                            const startX = xMin + Math.max(0, d - (yMax - yMin));
                            const startY = yMin + Math.min(d, yMax - yMin);
                            // Find first and last valid points on this diagonal
                            let firstPt = null, lastPt = null;
                            let cx = startX, cy = startY;
                            while (cx <= xMax && cy >= yMin) {
                                if (this._isInSafeMask(Math.round(cx), Math.round(cy))) {
                                    const pt = { x: Math.round(cx), y: Math.round(cy) };
                                    if (!firstPt) firstPt = pt;
                                    lastPt = pt;
                                }
                                cx += 1;
                                cy -= 1;
                            }
                            if (firstPt && lastPt) {
                                diags.push({ from: firstPt, to: lastPt });
                            }
                        }

                        // Sharp square-turn zig-zag along diagonals
                        for (let i = 0; i < diags.length; i++) {
                            const diag = diags[i];
                            if (i % 2 === 0) {
                                pts.push(diag.from);
                                pts.push(diag.to);
                            } else {
                                pts.push(diag.to);
                                pts.push(diag.from);
                            }
                        }
                    }
                    return pts;
                }

                /**
                 * Fill a zone with zig-zag, using Big Box Splitting if needed.
                 * If zone width > strokeWidth * 4, split into Left & Right halves.
                 */
                _fillZoneZigzag(zoneIdx) {
                    const zone = this.zones[zoneIdx];
                    const cells = this.microCells[zoneIdx];
                    if (!zone || !cells) return [];

                    const hasActive = cells.some(c => c.active);
                    if (!hasActive) return [];

                    const dir = this.zoneDirections[zoneIdx];
                    const zMinX = Math.floor(zone.x);
                    const zMaxX = Math.ceil(zone.x + zone.w);
                    const zMinY = Math.floor(zone.y);
                    const zMaxY = Math.ceil(zone.y + zone.h);
                    const zoneWidth = zMaxX - zMinX;

                    let pts = [];

                    // --- Big Box Splitting ---
                    if (zoneWidth > this.strokeWidth * 4) {
                        // Split zone into Left and Right sub-sections
                        const midX = Math.round(zMinX + zoneWidth / 2);
                        const leftPts = this._rasterFillRect(zMinX, midX, zMinY, zMaxY, dir);
                        const rightPts = this._rasterFillRect(midX, zMaxX, zMinY, zMaxY, dir);

                        // Fill Left first, then Right
                        if (leftPts.length > 0) pts.push(...leftPts);
                        if (rightPts.length > 0) {
                            // Seamless connection: check if reversing right sub-section is shorter
                            if (pts.length > 0 && rightPts.length > 1) {
                                const lastPt = pts[pts.length - 1];
                                const distFirst = Math.hypot(rightPts[0].x - lastPt.x, rightPts[0].y - lastPt.y);
                                const distLast = Math.hypot(rightPts[rightPts.length - 1].x - lastPt.x, rightPts[rightPts.length - 1].y - lastPt.y);
                                if (distLast < distFirst) rightPts.reverse();
                            }
                            pts.push(...rightPts);
                        }
                    } else {
                        // Zone is narrow enough  fill as single block
                        pts = this._rasterFillRect(zMinX, zMaxX, zMinY, zMaxY, dir);
                    }

                    // If area is smaller than strokeWidth in both dimensions  single dot
                    if (pts.length === 0 && hasActive) {
                        let sx = 0, sy = 0, n = 0;
                        for (const c of cells) {
                            if (c.active && this._isInMask(c.cx, c.cy)) {
                                sx += c.cx; sy += c.cy; n++;
                            }
                        }
                        if (n > 0) {
                            pts.push({ x: sx / n, y: sy / n });
                        }
                    }

                    return pts;
                }

                // --- Generate zone fills in S-Curve boustrophedon order ---
                // Order: Row1 LR (0,1,2), Row2 RL (5,4,3), Row3 LR (6,7,8)
                // Minimizes travel distance between zone exits/entries
                generateZoneFillPoints() {
                    const allPts = [];
                    for (const z of this.zoneOrder) {
                        const zonePts = this._fillZoneZigzag(z);
                        if (zonePts.length === 0) continue;

                        // Seamless connection: pick whichever direction minimizes jump
                        if (allPts.length > 0) {
                            const lastPt = allPts[allPts.length - 1];
                            const distToFirst = Math.hypot(zonePts[0].x - lastPt.x, zonePts[0].y - lastPt.y);
                            const distToLast = Math.hypot(zonePts[zonePts.length - 1].x - lastPt.x, zonePts[zonePts.length - 1].y - lastPt.y);
                            if (distToLast < distToFirst) {
                                zonePts.reverse();
                            }
                        }
                        allPts.push(...zonePts);
                    }
                    return allPts;
                }

                // --- Full path: Outline + Fill (single continuous path) ---
                // With smart strategy selection: zig-zag for large shapes, inner outline for small
                generatePath() {
                    let outlinePoints = this.tracePerimeter();
                    const allPoints = [];

                    // Apply Normal Vector Offsetting to outline
                    // This ensures 1% overlap on shape, 99% outside
                    if (outlinePoints.length > 1) {
                        outlinePoints = applyNormalVectorOffset(outlinePoints, this.strokeWidth);
                    }

                    // Phase 1: Outline
                    if (outlinePoints.length > 0) {
                        allPoints.push(...outlinePoints);
                    }

                    // Phase 2: Decide fill strategy based on shape size
                    // Small shapes: use inner outline (with 80% probability)
                    // Large shapes: use standard zig-zag fill
                    const isSmall = this._isSmallShape();
                    const useInnerOutline = isSmall && Math.random() < 0.8;

                    let fillPoints = [];
                    if (useInnerOutline) {
                        // Small shape strategy: inner outline contour
                        fillPoints = this._generateInnerOutline();
                    } else {
                        // Large shape strategy (or small shape fallback): standard zone-based zig-zag
                        fillPoints = this.generateZoneFillPoints();
                    }

                    // Phase 3: Direct straight-line connection into fill (no gap)
                    if (fillPoints.length > 0) {
                        // Direct lineTo connection  no midpoint, no curve
                        allPoints.push(...fillPoints);
                    }

                    return allPoints;
                }
            }

            // --- Catmull-Rom Spline Smoothing ---
            function catmullRomPoint(p0, p1, p2, p3, t) {
                const t2 = t * t, t3 = t2 * t;
                return {
                    x: 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                    y: 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)
                };
            }

            /**
             * Apply Normal Vector Offsetting to perimeter points
             * Offsets the stroke path outward so 1% overlaps the shape and 99% is outside
             * Handles sharp turns with Miter Point calculations
             */
            function applyNormalVectorOffset(points, strokeWidth) {
                if (!points || points.length < 2) return points;

                // Calculate offset distance: pushes centerline outward
                // (strokeWidth / 2) * 0.98 ensures 1% inner edge touches, 99% outside
                const offsetDist = (strokeWidth / 2) * 0.98;
                const offsetPoints = [];
                const n = points.length;

                for (let i = 0; i < n; i++) {
                    const curr = points[i];
                    const prev = points[(i - 1 + n) % n];
                    const next = points[(i + 1) % n];

                    // Calculate incoming edge vector: prev  curr
                    let v1x = curr.x - prev.x;
                    let v1y = curr.y - prev.y;
                    const len1 = Math.sqrt(v1x * v1x + v1y * v1y);

                    // Calculate outgoing edge vector: curr  next
                    let v2x = next.x - curr.x;
                    let v2y = next.y - curr.y;
                    const len2 = Math.sqrt(v2x * v2x + v2y * v2y);

                    // Handle degenerate cases (zero-length vectors)
                    if (len1 < 1e-6 || len2 < 1e-6) {
                        // Fallback: just offset perpendicular to this edge
                        offsetPoints.push({
                            x: curr.x - v1y * offsetDist / (len1 + 1e-6),
                            y: curr.y + v1x * offsetDist / (len1 + 1e-6)
                        });
                        continue;
                    }

                    // Normalize incoming and outgoing vectors
                    v1x /= len1; v1y /= len1;
                    v2x /= len2; v2y /= len2;

                    // Calculate normals (perpendicular, pointing outward)
                    // For incoming edge: rotate 90 clockwise
                    const n1x = v1y;
                    const n1y = -v1x;

                    // For outgoing edge: rotate 90 clockwise
                    const n2x = v2y;
                    const n2y = -v2x;

                    // Bisector of the two normals (average direction for the turn)
                    let bisectX = (n1x + n2x) * 0.5;
                    let bisectY = (n1y + n2y) * 0.5;
                    const bisectLen = Math.sqrt(bisectX * bisectX + bisectY * bisectY);

                    let offsetX, offsetY;

                    if (bisectLen < 1e-6) {
                        // Nearly opposite normals (180 turn / straight line continuation)
                        // Use perpendicular offset from incoming edge
                        offsetX = n1x * offsetDist;
                        offsetY = n1y * offsetDist;
                    } else {
                        // Normal turn: calculate miter point
                        bisectX /= bisectLen;
                        bisectY /= bisectLen;

                        // Dot product of normals determines sharpness
                        const dotProduct = n1x * n2x + n1y * n2y;

                        // Cross product to detect if it's a U-turn (sharp inward turn)
                        const crossProduct = n1x * n2y - n1y * n2x;

                        // Calculate miter length (distance along bisector to maintain offset)
                        // Using: offsetDist / sin(angle/2)
                        const sinHalf = Math.sqrt((1 - dotProduct) / 2);

                        let miterDist = offsetDist;
                        if (sinHalf > 1e-6) {
                            miterDist = offsetDist / sinHalf;
                        }

                        // Clamp miter distance for very sharp turns (prevent unrealistic spikes)
                        const maxMiterDist = offsetDist * 3;
                        if (miterDist > maxMiterDist) {
                            // For very sharp turns: blend between bisector and single normal
                            // Use arc join behavior (back off from full miter)
                            miterDist = maxMiterDist;
                        }

                        offsetX = bisectX * miterDist;
                        offsetY = bisectY * miterDist;
                    }

                    // Apply offset to current point
                    offsetPoints.push({
                        x: curr.x + offsetX,
                        y: curr.y + offsetY
                    });
                }

                // Close the loop if original was closed
                if (n > 0 && offsetPoints.length > 0) {
                    if (points[0].x === points[n - 1].x && points[0].y === points[n - 1].y) {
                        // Copy first point to close
                        if (offsetPoints[offsetPoints.length - 1].x !== offsetPoints[0].x ||
                            offsetPoints[offsetPoints.length - 1].y !== offsetPoints[0].y) {
                            offsetPoints.push({ ...offsetPoints[0] });
                        }
                    }
                }

                return offsetPoints;
            }

            function smoothPointsCatmullRom(points, segmentsPerPair) {
                if (!points || points.length < 3) return points || [];
                const segs = segmentsPerPair || 4;
                const out = [{ ...points[0] }];
                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = points[Math.max(0, i - 1)];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = points[Math.min(points.length - 1, i + 2)];
                    for (let s = 1; s <= segs; s++) {
                        out.push(catmullRomPoint(p0, p1, p2, p3, s / segs));
                    }
                }
                return out;
            }

            // --- Helper: Get mask bounds ---
            function getMaskBounds(activeMask, width, height) {
                let minX = width, minY = height, maxX = -1, maxY = -1;
                for (let i = 0; i < activeMask.length; i++) {
                    if (activeMask[i] === 1) {
                        const x = i % width;
                        const y = (i / width) | 0;
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
                if (maxX < 0) return null;
                return { minX, minY, maxX, maxY };
            }

            function getMaskCentroid(activeMask, width, height, bounds) {
                let sumX = 0, sumY = 0, n = 0;
                for (let y = bounds.minY; y <= bounds.maxY; y++) {
                    for (let x = bounds.minX; x <= bounds.maxX; x++) {
                        if (activeMask[y * width + x] === 1) { sumX += x; sumY += y; n++; }
                    }
                }
                return n === 0 ? null : { x: sumX / n, y: sumY / n };
            }

            // --- Pen-lift aware smooth path generation ---
            function generateSmoothPathWithPenLifts(points, strokeWidth) {
                if (!points || points.length < 2) return "";
                const segments = [];
                let seg = [];
                for (let i = 0; i < points.length; i++) {
                    if (points[i].penLift && seg.length >= 2) {
                        segments.push([...seg]);
                        seg = [points[i]];
                    } else {
                        seg.push(points[i]);
                    }
                }
                if (seg.length >= 2) segments.push(seg);

                let pathData = "";
                for (const s of segments) {
                    if (s.length < 2) continue;
                    // Smooth with Catmull-Rom
                    const smooth = smoothPointsCatmullRom(s, 3);
                    const r = (n) => Math.round(n * 10) / 10;
                    pathData += (pathData ? " " : "") + `M${r(smooth[0].x)},${r(smooth[0].y)}`;
                    for (let i = 1; i < smooth.length; i++) {
                        pathData += ` L${r(smooth[i].x)},${r(smooth[i].y)}`;
                    }
                }
                return pathData;
            }

            // --- Component ID lookup (for selection system) ---
            function getComponentIdForSvgPoint(svgX, svgY) {
                if (!selectionMask || !selectionViewBox || !selectionMaskWidth || !selectionMaskHeight) return null;
                if (!selectionComponentLabels) {
                    const result = computeSelectionComponents(selectionMask, selectionMaskWidth, selectionMaskHeight);
                    if (result) { selectionComponentLabels = result.labels; selectionComponentCount = result.count; }
                    else return null;
                }
                const relX = (svgX - selectionViewBox.x) / selectionViewBox.w;
                const relY = (svgY - selectionViewBox.y) / selectionViewBox.h;
                if (relX < 0 || relX > 1 || relY < 0 || relY > 1) return null;
                const maskX = Math.floor(relX * selectionMaskWidth);
                const maskY = Math.floor(relY * selectionMaskHeight);
                if (maskX < 0 || maskX >= selectionMaskWidth || maskY < 0 || maskY >= selectionMaskHeight) return null;
                const label = selectionComponentLabels[maskY * selectionMaskWidth + maskX];
                return label >= 0 ? label : null;
            }

            function clearSelectionComponentCache() {
                selectionComponentLabels = null;
                selectionComponentCount = 0;
            }

            // --- Calculate actual pixel length of stroke ---
            function calculateStrokeLength(points) {
                if (!points || points.length < 2) return 0;
                let total = 0;
                for (let i = 1; i < points.length; i++) {
                    total += Math.hypot(points[i].x - points[i - 1].x, points[i].y - points[i - 1].y);
                }
                return total;
            }

            // --- Split points into animated stroke segments ---
            function generateAnimatedStrokePaths(points, strokeWidth) {
                if (!points || points.length < 2) return [];
                const paths = [];
                let current = [];
                const maxLen = 2000;
                const minLen = 3;
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    if (p.penLift || (current.length >= maxLen && i < points.length - 1)) {
                        if (current.length >= minLen) {
                            const len = calculateStrokeLength(current);
                            if (len >= strokeWidth * 2) paths.push([...current]);
                        }
                        current = [p];
                    } else {
                        current.push(p);
                    }
                }
                if (current.length >= minLen) {
                    if (calculateStrokeLength(current) >= strokeWidth * 2) paths.push(current);
                }
                return paths;
            }

            // --- Create individual SVG path element ---
            function createAnimatedStrokePath(strokePoints, strokeWidth, color, strokeIndex) {
                if (!strokePoints || strokePoints.length < 2) return null;
                const smooth = smoothPointsCatmullRom(strokePoints, 3);
                const r = (n) => Math.round(n * 10) / 10;
                let pathData = `M ${r(smooth[0].x)} ${r(smooth[0].y)}`;
                for (let i = 1; i < smooth.length; i++) {
                    pathData += ` L ${r(smooth[i].x)} ${r(smooth[i].y)}`;
                }

                const pathId = `animated-stroke-${strokeIndex}-${Date.now()}`;
                const pathAttrs = {
                    id: pathId,
                    d: pathData,
                    stroke: color || currentColor,
                    'stroke-width': strokeWidth,
                    fill: 'none',
                    'stroke-linecap': 'round',
                    'stroke-linejoin': 'round',
                    'stroke-opacity': currentStrokeOpacity,
                    'opacity': currentStrokeOpacity,
                    'visibility': 'visible',
                    'data-stroke-index': strokeIndex,
                    'data-stroke-length': strokePoints.length,
                    'data-animation-order': strokeIndex,
                    'data-hidden': 'false',
                    'data-can-animate': 'true',
                    'class': 'animated-stroke-path visible-stroke'
                };

                // --- ARTISTIC FILTER APPLICATION (mirrors manual drawing logic) ---
                const baseStyleParts = ['pointer-events: none;'];
                let effectFilterId = null;

                if (wetPaintEnabled) {
                    effectFilterId = ensureWetPaintStrokeFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else if (waterMixEnabled) {
                    effectFilterId = ensureWaterMixFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else if (glossyEffectEnabled) {
                    effectFilterId = ensureGlossyEffectFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else if (glitterEffectEnabled) {
                    effectFilterId = ensureGlitterEffectFilter(currentStrokeBlur);
                    if (effectFilterId) {
                        baseStyleParts.push(`filter: url(#${effectFilterId});`);
                    }
                } else {
                    if (currentStrokeBlur > 0) {
                        pathAttrs['filter'] = `url(#blur-${currentStrokeBlur})`;
                    }
                }
                pathAttrs['style'] = baseStyleParts.join(' ');

                const path = createSvgElement('path', pathAttrs);

                // --- DATA ATTRIBUTES for effect tracking (mirrors manual drawing) ---
                if (wetPaintEnabled) {
                    path.setAttribute('data-wet-paint-stroke', 'true');
                    if (effectFilterId) {
                        path.setAttribute('data-wet-paint-filter', effectFilterId);
                    }
                } else if (glossyEffectEnabled) {
                    path.setAttribute('data-glossy-stroke', 'true');
                    if (effectFilterId) {
                        path.setAttribute('data-glossy-filter', effectFilterId);
                    }
                } else if (glitterEffectEnabled) {
                    path.setAttribute('data-glitter-stroke', 'true');
                    if (effectFilterId) {
                        path.setAttribute('data-glitter-filter', effectFilterId);
                    }
                } else if (waterMixEnabled) {
                    path.setAttribute('data-water-mix-stroke', 'true');
                    if (effectFilterId) {
                        path.setAttribute('data-water-mix-filter', effectFilterId);
                    }
                }

                // --- FILTER PERFORMANCE OPTIMIZATION ---
                // Cache heavy filters off the live canvas (same pattern as endDrawing).
                // They will be restored during export.
                if (effectFilterId) {
                    const style = path.getAttribute('style') || '';
                    const filterMatch = style.match(/filter:\s*url\(#([^)]+)\)/);
                    if (filterMatch) {
                        const fId = filterMatch[1];
                        if (fId.includes('wet-paint') ||
                            fId.includes('glitter') ||
                            fId.includes('glossy') ||
                            fId.includes('water-mix')) {
                            path.setAttribute('data-cached-filter', `url(#${fId})`);
                            const newStyle = style.replace(/filter:\s*url\(#[^)]+\);?/, '').trim();
                            path.setAttribute('style', newStyle);
                        }
                    }
                }

                if (currentSelectionClipPathId) {
                    path.setAttribute('clip-path', `url(#${currentSelectionClipPathId})`);
                }
                return path;
            }

            /**
             * MAIN AUTO-STROKE FUNCTION - Smart Snake Filler Engine
             * Uses SmartSnakeFiller: FIXED pen size, zig-zag raster fill
             * Stage A: Perimeter trace (outline of the shape)
             * Stage B: Zone-by-zone zig-zag fill (19) with directional variety
             * Stroke width is NEVER changed  uses the user's currentStrokeWidth
             */

            /**
             * Validate and execute Auto Stroke for a detected closed shape
             * Real-time validation: Ensures only valid closed paths are processed
             * Shows feedback for invalid shapes
             * 
             * NEW IMPROVEMENTS:
             * 1. Randomized stroke pattern direction per shape (different angles for each)
             * 2. Smart size detection with inner outline strategy for small shapes (80% probability)
             */
            async function executeAutoStroke(selectionMaskParam, maskWidthParam, maskHeightParam, viewBoxParam) {
                // Validate that we have a valid selection
                if (!selectionMaskParam || !maskWidthParam || !maskHeightParam || !viewBoxParam) {
                    console.warn('[Auto Stroke] Invalid selection - missing mask or dimensions');
                    return false;
                }

                // Check if selection has content (non-empty mask)
                const maskHasContent = selectionMaskParam.some(pixel => pixel === 1);
                if (!maskHasContent) {
                    console.warn('[Auto Stroke] Selection mask is empty - cannot auto stroke');
                    return false;
                }

                // Validate that selection is large enough to stroke
                let pixelCount = 0;
                for (let i = 0; i < selectionMaskParam.length; i++) {
                    if (selectionMaskParam[i] === 1) pixelCount++;
                }

                const minPixelsForStroke = Math.max(currentStrokeWidth * currentStrokeWidth * 2, 100);
                if (pixelCount < minPixelsForStroke) {
                    console.warn(`[Auto Stroke] Selection too small (${pixelCount} pixels, minimum ${minPixelsForStroke})`);
                    return false;
                }

                // Real-time detection logging with NEW FEATURE INFO
                console.log(`[Auto Stroke v2] Closed shape detected with NEW improvements:`, {
                    pixelCount,
                    bounds: { width: maskWidthParam, height: maskHeightParam },
                    strokeWidth: currentStrokeWidth,
                    improvements: [
                        'FEATURE 1: Randomized stroke pattern direction per shape',
                        'FEATURE 2: Smart inner outline strategy for small shapes (80% probability)'
                    ],
                    timestamp: new Date().toISOString()
                });

                // Execute auto stroke with improved SmartSnakeFiller
                await autoStroke(selectionMaskParam, maskWidthParam, maskHeightParam, currentStrokeWidth, currentColor, viewBoxParam);
                return true;
            }

            /**
             * Validate coverage boxes for a shape
             * Returns validated boxes that fit within the shape bounds
             * Ensures no gaps and no overlaps
             */
            function validateShapeCoverage(mask, width, height, viewBox, strokeWidth) {
                if (!mask || !viewBox) return [];

                // Generate initial boxes
                const boxes = generateZoomIndependentBoxes(mask, width, height, viewBox, strokeWidth);

                // Validate each box
                const validatedBoxes = validateCoverageBoxes(boxes, mask, width, height);

                console.log(`[Auto Stroke] Coverage validation:`, {
                    totalBoxes: boxes.length,
                    validatedBoxes: validatedBoxes.length,
                    coverage: validatedBoxes.length > 0 ? `${Math.round(validatedBoxes.length / 9 * 100)}%` : '0%'
                });

                return validatedBoxes;
            }

            async function autoStroke(mask, width, height, strokeWidth, color, viewBox) {
                const vBox = viewBox || selectionViewBox;
                if (!mask || !width || !height || !vBox) return;

                loader.classList.remove('hidden');
                await new Promise(r => requestAnimationFrame(r));

                // FIXED PEN SIZE: use user's strokeWidth, never auto-change
                const fixedSW = Math.max(1, strokeWidth);

                // Calculate zoom level from SVG viewBox
                // Default canvas viewBox is typically { x: 0, y: 0, w: canvasWidth, h: canvasHeight }
                // Current viewBox determines zoom: smaller w means more zoomed in
                let zoomLevel = 1.0;
                if (svgCanvas && vBox) {
                    const defaultVB = svgCanvas.getAttribute('viewBox');
                    if (defaultVB) {
                        const defaultParts = defaultVB.split(/[\s,]+/).map(v => parseFloat(v));
                        if (defaultParts.length === 4) {
                            zoomLevel = defaultParts[2] / vBox.w;
                        }
                    }
                }

                // Create the SmartSnakeFiller with zoom independence (Smart Snake engine)
                const filler = new SmartSnakeFiller(mask, width, height, fixedSW, vBox, zoomLevel);
                if (!filler.bounds || !filler.mainBox) {
                    loader.classList.add('hidden');
                    return;
                }

                // Detect shape characteristics for feedback
                const isSmallShape = filler._isSmallShape();
                let pixelCount = 0;
                for (let i = 0; i < mask.length; i++) {
                    if (mask[i] === 1) pixelCount++;
                }

                // Log shape strategy selection
                console.log('[Auto Stroke] Shape Analysis:', {
                    pixelCount,
                    isSmall: isSmallShape,
                    bounds: { width: filler.mainBox.w, height: filler.mainBox.h },
                    strokeWidth: fixedSW,
                    strategy: isSmallShape ? 'Inner Outline (with 80% probability)' : 'Standard Zig-Zag Fill',
                    zoneDirections: filler.zoneDirections
                });

                // Generate the single continuous path: Outline  Zone fills
                const allPoints = filler.generatePath();

                if (allPoints.length < 2) {
                    loader.classList.add('hidden');
                    return;
                }

                // Convert pixel coords  SVG coords using filler's zoom-independent methods
                const svgPoints = allPoints.map(p => ({
                    x: filler.toSvgX(p.x),
                    y: filler.toSvgY(p.y),
                    penLift: p.penLift || false
                }));

                // Split into animated stroke segments (pen lifts at zone transitions)
                const strokePaths = generateAnimatedStrokePaths(svgPoints, fixedSW);

                if (strokePaths.length === 0) {
                    loader.classList.add('hidden');
                    return;
                }

                const createdPaths = [];
                for (let i = 0; i < strokePaths.length; i++) {
                    if (strokePaths[i].length >= 2) {
                        const path = createAnimatedStrokePath(strokePaths[i], fixedSW, color, i);
                        if (path) {
                            drawingLayer.appendChild(path);
                            createdPaths.push(path);
                        }
                    }
                    // Yield to UI periodically
                    if (i % 10 === 0) await new Promise(r => setTimeout(r, 0));
                }

                // Metadata for external animation control
                const metadata = createSvgElement('g', {
                    id: 'animation-metadata',
                    'data-total-strokes': createdPaths.length,
                    'data-stroke-width': fixedSW,
                    'data-color': color || currentColor,
                    'data-timestamp': Date.now(),
                    style: 'display: none;'
                });
                drawingLayer.appendChild(metadata);

                // --- NEW: Create visual overlay for the auto stroke area ---
                try {
                    const contours = getContoursFromMask(mask, width, height);
                    let d = "";
                    contours.forEach(contour => {
                        contour.forEach((p, i) => {
                            const sx = filler.toSvgX(p.x);
                            const sy = filler.toSvgY(p.y);
                            d += (i === 0 ? "M" : "L") + sx.toFixed(2) + "," + sy.toFixed(2);
                        });
                        d += "Z ";
                    });
                    if (d) {
                        const overlay = createSvgElement('path', {
                            d: d.trim(),
                            fill: 'url(#diagonalHatch)',
                            class: 'auto-stroke-overlay',
                            style: 'pointer-events: none;'
                        });
                        drawingLayer.appendChild(overlay);
                    }
                } catch (e) {
                    console.warn("Failed to create auto-stroke overlay:", e);
                }

                deselect();
                addHistoryState('drawing');
                loader.classList.add('hidden');
            }
            // --- NEW: Helper function to detect collinear points ---
            function checkIfCollinear(p1, p2, p3, tolerance = 2) {
                // Check if three points are collinear (within tolerance)
                // Using cross product: if ~0, points are collinear
                const v1x = p2.x - p1.x;
                const v1y = p2.y - p1.y;
                const v2x = p3.x - p2.x;
                const v2y = p3.y - p2.y;

                const crossProduct = Math.abs(v1x * v2y - v1y * v2x);
                const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
                const len2 = Math.sqrt(v2x * v2x + v2y * v2y);

                if (len1 === 0 || len2 === 0) return false;

                // Normalize cross product by length product
                const normalizedCross = crossProduct / (len1 * len2);
                return normalizedCross < tolerance;
            }

            // === ANIMATION EXPORT FUNCTIONS ===

            /**
             * Export stroke data for external animation app
             */
            function exportAnimationData() {
                const animatedStrokes = document.querySelectorAll('.animated-stroke-path');
                const metadata = document.getElementById('animation-metadata');

                if (animatedStrokes.length === 0) {
                    console.log('No animated strokes found');
                    return null;
                }

                const strokeData = [];
                animatedStrokes.forEach((stroke, index) => {
                    strokeData.push({
                        id: stroke.getAttribute('id'),
                        pathData: stroke.getAttribute('d'),
                        strokeIndex: parseInt(stroke.getAttribute('data-stroke-index')),
                        strokeLength: parseInt(stroke.getAttribute('data-stroke-length')),
                        animationOrder: parseInt(stroke.getAttribute('data-animation-order')),
                        color: stroke.getAttribute('stroke'),
                        strokeWidth: stroke.getAttribute('stroke-width')
                    });
                });

                const exportData = {
                    strokes: strokeData.sort((a, b) => a.animationOrder - b.animationOrder),
                    metadata: metadata ? {
                        totalStrokes: parseInt(metadata.getAttribute('data-total-strokes')),
                        strokeWidth: parseInt(metadata.getAttribute('data-stroke-width')),
                        color: metadata.getAttribute('data-color'),
                        timestamp: parseInt(metadata.getAttribute('data-timestamp'))
                    } : null,
                    svgViewBox: selectionViewBox,
                    exportTime: new Date().toISOString()
                };

                // Log to console for external app to capture
                console.log('ANIMATION_EXPORT:', JSON.stringify(exportData, null, 2));

                // Also store in window for external app access
                window.animationExportData = exportData;

                return exportData;
            }

            /**
             * Get stroke paths for real-time animation
             */
            function getAnimationStrokes() {
                const strokes = document.querySelectorAll('.animated-stroke-path');
                const strokeArray = [];

                strokes.forEach(stroke => {
                    strokeArray.push({
                        element: stroke,
                        path: stroke.getAttribute('d'),
                        index: parseInt(stroke.getAttribute('data-animation-order')),
                        length: parseInt(stroke.getAttribute('data-stroke-length'))
                    });
                });

                return strokeArray.sort((a, b) => a.index - b.index);
            }

            /**
             * Animate strokes with external PNG hand (for testing)
             */
            function animateWithHand() {
                const strokes = getAnimationStrokes();
                if (strokes.length === 0) return;

                console.log(`Starting animation of ${strokes.length} visible strokes`);

                // First hide all strokes for animation
                strokes.forEach(stroke => {
                    hideStroke(stroke.element);
                });

                // Then reveal each stroke in sequence
                strokes.forEach((stroke, index) => {
                    setTimeout(() => {
                        revealStroke(stroke.element);
                        console.log(`Revealing stroke ${index + 1}/${strokes.length}: ${stroke.element.id}`);

                        // Here you would trigger the external app's PNG hand animation
                        if (window.externalHandAnimator) {
                            window.externalHandAnimator.animateStroke(stroke);
                        }
                    }, index * 500); // 500ms delay between strokes
                });
            }

            /**
             * Reveal a single stroke for external animation
             */
            function revealStroke(strokeElement) {
                if (!strokeElement) return;

                // Make stroke visible
                strokeElement.style.visibility = 'visible';
                strokeElement.style.opacity = currentStrokeOpacity.toString();
                strokeElement.setAttribute('stroke-opacity', currentStrokeOpacity.toString());
                strokeElement.setAttribute('opacity', currentStrokeOpacity.toString());
                strokeElement.setAttribute('visibility', 'visible');
                strokeElement.setAttribute('data-hidden', 'false');
                strokeElement.classList.remove('hidden-stroke');
                strokeElement.classList.add('revealed-stroke');
                strokeElement.classList.add('visible-stroke');

                console.log(`Stroke revealed: ${strokeElement.id}`);
            }

            /**
             * Hide a single stroke (for external animation control)
             */
            function hideStroke(strokeElement) {
                if (!strokeElement) return;

                // Hide stroke
                strokeElement.style.visibility = 'hidden';
                strokeElement.style.opacity = '0';
                strokeElement.setAttribute('stroke-opacity', '0');
                strokeElement.setAttribute('opacity', '0');
                strokeElement.setAttribute('visibility', 'hidden');
                strokeElement.setAttribute('data-hidden', 'true');
                strokeElement.classList.add('hidden-stroke');
                strokeElement.classList.remove('revealed-stroke');
                strokeElement.classList.remove('visible-stroke');

                console.log(`Stroke hidden: ${strokeElement.id}`);
            }

            /**
             * Reveal stroke by index for external app
             */
            function revealStrokeByIndex(strokeIndex) {
                const stroke = document.querySelector(`[data-stroke-index="${strokeIndex}"]`);
                if (stroke) {
                    revealStroke(stroke);
                    return true;
                }
                console.log(`Stroke with index ${strokeIndex} not found`);
                return false;
            }

            /**
             * Hide stroke by index for external app
             */
            function hideStrokeByIndex(strokeIndex) {
                const stroke = document.querySelector(`[data-stroke-index="${strokeIndex}"]`);
                if (stroke) {
                    hideStroke(stroke);
                    return true;
                }
                console.log(`Stroke with index ${strokeIndex} not found`);
                return false;
            }

            /**
             * Hide all strokes (for external animation setup)
             */
            function hideAllStrokes() {
                const strokes = document.querySelectorAll('.animated-stroke-path');
                strokes.forEach(stroke => hideStroke(stroke));
                console.log(`Hidden all ${strokes.length} strokes for animation`);
            }

            /**
             * Show all strokes (restore normal visibility)
             */
            function showAllStrokes() {
                const strokes = document.querySelectorAll('.animated-stroke-path');
                strokes.forEach(stroke => revealStroke(stroke));
                console.log(`Shown all ${strokes.length} strokes`);
            }

            /**
             * Get all stroke data for external app
             */
            function getAllStrokeData() {
                const strokes = document.querySelectorAll('.animated-stroke-path');
                const strokeData = [];

                strokes.forEach(stroke => {
                    strokeData.push({
                        id: stroke.getAttribute('id'),
                        pathData: stroke.getAttribute('d'),
                        strokeIndex: parseInt(stroke.getAttribute('data-stroke-index')),
                        animationOrder: parseInt(stroke.getAttribute('data-animation-order')),
                        color: stroke.getAttribute('stroke'),
                        strokeWidth: stroke.getAttribute('stroke-width'),
                        canAnimate: stroke.getAttribute('data-can-animate') === 'true',
                        isHidden: stroke.getAttribute('data-hidden') === 'true',
                        isVisible: stroke.style.visibility !== 'hidden' && stroke.style.opacity !== '0'
                    });
                });

                return strokeData.sort((a, b) => a.animationOrder - b.animationOrder);
            }

            /**
             * External App API - Control stroke visibility for animation
             */
            window.strokeAnimationAPI = {
                // Get all stroke data
                getAllStrokes: getAllStrokeData,
                getAnimationData: exportAnimationData,
                getStrokes: getAnimationStrokes,

                // Animation controls
                revealStroke: revealStrokeByIndex,
                hideStroke: hideStrokeByIndex,
                revealAllStrokes: showAllStrokes,
                hideAllStrokes: hideAllStrokes,

                // Animation setup
                setupForAnimation: hideAllStrokes, // Hide all before animation
                restoreAfterAnimation: showAllStrokes, // Show all after animation

                // Status check
                getVisibleCount: () => document.querySelectorAll('.visible-stroke').length,
                getHiddenCount: () => document.querySelectorAll('.hidden-stroke').length,
                areAllVisible: () => document.querySelectorAll('.animated-stroke-path').length === document.querySelectorAll('.visible-stroke').length
            };

            console.log('Stroke Animation API loaded:', Object.keys(window.strokeAnimationAPI));
            // --- NEW: Marching Squares for Smooth Selection ---
            function getContoursFromMask(mask, width, height) {
                const nextMap = new Map();
                const addSeg = (x1, y1, x2, y2) => {
                    nextMap.set(`${x1},${y1}`, { x: x2, y: y2 });
                };

                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        const idx = y * width + x;
                        const tl = mask[idx] === 1 ? 1 : 0;
                        const tr = mask[idx + 1] === 1 ? 1 : 0;
                        const bl = mask[idx + width] === 1 ? 1 : 0;
                        const br = mask[idx + width + 1] === 1 ? 1 : 0;

                        const val = (tl << 3) | (tr << 2) | (br << 1) | bl;
                        if (val === 0 || val === 15) continue;

                        const top = { x: x + 0.5, y: y };
                        const right = { x: x + 1, y: y + 0.5 };
                        const bottom = { x: x + 0.5, y: y + 1 };
                        const left = { x: x, y: y + 0.5 };

                        switch (val) {
                            case 1: addSeg(left.x, left.y, bottom.x, bottom.y); break;
                            case 2: addSeg(bottom.x, bottom.y, right.x, right.y); break;
                            case 3: addSeg(left.x, left.y, right.x, right.y); break;
                            case 4: addSeg(right.x, right.y, top.x, top.y); break;
                            case 5: addSeg(left.x, left.y, top.x, top.y); addSeg(right.x, right.y, bottom.x, bottom.y); break;
                            case 6: addSeg(bottom.x, bottom.y, top.x, top.y); break;
                            case 7: addSeg(left.x, left.y, top.x, top.y); break;
                            case 8: addSeg(top.x, top.y, left.x, left.y); break;
                            case 9: addSeg(top.x, top.y, bottom.x, bottom.y); break;
                            case 10: addSeg(top.x, top.y, right.x, right.y); addSeg(bottom.x, bottom.y, left.x, left.y); break;
                            case 11: addSeg(top.x, top.y, right.x, right.y); break;
                            case 12: addSeg(right.x, right.y, left.x, left.y); break;
                            case 13: addSeg(right.x, right.y, bottom.x, bottom.y); break;
                            case 14: addSeg(bottom.x, bottom.y, left.x, left.y); break;
                        }
                    }
                }

                const contours = [];
                const visited = new Set();
                for (const [startKey, endPoint] of nextMap) {
                    if (visited.has(startKey)) continue;
                    const contour = [];
                    let currKey = startKey;
                    let currPoint = { x: parseFloat(startKey.split(',')[0]), y: parseFloat(startKey.split(',')[1]) };

                    while (currKey && !visited.has(currKey)) {
                        visited.add(currKey);
                        contour.push(currPoint);
                        const nextP = nextMap.get(currKey);
                        if (!nextP) break;
                        currPoint = nextP;
                        currKey = `${nextP.x},${nextP.y}`;
                        if (currKey === startKey) { contour.push(currPoint); break; }
                    }
                    if (contour.length > 2) contours.push(contour);
                }
                return contours;
            }
            function generateSelectionPath(mask, width, height) {
                // For Wand 2 (outline selection), use exact mask without shrinking
                // For other selections, apply shrink if user requested
                let pathMask = mask;
                if (currentSelectionType !== 'wand-2' && selectionShrinkAmount !== 0) {
                    pathMask = shrinkSelectionMask(mask, width, height, selectionShrinkAmount);
                }

                // Cache the mask used for clipping
                cachedShrunkMask = pathMask;

                selectionPath = new Path2D();
                let fullPathData = "";

                // Generate contours using Marching Squares
                const contours = getContoursFromMask(pathMask, width, height);

                contours.forEach(contour => {
                    if (contour.length < 3) return;

                    let simplified;
                    let pathData;

                    if (currentSelectionType !== 'wand-2') {
                        // WAND 1: Use Douglas-Peucker to reduce nodes while maintaining pixel accuracy
                        // Tolerance of 0.3-0.5 is ideal for pixel-perfect but lightweight paths
                        simplified = simplifyPath(contour, 0.4);

                        // Final pass: remove any remaining collinear points to minimize path data
                        const reduced = [];
                        if (simplified.length > 0) {
                            reduced.push(simplified[0]);
                            for (let i = 1; i < simplified.length - 1; i++) {
                                if (!checkIfCollinear(simplified[i - 1], simplified[i], simplified[i + 1], 0.05)) {
                                    reduced.push(simplified[i]);
                                }
                            }
                            if (simplified.length > 1) {
                                reduced.push(simplified[simplified.length - 1]);
                            }
                        }

                        pathData = generateLinearPath(reduced);
                    } else {
                        // WAND 2: Use moderate simplification and smooth spline generation
                        simplified = simplifyPath(contour, 0.7);
                        pathData = generateSmoothPath(simplified);
                    }

                    if (pathData) {
                        pathData += " Z";
                        selectionPath.addPath(new Path2D(pathData));
                        fullPathData += pathData + " ";
                    }
                });

                currentSelectionPathData = fullPathData;

                // Update clip path with the optimized vector path
                updateSelectionClipPath(pathMask, width, height, fullPathData);

                // Save marching ants path to cache
                if (selectionViewBox) {
                    saveMarchingAntsPath(selectionPath, selectionViewBox);
                }
            }
            function updateSelectionClipPath(mask, width, height, smoothPathData = null) {
                if (!selectionMask || !selectionViewBox) {
                    drawingLayer.removeAttribute('clip-path');
                    currentSelectionClipPathId = null;
                    return;
                }

                // Create unique clipPath ID for this selection (keep old ones for previous paths)
                const clipPathId = `selection-clip-path-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                currentSelectionClipPathId = clipPathId;

                // Use stored smooth path data if not provided
                if (!smoothPathData && typeof currentSelectionPathData !== 'undefined' && currentSelectionPathData) {
                    smoothPathData = currentSelectionPathData;
                }

                const clipPath = createSvgElement('clipPath', { id: clipPathId });

                if (smoothPathData) {
                    // Use the smooth vector path
                    const scaleX = selectionViewBox.w / width;
                    const scaleY = selectionViewBox.h / height;

                    const clipPathElement = createSvgElement('path', {
                        d: smoothPathData,
                        transform: `translate(${selectionViewBox.x}, ${selectionViewBox.y}) scale(${scaleX}, ${scaleY})`,
                        'fill-rule': 'evenodd'
                    });
                    clipPath.appendChild(clipPathElement);
                } else {
                    // Fallback to pixel-based rectangles (legacy/backup)
                    const padding = Math.max(currentStrokeWidth / 2 + 2, 5);
                    const scaleX = selectionViewBox.w / width;
                    const scaleY = selectionViewBox.h / height;
                    const pathParts = [];
                    const isWand2Selection = !!outlineSelectionMask;

                    // MODIFICATION: If Auto Stroke is enabled and it's a Wand 1 selection, 
                    // we use NO expansion to ensure zero bleed as requested.
                    const strokeExpansion = (autoStrokePathEnabled && !isWand2Selection) ? 0 :
                        (isWand2Selection ? (0.5 * (scaleX + scaleY) / 2) : (currentStrokeWidth / 2) * (scaleX + scaleY) / 2);

                    for (let y = 0; y < height; y++) {
                        let startX = -1;
                        for (let x = 0; x <= width; x++) {
                            const isSelected = x < width && mask[y * width + x] === 1;

                            if (isSelected && startX === -1) {
                                startX = x;
                            } else if (!isSelected && startX !== -1) {
                                const svgX1 = selectionViewBox.x + (startX * scaleX) - strokeExpansion;
                                const svgY1 = selectionViewBox.y + (y * scaleY) - strokeExpansion;
                                const svgX2 = selectionViewBox.x + ((x) * scaleX) + strokeExpansion;
                                const svgY2 = selectionViewBox.y + ((y + 1) * scaleY) + strokeExpansion;

                                pathParts.push(`M ${svgX1} ${svgY1} L ${svgX2} ${svgY1} L ${svgX2} ${svgY2} L ${svgX1} ${svgY2} Z`);
                                startX = -1;
                            }
                        }
                    }

                    if (pathParts.length > 0) {
                        const clipPathElement = createSvgElement('path', {
                            d: pathParts.join(' '),
                            'fill-rule': 'evenodd'
                        });
                        clipPath.appendChild(clipPathElement);
                    } else {
                        let clipX, clipY, clipW, clipH;
                        if (selectionBounds) {
                            clipX = selectionViewBox.x + (selectionBounds.minX * scaleX) - padding;
                            clipY = selectionViewBox.y + (selectionBounds.minY * scaleY) - padding;
                            clipW = ((selectionBounds.maxX - selectionBounds.minX + 1) * scaleX) + (padding * 2);
                            clipH = ((selectionBounds.maxY - selectionBounds.minY + 1) * scaleY) + (padding * 2);
                        } else {
                            clipX = selectionViewBox.x - padding;
                            clipY = selectionViewBox.y - padding;
                            clipW = selectionViewBox.w + (padding * 2);
                            clipH = selectionViewBox.h + (padding * 2);
                        }
                        const clipRect = createSvgElement('rect', {
                            x: clipX,
                            y: clipY,
                            width: clipW,
                            height: clipH
                        });
                        clipPath.appendChild(clipRect);
                    }
                }

                defs.appendChild(clipPath);

                // Don't apply clipPath to entire drawing layer - it will be applied to individual paths
            }
            function deselect() {
                if (antsAnimationId) {
                    cancelAnimationFrame(antsAnimationId);
                    antsAnimationId = null;
                }
                antsCtx.clearRect(0, 0, antsCanvas.width, antsCanvas.height);
                selectionMask = null;
                selectionMaskWidth = 0;
                selectionMaskHeight = 0;
                selectionPath = null;
                currentSelectionPathData = null; // NEW: Clear smooth path data
                selectionViewBox = null;
                selectionBounds = null;
                cachedShrunkMask = null; // Clear cached shrunk mask
                cachedShrunkMask = null; // Clear cached shrunk mask
                currentSelectionClipPathId = null; // Clear current selection clipPath ID
                outlineSelectionMask = null; // Clear outline selection mask
                currentSelectionType = null; // Clear selection type
                clearSelectionComponentCache(); // Clear connected component cache
                deselectBtn.classList.add('hidden');
                if (shortcutSelectionVisibilityBtn) shortcutSelectionVisibilityBtn.classList.add('hidden'); // Hide shortcut

                wandPencilSliderContainer.classList.remove('visible');
                wandHistoryContainer.classList.remove('visible'); // NEW: Hide history
                wandBtnManualPos = null; // NEW: Reset manual position

                // NEW: Restore opacity when deselecting (if we're not using wand anymore)
                if (currentTool !== 'magic-wand' && referenceImage) {
                    opacitySlider.value = savedTraceOpacity.toString();
                    referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                }

                // Don't remove clipPaths from defs - existing paths still need them for export

                updateCanvasOverlays();
            }

            function startMarchingAnts() {
                if (!selectionMask || !antsCanvas) return;

                // NEW: Debounce the marching ants restart to prevent excessive restarts during pan/zoom
                if (marchingAntsDebouncerId) {
                    clearTimeout(marchingAntsDebouncerId);
                }

                marchingAntsDebouncerId = setTimeout(() => {
                    _internalStartMarchingAnts();
                    marchingAntsDebouncerId = null;
                }, MARCHING_ANTS_DEBOUNCE_MS);
            }

            function _internalStartMarchingAnts() {
                if (!selectionMask || !antsCanvas) return;

                // Respect manual visibility setting
                if (!isSelectionVisible) {
                    antsCanvas.style.opacity = '0';
                    if (wandToggleBtn) wandToggleBtn.style.display = 'none';
                    if (antsAnimationId) {
                        cancelAnimationFrame(antsAnimationId);
                        antsAnimationId = null;
                    }
                    return;
                } else {
                    antsCanvas.style.opacity = '1';
                    if (wandToggleBtn) wandToggleBtn.style.display = '';
                }

                if (antsAnimationId) {
                    cancelAnimationFrame(antsAnimationId);
                    antsAnimationId = null;
                }

                // Animation Loop
                let offset = 0;
                let lastAnimationTime = 0;
                const ANIMATION_INTERVAL_MS = 50; // Update animation every ~50ms (20fps is enough for marching ants)

                const animate = () => {
                    const now = Date.now();

                    // Only update animation if enough time has passed
                    if (now - lastAnimationTime < ANIMATION_INTERVAL_MS) {
                        antsAnimationId = requestAnimationFrame(animate);
                        return;
                    }
                    lastAnimationTime = now;
                    offset = (offset - 0.5) % 12; // Move ants

                    antsCtx.setTransform(1, 0, 0, 1, 0, 0);
                    antsCtx.clearRect(0, 0, antsCanvas.width, antsCanvas.height);

                    let path = null;
                    let transform = { scale: 1, tx: 0, ty: 0 };

                    // Check cache first
                    const cached = getMarchingAntsPath();

                    if (cached && cached.path && cached.viewBox) {
                        path = cached.path;
                        const scale = cached.viewBox.w / viewBox.w;
                        const tx = (cached.viewBox.x - viewBox.x) * (antsCanvas.width / viewBox.w);
                        const ty = (cached.viewBox.y - viewBox.y) * (antsCanvas.height / viewBox.h);
                        transform = { scale, tx, ty };
                    } else if (selectionPath && selectionViewBox) {
                        path = selectionPath;
                        const scale = selectionViewBox.w / viewBox.w;
                        const tx = (selectionViewBox.x - viewBox.x) * (antsCanvas.width / viewBox.w);
                        const ty = (selectionViewBox.y - viewBox.y) * (antsCanvas.height / viewBox.h);
                        transform = { scale, tx, ty };

                        // Save to cache if not using cached
                        saveMarchingAntsPath(selectionPath, selectionViewBox);
                    }

                    if (path) {
                        antsCtx.save();
                        antsCtx.transform(transform.scale, 0, 0, transform.scale, transform.tx, transform.ty);

                        // For Wand 2 (outline selection), use thinner line that fits exactly on the outline
                        const lineWidth = (currentSelectionType === 'wand-2') ? (1 / transform.scale) : (2 / transform.scale);
                        const dashLength = (currentSelectionType === 'wand-2') ? (4 / transform.scale) : (6 / transform.scale);
                        const gapLength = (currentSelectionType === 'wand-2') ? (4 / transform.scale) : (6 / transform.scale);

                        // Draw White Dashes
                        antsCtx.strokeStyle = '#FFFFFF';
                        antsCtx.lineWidth = lineWidth;
                        antsCtx.setLineDash([dashLength, gapLength]);
                        antsCtx.lineDashOffset = (offset + gapLength) / transform.scale;
                        antsCtx.stroke(path);

                        // Draw Black Dashes
                        antsCtx.strokeStyle = (blackOutlineModeEnabled && currentSelectionType === 'wand-1') ? '#000000' : '#00FF00';
                        antsCtx.lineWidth = lineWidth;
                        antsCtx.setLineDash([dashLength, gapLength]);
                        antsCtx.lineDashOffset = offset / transform.scale;
                        antsCtx.stroke(path);

                        antsCtx.restore();
                    }

                    antsAnimationId = requestAnimationFrame(animate);
                };

                animate();
                updateWandButtonPosition();
            }
            // MODIFICATION: Now positions button only (history moved to color palette area)
            function updateWandButtonPosition() {
                // Hide button strictly if Wand 2 is active
                if (currentSelectionType === 'wand-2') {
                    wandToggleBtn.classList.remove('visible');
                    wandToggleBtn.style.display = 'none';
                    return;
                } else {
                    wandToggleBtn.style.display = ''; // Restore display if not Wand 2
                }

                if (!selectionBounds || !selectionViewBox || !antsCanvas) {
                    wandToggleBtn.classList.remove('visible');
                    wandPencilSliderContainer.classList.remove('visible'); // Hide slider in sidebar

                    wandToggleBtn.style.left = 'auto';
                    wandToggleBtn.style.top = 'auto';
                    wandToggleBtn.style.bottom = '1rem';
                    wandToggleBtn.style.right = '6rem';
                    return;
                }

                // Honor manual position if set
                if (wandBtnManualPos) {
                    wandToggleBtn.style.left = `${wandBtnManualPos.left}px`;
                    wandToggleBtn.style.top = `${wandBtnManualPos.top}px`;
                    wandToggleBtn.style.bottom = 'auto';
                    wandToggleBtn.style.right = 'auto';
                    wandToggleBtn.classList.add('visible');
                    wandPencilSliderContainer.classList.add('visible');
                    return;
                }
                try {
                    const boundPoint = { x: selectionBounds.maxX, y: selectionBounds.minY };

                    const scaleX = antsCanvas.width / viewBox.w;
                    const scaleY = antsCanvas.height / viewBox.h;

                    const selViewBoxScaleX = selectionMaskWidth ? (selectionMaskWidth / selectionViewBox.w) : (antsCanvas.width / selectionViewBox.w);
                    const selViewBoxScaleY = selectionMaskHeight ? (selectionMaskHeight / selectionViewBox.h) : (antsCanvas.height / selectionViewBox.h);

                    const svgPointX = (boundPoint.x / selViewBoxScaleX) + selectionViewBox.x;
                    const svgPointY = (boundPoint.y / selViewBoxScaleY) + selectionViewBox.y;

                    const screenX = (svgPointX - viewBox.x) * scaleX;
                    const screenY = (svgPointY - viewBox.y) * scaleY;

                    const btnRect = wandToggleBtn.getBoundingClientRect();

                    const offsetX = 32;
                    const buttonHeight = btnRect.height || 40;
                    const buttonWidth = btnRect.width || 40;

                    let finalBtnLeft = screenX + offsetX;
                    let finalBtnTop = screenY - (buttonHeight / 2);

                    const canvasParentWidth = canvasContainer.clientWidth;
                    const canvasParentHeight = canvasContainer.clientHeight;

                    // Constrain button
                    if (finalBtnLeft + buttonWidth > canvasParentWidth - 16) {
                        finalBtnLeft = canvasParentWidth - buttonWidth - 16;
                    }
                    if (finalBtnTop < 16) {
                        finalBtnTop = 16;
                    }
                    if (finalBtnTop + buttonHeight > canvasParentHeight - 16) {
                        finalBtnTop = canvasParentHeight - buttonHeight - 16;
                    }
                    if (finalBtnLeft < 16) {
                        finalBtnLeft = 16;
                    }

                    wandToggleBtn.style.left = `${finalBtnLeft}px`;
                    wandToggleBtn.style.top = `${finalBtnTop}px`;
                    wandToggleBtn.style.bottom = 'auto';
                    wandToggleBtn.style.right = 'auto';
                    wandToggleBtn.classList.add('visible');

                    // Show slider in sidebar
                    wandPencilSliderContainer.classList.add('visible');

                } catch (e) {
                    console.error("Error positioning wand button:", e);
                    // Fallback
                    wandToggleBtn.style.left = 'auto';
                    wandToggleBtn.style.top = 'auto';
                    wandToggleBtn.style.bottom = '1rem';
                    wandToggleBtn.style.right = '6rem';
                    wandToggleBtn.classList.add('visible');

                    wandPencilSliderContainer.classList.add('visible'); // Show slider in sidebar
                }
            }


            // Optimized SVG to canvas rendering with caching
            function getRenderedSvgImageData(forceRefresh = false) {
                // CRITICAL: Include viewBox in cache key to handle pan/zoom
                const viewBoxKey = `${viewBox.x.toFixed(0)}_${viewBox.y.toFixed(0)}_${viewBox.w.toFixed(0)}_${viewBox.h.toFixed(0)}`;
                const cacheKey = `svg_render_${drawingLayerVersion}_${viewBoxKey}_${referenceImage ? referenceImage.getAttribute('href').substring(0, 20) : 'noimg'}_${referenceImage ? referenceImage.getAttribute('opacity') : '1'}`;

                if (!forceRefresh && CACHE.imageDataCache[cacheKey]) {
                    return Promise.resolve(CACHE.imageDataCache[cacheKey]);
                }

                return new Promise((resolve, reject) => {
                    const rect = svgCanvas.getBoundingClientRect();

                    // Reuse canvas to reduce GC and allocation overhead
                    if (!renderCanvas) {
                        renderCanvas = document.createElement('canvas');
                    }
                    // Resize to match antsCanvas (logical pixels) to ensure alignment
                    if (renderCanvas.width !== antsCanvas.width || renderCanvas.height !== antsCanvas.height) {
                        renderCanvas.width = antsCanvas.width;
                        renderCanvas.height = antsCanvas.height;
                    }

                    if (!renderCtx) {
                        renderCtx = renderCanvas.getContext('2d', { willReadFrequently: true });
                    }

                    renderCtx.fillStyle = 'white';
                    renderCtx.fillRect(0, 0, renderCanvas.width, renderCanvas.height);

                    const xml = new XMLSerializer().serializeToString(svgCanvas);
                    const svg64 = btoa(unescape(encodeURIComponent(xml)));
                    const b64Start = 'data:image/svg+xml;base64,';
                    const image64 = b64Start + svg64;

                    const img = new Image();
                    img.onload = () => {
                        renderCtx.drawImage(img, 0, 0, renderCanvas.width, renderCanvas.height);
                        try {
                            const imageData = renderCtx.getImageData(0, 0, renderCanvas.width, renderCanvas.height);
                            CACHE.imageDataCache[cacheKey] = imageData;

                            // Limit cache size
                            const keys = Object.keys(CACHE.imageDataCache);
                            if (keys.length > 5) { // Keep fewer items as they are large
                                delete CACHE.imageDataCache[keys[0]];
                            }
                            resolve(imageData);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    img.onerror = () => {
                        reject(new Error("Failed to load SVG"));
                    };
                    img.src = image64;
                });
            }

            async function runMagicWand(screenX, screenY) {
                loader.classList.remove('hidden');
                // Only deselect if not in multi-wand mode (for continuous selection)
                if (!multiWandMode) {
                    deselect();
                }
                currentSelectionType = 'wand-1';

                // NEW: If auto color pick mode is enabled, detect color from rendered canvas
                if (autoColorPickMode && referenceImage) {
                    // Check cache first
                    const tolerance = parseFloat(allColorToleranceSlider.value);
                    const imageHash = getImageHash(referenceImage) + '_' + drawingLayerVersion + (wandWMode ? '_wandW' : '');
                    const cached = getWandMaskFromCache(screenX, screenY, tolerance, imageHash);

                    if (cached && cached.mask && cached.bounds) {
                        // Use cached result
                        selectionMask = cached.mask;
                        selectionMaskWidth = cached.width || (cached.imageData ? cached.imageData.width : antsCanvas.width);
                        selectionMaskHeight = cached.height || (cached.imageData ? cached.imageData.height : antsCanvas.height);
                        selectionBounds = cached.bounds;
                        selectionViewBox = { ...viewBox };

                        // If we have the cached rendered image data, pick the color at the clicked point
                        if (cached.imageData && cached.imageData.data) {
                            try {
                                const img = cached.imageData;
                                const { width, height, data } = img;
                                if (screenX >= 0 && screenX < width && screenY >= 0 && screenY < height) {
                                    const startIdx = (screenY * width + screenX) * 4;
                                    const r = data[startIdx], g = data[startIdx + 1], b = data[startIdx + 2];
                                    const hexColor = fastRgbToHex(r, g, b);
                                    selectColor(hexColor);
                                }
                            } catch (e) {
                                console.warn('Failed to pick color from cached imageData:', e);
                            }
                        }

                        const maskWidth = cached.width || (cached.imageData ? cached.imageData.width : antsCanvas.width);
                        const maskHeight = cached.height || (cached.imageData ? cached.imageData.height : antsCanvas.height);
                        selectionMaskWidth = maskWidth;
                        selectionMaskHeight = maskHeight;
                        generateSelectionPath(selectionMask, maskWidth, maskHeight);
                        // Ensure marching ants animation is started so the selection is visible
                        startMarchingAnts();

                        deselectBtn.classList.remove('hidden');
                        if (shortcutSelectionVisibilityBtn) shortcutSelectionVisibilityBtn.classList.remove('hidden'); // Show shortcut
                        // Turn on filter when selection is created
                        if (currentColorFilter !== 'none') {
                            toggleColorFilter(true);
                        }

                        // --- UPGRADED: Auto Stroke logic ---
                        if (autoStrokePathEnabled) {
                            await autoStroke(selectionMask, selectionMaskWidth, selectionMaskHeight, currentStrokeWidth, currentColor, selectionViewBox);
                            deselect(); // Clear selection immediately
                            loader.classList.add('hidden');
                            // Restore opacity
                            if (referenceImage) {
                                opacitySlider.value = savedTraceOpacity.toString();
                                referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                            }
                            // Return to Wand 1 (magic-wand) when Auto Stroke is enabled
                            switchTool('magic-wand');
                            return;
                        }
                        // ------------------------------------

                        loader.classList.add('hidden');
                        if (referenceImage) {
                            opacitySlider.value = savedTraceOpacity.toString();
                            referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                        }
                        // NEW: Auto-disable force black stroke for Wand 1 (color wand)
                        forceBlackStrokeEnabled = false;
                        if (forceBlackStrokeToggle) forceBlackStrokeToggle.checked = false;



                        switchTool('pencil');
                        return;
                    }

                    // Use cached SVG rendering if available
                    getRenderedSvgImageData().then(async imageData => {
                        try {
                            const { data, width, height } = imageData;
                            const startIdx = (screenY * width + screenX) * 4;

                            if (screenX < 0 || screenX >= width || screenY < 0 || screenY >= height || data[startIdx + 3] < 128) {
                                console.log("Wand clicked on transparent or off-bounds area.");
                                loader.classList.add('hidden');
                                // Restore opacity
                                if (referenceImage) {
                                    opacitySlider.value = savedTraceOpacity.toString();
                                    referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                                }
                                return;
                            }

                            // Get the color at clicked point
                            const startColor = [data[startIdx], data[startIdx + 1], data[startIdx + 2]];

                            // Convert to hex color and set as current color (use fast cached version)
                            const r = data[startIdx], g = data[startIdx + 1], b = data[startIdx + 2];
                            const hexColor = fastRgbToHex(r, g, b);
                            selectColor(hexColor);

                            const tolerance = parseFloat(allColorToleranceSlider.value);
                            selectionMask = new Uint8Array(width * height);
                            selectionMaskWidth = width;
                            selectionMaskHeight = height;

                            // === WAND W MODE: Precise shape-bounded selection with global same-color matching ===
                            if (wandWMode) {
                                // --- STEP 1: Build adaptive boundary map ---
                                const totalPixels = width * height;
                                const boundaryMap = new Uint8Array(totalPixels);

                                // Detect clicked color luma for adaptive thresholding
                                const ci_clicked = (screenY * width + screenX) * 4;
                                const startLuma = (data[ci_clicked] * 299 + data[ci_clicked + 1] * 587 + data[ci_clicked + 2] * 114) / 1000;

                                // Adaptive threshold: avoid treating the clicked color itself as a boundary if it's dark
                                // But still catch black lines (luma ~0-15)
                                let adaptiveLumaThreshold = 55;
                                if (startLuma < 70) {
                                    adaptiveLumaThreshold = Math.max(15, startLuma - 20); // Be strict if clicked on dark color
                                }

                                for (let i = 0; i < totalPixels; i++) {
                                    const ci = i * 4;
                                    if (data[ci + 3] < 50) continue;

                                    const luma = (data[ci] * 299 + data[ci + 1] * 587 + data[ci + 2] * 114) / 1000;

                                    // 1. Absolute dark check (Black lines)
                                    if (luma < adaptiveLumaThreshold) {
                                        boundaryMap[i] = 1;
                                        continue;
                                    }

                                    // 2. High-gradient edge detection (for anti-aliasing and colored outlines)
                                    // Only check pixels that could plausibly be edges (not too bright)
                                    if (luma < 130) {
                                        const x = i % width;
                                        const y = (i / width) | 0;
                                        if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {
                                            const nOffsets = [-width, -1, 1, width];
                                            let maxGrad = 0;
                                            for (let n = 0; n < 4; n++) {
                                                const ni = i + nOffsets[n];
                                                const nLuma = (data[ni * 4] * 299 + data[ni * 4 + 1] * 587 + data[ni * 4 + 2] * 114) / 1000;
                                                const grad = Math.abs(luma - nLuma);
                                                if (grad > maxGrad) maxGrad = grad;
                                            }
                                            // Scale gradient threshold by darkness
                                            const gradLimit = (luma < 60) ? 40 : 80;
                                            if (maxGrad > gradLimit) {
                                                boundaryMap[i] = 1;
                                            }
                                        }
                                    }
                                }

                                // --- STEP 2: Connected component labeling ---
                                // Label every non-boundary pixel with a component ID
                                const labels = new Int32Array(totalPixels); // 0 = unlabeled/boundary
                                let nextLabel = 1;
                                const cQueue = new Int32Array(totalPixels); // reusable BFS queue
                                // Store per-component info: average color + pixel count
                                const compInfoArr = [null]; // index 0 unused (labels start at 1)
                                const nDx = [1, -1, 0, 0];
                                const nDy = [0, 0, 1, -1];

                                for (let sy = 0; sy < height; sy++) {
                                    for (let sx = 0; sx < width; sx++) {
                                        const si = sy * width + sx;
                                        if (boundaryMap[si] === 1 || labels[si] !== 0) continue;

                                        // BFS flood fill for this component
                                        const label = nextLabel++;
                                        let cqH = 0, cqT = 0;
                                        cQueue[cqT++] = si;
                                        labels[si] = label;
                                        let tR = 0, tG = 0, tB = 0, cnt = 0;

                                        while (cqH < cqT) {
                                            const idx = cQueue[cqH++];
                                            const ci = idx * 4;
                                            tR += data[ci]; tG += data[ci + 1]; tB += data[ci + 2];
                                            cnt++;

                                            const cx = idx % width;
                                            const cy = (idx / width) | 0;

                                            // 4-connectivity neighbors
                                            for (let d = 0; d < 4; d++) {
                                                const nx = cx + nDx[d];
                                                const ny = cy + nDy[d];
                                                if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                                const ni = ny * width + nx;
                                                if (labels[ni] === 0 && boundaryMap[ni] === 0) {
                                                    labels[ni] = label;
                                                    cQueue[cqT++] = ni;
                                                }
                                            }
                                        }

                                        compInfoArr.push({
                                            r: cnt > 0 ? Math.round(tR / cnt) : 0,
                                            g: cnt > 0 ? Math.round(tG / cnt) : 0,
                                            b: cnt > 0 ? Math.round(tB / cnt) : 0,
                                            count: cnt
                                        });
                                    }
                                }

                                // --- STEP 3: Find clicked component ---
                                const clickIdx = screenY * width + screenX;
                                const clickLabel = labels[clickIdx];

                                if (clickLabel === 0) {
                                    // Clicked on boundary pixel
                                    showToast("Clicked on a boundary line. Click inside a shape.");
                                    loader.classList.add('hidden');
                                    if (referenceImage) {
                                        opacitySlider.value = savedTraceOpacity.toString();
                                        referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                                    }
                                    return;
                                }

                                // --- STEP 4: Find ALL components with the same average color ---
                                const clickedComp = compInfoArr[clickLabel];
                                const clickedLab = rgbToLab(clickedComp.r, clickedComp.g, clickedComp.b);
                                const tolSq = tolerance * tolerance;
                                const MIN_COMP_PIXELS = 8; // Skip tiny noise components
                                const matchingLabels = new Set();
                                matchingLabels.add(clickLabel); // Always include the clicked shape

                                for (let l = 1; l < compInfoArr.length; l++) {
                                    if (l === clickLabel) continue;
                                    const comp = compInfoArr[l];
                                    if (comp.count < MIN_COMP_PIXELS) continue; // skip noise
                                    const lab = rgbToLab(comp.r, comp.g, comp.b);
                                    const dL = clickedLab[0] - lab[0];
                                    const dA = clickedLab[1] - lab[1];
                                    const dB = clickedLab[2] - lab[2];
                                    if (dL * dL + dA * dA + dB * dB <= tolSq) {
                                        matchingLabels.add(l);
                                    }
                                }

                                // --- STEP 5: Build selection mask from all matching components ---
                                for (let i = 0; i < totalPixels; i++) {
                                    if (matchingLabels.has(labels[i])) {
                                        selectionMask[i] = 1;
                                    }
                                }
                            } else {
                                // === ORIGINAL MODE: Scan entire image for all matching colors ===
                                // OPTIMIZATION: Pre-calculate start color LAB
                                const startLab = rgbToLab(startColor[0], startColor[1], startColor[2]);
                                const toleranceSq = tolerance * tolerance;

                                // Calculate start color luminance to decide on boundary detection
                                const startLuma = (startColor[0] * 299 + startColor[1] * 587 + startColor[2] * 114) / 1000;
                                const isStartDark = startLuma < 60; // If start color is dark, don't exclude boundaries

                                // Use candidateMask directly to avoid large array allocation
                                const candidateMask = new Uint8Array(width * height);

                                // Optimization: Use single loop for color matching
                                for (let i = 0; i < width * height; i++) {
                                    const colorIdx = i * 4;
                                    // Check if pixel is opaque
                                    if (data[colorIdx + 3] > 128) {
                                        const r = data[colorIdx];
                                        const g = data[colorIdx + 1];
                                        const b = data[colorIdx + 2];

                                        // Fast Manhattan check
                                        const distManhattan = Math.abs(r - startColor[0]) + Math.abs(g - startColor[1]) + Math.abs(b - startColor[2]);
                                        if (distManhattan > 150) continue; // Skip obvious mismatches

                                        // Precise check
                                        const lab = rgbToLab(r, g, b);
                                        const dL = startLab[0] - lab[0];
                                        const dA = startLab[1] - lab[1];
                                        const dB = startLab[2] - lab[2];

                                        if (dL * dL + dA * dA + dB * dB <= toleranceSq) {
                                            candidateMask[i] = 1;
                                        }
                                    }
                                }

                                // Second pass: Smart flood fill that stops at black/dark boundaries
                                // Only apply if start color is NOT dark
                                if (!isStartDark) {
                                    // Mark boundaries
                                    const boundaryMask = new Uint8Array(width * height);
                                    for (let i = 0; i < width * height; i++) {
                                        if (candidateMask[i] === 1) { // Only check candidates to save time
                                            if (isBlackBoundary(data, i, width, height)) {
                                                boundaryMask[i] = 1;
                                            }
                                        }
                                    }

                                    // Remove boundaries from candidates
                                    for (let i = 0; i < width * height; i++) {
                                        if (boundaryMask[i] === 1) {
                                            candidateMask[i] = 0;
                                        }
                                    }
                                }

                                // Transfer candidates to selection mask
                                selectionMask.set(candidateMask);
                            }

                            // Calculate bounds
                            let minX = width, minY = height, maxX = 0, maxY = 0;
                            let hasSelection = false;
                            for (let y = 0; y < height; y++) {
                                for (let x = 0; x < width; x++) {
                                    if (selectionMask[y * width + x] === 1) {
                                        if (x < minX) minX = x;
                                        if (x > maxX) maxX = x;
                                        if (y < minY) minY = y;
                                        if (y > maxY) maxY = y;
                                        hasSelection = true;
                                    }
                                }
                            }

                            if (hasSelection) {
                                selectionBounds = { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 };
                                selectionViewBox = { ...viewBox };

                                // Save to cache
                                saveWandMaskToCache(screenX, screenY, tolerance, imageHash, selectionMask, imageData, selectionBounds, width, height);

                                generateSelectionPath(selectionMask, width, height);
                                startMarchingAnts();
                                deselectBtn.classList.remove('hidden');
                                if (shortcutSelectionVisibilityBtn) shortcutSelectionVisibilityBtn.classList.remove('hidden'); // Show shortcut
                                // Turn on filter when selection is created
                                if (currentColorFilter !== 'none') {
                                    toggleColorFilter(true);
                                }

                                // --- UPGRADED: Auto Stroke logic ---
                                if (autoStrokePathEnabled) {
                                    await autoStroke(selectionMask, width, height, currentStrokeWidth, currentColor, selectionViewBox);
                                    deselect(); // Clear selection immediately
                                    loader.classList.add('hidden');
                                    if (referenceImage) {
                                        opacitySlider.value = savedTraceOpacity.toString();
                                        referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                                    }
                                    // Return to Wand 1 (magic-wand) when Auto Stroke is enabled
                                    switchTool('magic-wand');
                                    return;
                                }
                                // ------------------------------------

                            } else {
                                showToast("No area selected.");
                            }

                            loader.classList.add('hidden');
                            if (referenceImage) {
                                opacitySlider.value = savedTraceOpacity.toString();
                                referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                            }
                            // NEW: Auto-disable force black stroke for Wand 1 (color wand)
                            forceBlackStrokeEnabled = false;
                            if (forceBlackStrokeToggle) forceBlackStrokeToggle.checked = false;

                            switchTool('pencil');

                        } catch (e) {
                            console.error("Error in auto color pick:", e);
                            loader.classList.add('hidden');
                            if (referenceImage) {
                                opacitySlider.value = savedTraceOpacity.toString();
                                referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                            }
                        }
                    }).catch(e => {
                        console.error("Error loading SVG:", e);
                        loader.classList.add('hidden');
                        // Restore opacity on error
                        if (referenceImage) {
                            opacitySlider.value = savedTraceOpacity.toString();
                            referenceImage.setAttribute('opacity', savedTraceOpacity.toString());
                        }
                    });
                    return; // Exit early, the async operation will continue
                }

                // Standard Magic Wand (Flood Fill)
                // Use cached SVG rendering if available
                getRenderedSvgImageData().then(async imageData => {
                    try {
                        const { data, width, height } = imageData;
                        const startIdx = (screenY * width + screenX) * 4;

                        if (screenX < 0 || screenX >= width || screenY < 0 || screenY >= height) {
                            console.warn("Wand click out of bounds");
                            loader.classList.add('hidden');
                            return;
                        }

                        const startColor = [data[startIdx], data[startIdx + 1], data[startIdx + 2], data[startIdx + 3]];

                        // NEW: Always pick the clicked color, even if auto-pick is off
                        const hexColor = fastRgbToHex(data[startIdx], data[startIdx + 1], data[startIdx + 2]);
                        selectColor(hexColor);

                        const tolerance = parseFloat(toleranceSlider.value);
                        const imageHash = (referenceImage ? getImageHash(referenceImage) : 'noimage') + '_' + drawingLayerVersion;

                        // Check cache
                        const cached = getWandMaskFromCache(screenX, screenY, tolerance, imageHash);
                        if (cached && cached.mask && cached.bounds) {
                            selectionMask = cached.mask;
                            selectionMaskWidth = cached.width || width;
                            selectionMaskHeight = cached.height || height;
                            selectionBounds = cached.bounds;
                            selectionViewBox = { ...viewBox };
                            generateSelectionPath(selectionMask, selectionMaskWidth, selectionMaskHeight);
                            startMarchingAnts();
                            deselectBtn.classList.remove('hidden');
                            // Turn on filter when selection is created
                            if (currentColorFilter !== 'none') {
                                toggleColorFilter(true);
                            }
                            loader.classList.add('hidden');

                            // --- UPGRADED: Auto Stroke logic ---
                            if (autoStrokePathEnabled) {
                                await autoStroke(selectionMask, selectionMaskWidth, selectionMaskHeight, currentStrokeWidth, currentColor, selectionViewBox);
                                deselect(); // Clear selection immediately
                                // Return to Wand 1 (magic-wand) when Auto Stroke is enabled
                                switchTool('magic-wand');
                                return;
                            }
                            // ------------------------------------

                            // NEW: Auto-disable force black stroke for Wand 1 (color wand)
                            forceBlackStrokeEnabled = false;
                            if (forceBlackStrokeToggle) forceBlackStrokeToggle.checked = false;

                            switchTool('pencil');
                            return;
                        }

                        selectionMask = new Uint8Array(width * height);

                        // Optimization: Use integer queue
                        const queue = new Int32Array(width * height);
                        let qHead = 0;
                        let qTail = 0;

                        const startPixelIdx = screenY * width + screenX;
                        queue[qTail++] = startPixelIdx;
                        selectionMask[startPixelIdx] = 1;

                        let processed = 0;
                        const maxProcess = width * height;

                        while (qHead < qTail) {
                            processed++;
                            if (processed > maxProcess) break;

                            const idx = queue[qHead++];
                            const x = idx % width;
                            const y = (idx / width) | 0;

                            // Check 4 neighbors
                            const neighbors = [
                                { idx: idx + 1, valid: x < width - 1 },
                                { idx: idx - 1, valid: x > 0 },
                                { idx: idx + width, valid: y < height - 1 },
                                { idx: idx - width, valid: y > 0 }
                            ];

                            for (let i = 0; i < 4; i++) {
                                const n = neighbors[i];
                                if (n.valid) {
                                    const nIdx = n.idx;
                                    if (selectionMask[nIdx] === 0) {
                                        // Handle color matching with perceptual accuracy (Delta E)
                                        const nColorIdx = nIdx * 4;
                                        const r = data[nColorIdx];
                                        const g = data[nColorIdx + 1];
                                        const b = data[nColorIdx + 2];
                                        const a = data[nColorIdx + 3];

                                        if (a < 128) {
                                            selectionMask[nIdx] = 2; // Visited, not selected
                                            continue;
                                        }

                                        // Use Delta E (CIE76) for better perceptual matching
                                        const dist = preciseColorDifference(startColor, [r, g, b]);

                                        if (dist <= tolerance) {
                                            selectionMask[nIdx] = 1; // Selected
                                            queue[qTail++] = nIdx;
                                        } else {
                                            selectionMask[nIdx] = 2; // Visited, not selected
                                        }
                                    }
                                }
                            }
                        }

                        // Calculate bounds
                        let minX = width, minY = height, maxX = 0, maxY = 0;
                        let hasSelection = false;
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (selectionMask[y * width + x] === 1) {
                                    if (x < minX) minX = x;
                                    if (x > maxX) maxX = x;
                                    if (y < minY) minY = y;
                                    if (y > maxY) maxY = y;
                                    hasSelection = true;
                                }
                            }
                        }

                        if (hasSelection) {
                            selectionBounds = { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 };
                            selectionViewBox = { ...viewBox };

                            // CRITICAL: Ensure state variables are set for Wand 1
                            currentSelectionType = 'wand-1';
                            selectionMaskWidth = width;
                            selectionMaskHeight = height;

                            saveWandMaskToCache(screenX, screenY, tolerance, imageHash, selectionMask, imageData, selectionBounds);

                            generateSelectionPath(selectionMask, width, height);
                            startMarchingAnts();
                            deselectBtn.classList.remove('hidden');
                            // Turn on filter when selection is created
                            if (currentColorFilter !== 'none') {
                                toggleColorFilter(true);
                            }

                            // Add selection to history
                            addHistoryState('selection');

                            // --- UPGRADED: Auto Stroke logic ---
                            if (autoStrokePathEnabled) {
                                await autoStroke(selectionMask, width, height, currentStrokeWidth, currentColor, selectionViewBox);
                                deselect(); // Clear selection immediately
                                loader.classList.add('hidden');
                                // Return to Wand 1 (magic-wand) when Auto Stroke is enabled
                                switchTool('magic-wand');
                                return;
                            }
                            // ------------------------------------
                        } else {
                            showToast("No area selected.");
                        }

                        loader.classList.add('hidden');

                        // NEW: Auto-disable force black stroke for Wand 1 (color wand)
                        forceBlackStrokeEnabled = false;
                        if (forceBlackStrokeToggle) forceBlackStrokeToggle.checked = false;



                        switchTool('pencil');

                    } catch (e) {
                        console.error("Error in magic wand:", e);
                        loader.classList.add('hidden');
                    }
                });
            }
            // --- END MAGIC WAND FUNCTIONS ---

            // --- NEW: MAGIC WAND 2 (GLOBAL OUTLINE SELECTION) ---
            function runMagicWandOutline(screenX, screenY) {
                loader.classList.remove('hidden');
                // Only deselect if not in multi-wand mode (for continuous selection)
                if (!multiWandMode) {
                    deselect();
                }
                currentSelectionType = 'wand-2';

                // Use rendered SVG (includes drawing + reference) for robust detection
                getRenderedSvgImageData().then(async imageData => {
                    try {
                        const { data, width, height } = imageData;
                        const mask = new Uint8Array(width * height);

                        // First pass: detect dark/black boundary pixels
                        for (let i = 0; i < width * height; i++) {
                            if (isBlackBoundary(data, i, width, height)) {
                                mask[i] = 1;
                            }
                        }

                        // Second pass: SMOOTH DILATION for robust outline selection
                        // Use shrinkSelectionMask with negative value for high-performance dilation
                        const dilated = shrinkSelectionMask(mask, width, height, -2);

                        // Compute bounds
                        let minX = width, minY = height, maxX = 0, maxY = 0;
                        let hasSelection = false;
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (dilated[y * width + x] === 1) {
                                    if (x < minX) minX = x;
                                    if (x > maxX) maxX = x;
                                    if (y < minY) minY = y;
                                    if (y > maxY) maxY = y;
                                    hasSelection = true;
                                }
                            }
                        }

                        if (!hasSelection) {
                            loader.classList.add('hidden');
                            showToast("No black outlines detected for Wand 2.");
                            return;
                        }

                        selectionMask = dilated;
                        outlineSelectionMask = dilated;
                        selectionMaskWidth = width;
                        selectionMaskHeight = height;
                        selectionBounds = { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 };
                        selectionViewBox = { ...viewBox };

                        // Build selection path + marching ants around all outlines using smooth contours
                        generateSmoothSelectionPath(selectionMask, width, height);
                        startMarchingAnts();
                        deselectBtn.classList.remove('hidden');
                        if (shortcutSelectionVisibilityBtn) shortcutSelectionVisibilityBtn.classList.remove('hidden'); // Show shortcut

                        // Add selection to history for undo/redo
                        addHistoryState('selection');

                        loader.classList.add('hidden');

                        // --- UPGRADED: Auto Stroke logic ---
                        if (autoStrokePathEnabled) {
                            await autoStroke(selectionMask, width, height, currentStrokeWidth, currentColor, selectionViewBox);
                            deselect(); // Clear selection immediately
                            // Return to Wand 2 (magic-wand-2) when Auto Stroke is enabled
                            switchTool('magic-wand-2');
                            return;
                        }
                        // ------------------------------------

                        // NEW: Auto-enable force black stroke for Wand 2 (outline wand)
                        forceBlackStrokeEnabled = true;
                        if (forceBlackStrokeToggle) forceBlackStrokeToggle.checked = true;

                        // NEW: Auto-disable auto color pick mode when Wand 2 is used
                        autoColorPickMode = false;
                        if (autoColorPickToggle) autoColorPickToggle.checked = false;

                        // NEW: Auto-disable trace lock when Wand 2 is used
                        traceLockCheckbox.checked = false;
                        drawingLayer.removeAttribute('mask');

                        // NEW: Auto-disable wet paint when Wand 2 is used
                        wetPaintEnabled = false;
                        if (wetPaintToolBtn) wetPaintToolBtn.classList.remove('active');

                        // After Wand 2 selection, automatically switch to Pencil 2
                        switchTool('pencil-2');

                        snapToOutlineEnabled = true;
                        if (snapToggle) {
                            snapToggle.checked = true;
                        }
                        if (snapStrengthContainer) {
                            snapStrengthContainer.style.display = 'block';
                        }
                        if (typeof snapStrength !== 'number' || snapStrength < 5) {
                            snapStrength = 8;
                        }
                        if (snapStrengthSlider) {
                            snapStrengthSlider.value = snapStrength;
                        }
                        if (snapStrengthValue) {
                            snapStrengthValue.textContent = `${snapStrength}px`;
                        }
                        if (typeof saveUiSettings === 'function') saveUiSettings();
                    } catch (e) {
                        console.error("Error in Wand 2 outline selection:", e);
                        loader.classList.add('hidden');
                    }
                }).catch(e => {
                    console.error("Error rendering SVG for Wand 2:", e);
                    loader.classList.add('hidden');
                });
            }

            // --- SMOOTH SELECTION PATH GENERATION ---
            // Helper function to generate smooth selection paths using marching squares
            function generateSmoothSelectionPath(mask, width, height) {
                // Marching squares algorithm to trace contours
                const contours = traceContours(mask, width, height);

                if (contours.length === 0) {
                    console.warn("No contours found in selection mask");
                    return;
                }

                let pathData = '';

                for (const contour of contours) {
                    if (contour.length < 3) continue;

                    // Apply advanced smoothing with Catmull-Rom splines
                    const smoothed = smoothContour(contour, 0.5);

                    // Use pixel coordinates directly (do not convert to SVG coordinates here)
                    const points = smoothed;

                    // Generate smooth path using cubic Bzier curves for professional results
                    if (points.length > 0) {
                        pathData += `M ${points[0].x} ${points[0].y} `;

                        // Use cubic Bzier curves for ultra-smooth contours
                        for (let i = 1; i < points.length; i++) {
                            const p0 = points[i - 1];
                            const p1 = points[i];
                            const p2 = points[(i + 1) % points.length];
                            const p3 = points[(i + 2) % points.length];

                            // Calculate control points using centripetal Catmull-Rom
                            // This creates smooth, flowing curves without overshoot
                            const alpha = 0.25; // Centripetal parameter

                            // Calculate distances (centripetal parameterization)
                            const d01 = Math.pow(
                                Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2),
                                alpha
                            );
                            const d12 = Math.pow(
                                Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2),
                                alpha
                            );
                            const d23 = Math.pow(
                                Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2),
                                alpha
                            );

                            // Calculate Catmull-Rom control points
                            const t1 = 0.15; // Control point tightness (lower = tighter curves)

                            const cp1x = p1.x + t1 * ((p1.x - p0.x) / (d01 + 0.0001) - (p2.x - p0.x) / (d01 + d12 + 0.0001));
                            const cp1y = p1.y + t1 * ((p1.y - p0.y) / (d01 + 0.0001) - (p2.y - p0.y) / (d01 + d12 + 0.0001));

                            const cp2x = p2.x - t1 * ((p2.x - p1.x) / (d12 + 0.0001) - (p3.x - p1.x) / (d12 + d23 + 0.0001));
                            const cp2y = p2.y - t1 * ((p2.y - p1.y) / (d12 + 0.0001) - (p3.y - p1.y) / (d12 + d23 + 0.0001));

                            pathData += `C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y} `;
                        }

                        pathData += 'Z ';
                    }
                }

                // Store the path for marching ants animation
                selectionPath = new Path2D(pathData);
                currentSelectionPathData = pathData;

                // Generate clip path for drawing restriction
                updateSelectionClipPath(mask, width, height, pathData);

                // Save marching ants path to cache
                if (selectionViewBox) {
                    saveMarchingAntsPath(selectionPath, selectionViewBox);
                }
            }

            // Marching squares contour tracing
            function traceContours(mask, width, height) {
                const visited = new Uint8Array(width * height);
                const contours = [];

                // Find all contour starting points
                for (let y = 0; y < height - 1; y++) {
                    for (let x = 0; x < width - 1; x++) {
                        const idx = y * width + x;

                        // Check if this is a boundary pixel (has at least one empty neighbor)
                        if (mask[idx] === 1 && !visited[idx]) {
                            const hasEmptyNeighbor =
                                (x > 0 && mask[idx - 1] === 0) ||
                                (x < width - 1 && mask[idx + 1] === 0) ||
                                (y > 0 && mask[idx - width] === 0) ||
                                (y < height - 1 && mask[idx + width] === 0);

                            if (hasEmptyNeighbor) {
                                const contour = traceContour(mask, width, height, x, y, visited);
                                if (contour.length > 2) {
                                    contours.push(contour);
                                }
                            }
                        }
                    }
                }

                return contours;
            }

            // Trace a single contour starting from (startX, startY)
            function traceContour(mask, width, height, startX, startY, visited) {
                const contour = [];
                let x = startX;
                let y = startY;
                let dir = 0; // 0=right, 1=down, 2=left, 3=up

                const dx = [1, 0, -1, 0];
                const dy = [0, 1, 0, -1];

                const maxSteps = width * height; // Safety limit
                let steps = 0;

                do {
                    contour.push({ x: x + 0.5, y: y + 0.5 }); // Center of pixel
                    const idx = y * width + x;
                    visited[idx] = 1;

                    // Find next direction using Moore neighborhood
                    let found = false;
                    for (let i = 0; i < 4; i++) {
                        const newDir = (dir + 3 + i) % 4; // Turn left first, then straight, then right
                        const nx = x + dx[newDir];
                        const ny = y + dy[newDir];

                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nidx = ny * width + nx;
                            if (mask[nidx] === 1) {
                                x = nx;
                                y = ny;
                                dir = newDir;
                                found = true;
                                break;
                            }
                        }
                    }

                    if (!found) break;

                    steps++;
                    if (steps > maxSteps) break;

                } while (x !== startX || y !== startY);

                return contour;
            }

            // Smooth contour using advanced Catmull-Rom splines with simplification
            function smoothContour(contour, smoothing = 0.5) {
                if (contour.length < 3) return contour;

                // Step 1: Apply Gaussian-like smoothing multiple passes for professional curves
                let current = [...contour];
                const iterations = 3; // More iterations for better smoothing
                const smoothingFactor = 0.6; // Stronger smoothing

                for (let iter = 0; iter < iterations; iter++) {
                    const temp = [];
                    for (let i = 0; i < current.length; i++) {
                        const prev = current[(i - 1 + current.length) % current.length];
                        const curr = current[i];
                        const next = current[(i + 1) % current.length];

                        // Weighted average: center point has more weight
                        temp.push({
                            x: curr.x * (1 - smoothingFactor) + (prev.x + next.x) * smoothingFactor / 2,
                            y: curr.y * (1 - smoothingFactor) + (prev.y + next.y) * smoothingFactor / 2
                        });
                    }
                    current = temp;
                }

                // Step 2: Apply Douglas-Peucker simplification to remove redundant points
                // This creates clean, flowing curves by removing zig-zags
                const simplified = douglasPeucker(current, 0.5); // epsilon = 0.5 pixels

                // Step 3: Final Catmull-Rom spline interpolation for ultra-smooth curves
                const interpolated = catmullRomInterpolation(simplified, 8); // 8 points per segment

                return interpolated;
            }

            // Douglas-Peucker algorithm for curve simplification
            function douglasPeucker(points, epsilon) {
                if (points.length < 3) return points;

                let maxDist = 0;
                let maxIdx = 0;

                // Find point with maximum distance from line segment
                for (let i = 1; i < points.length - 1; i++) {
                    const dist = pointToLineDistance(points[i], points[0], points[points.length - 1]);
                    if (dist > maxDist) {
                        maxDist = dist;
                        maxIdx = i;
                    }
                }

                // If max distance is greater than epsilon, recursively simplify
                if (maxDist > epsilon) {
                    const left = douglasPeucker(points.slice(0, maxIdx + 1), epsilon);
                    const right = douglasPeucker(points.slice(maxIdx), epsilon);
                    return left.slice(0, -1).concat(right);
                } else {
                    return [points[0], points[points.length - 1]];
                }
            }

            // Calculate perpendicular distance from point to line
            function pointToLineDistance(point, lineStart, lineEnd) {
                const dx = lineEnd.x - lineStart.x;
                const dy = lineEnd.y - lineStart.y;
                const len2 = dx * dx + dy * dy;

                if (len2 === 0) {
                    return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);
                }

                let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / len2;
                t = Math.max(0, Math.min(1, t));

                const nearestX = lineStart.x + t * dx;
                const nearestY = lineStart.y + t * dy;

                return Math.sqrt((point.x - nearestX) ** 2 + (point.y - nearestY) ** 2);
            }

            // Catmull-Rom spline interpolation for ultra-smooth curves
            function catmullRomInterpolation(points, pointsPerSegment) {
                if (points.length < 4) return points; // Need at least 4 points for Catmull-Rom

                const interpolated = [];
                const n = points.length;

                for (let i = 0; i < n; i++) {
                    const p0 = points[(i - 1 + n) % n];
                    const p1 = points[i];
                    const p2 = points[(i + 1) % n];
                    const p3 = points[(i + 2) % n];

                    for (let t = 0; t < 1; t += 1 / pointsPerSegment) {
                        const t2 = t * t;
                        const t3 = t2 * t;

                        // Catmull-Rom basis functions
                        const q = 0.5 * (
                            (2 * p1.x) +
                            (-p0.x + p2.x) * t +
                            (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                            (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3
                        );

                        const r = 0.5 * (
                            (2 * p1.y) +
                            (-p0.y + p2.y) * t +
                            (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                            (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3
                        );

                        interpolated.push({ x: q, y: r });
                    }
                }

                return interpolated;
            }


            // --- PAINT BUCKET FUNCTIONS ---
            function runPaintBucket(screenX, screenY) {
                loader.classList.remove('hidden');

                // === NEW: Auto-fill ALL same-color regions when autoColorPickMode + wand-1 selection ===
                // When the user used Wand 1 in auto color pick mode, the selectionMask already
                // contains ALL regions of the same color across the entire image.
                // So when paint bucket is used, fill ALL those regions at once instead of just one.
                if (autoColorPickMode && currentSelectionType === 'wand-1' && selectionMask && selectionViewBox) {
                    try {
                        const maskWidth = selectionMaskWidth;
                        const maskHeight = selectionMaskHeight;

                        // Use the entire wand selection mask as the fill mask
                        let finalMask = new Uint8Array(selectionMask.length);
                        for (let i = 0; i < selectionMask.length; i++) {
                            finalMask[i] = selectionMask[i] === 1 ? 1 : 0;
                        }

                        // Apply shrink if configured
                        if (fillShrinkAmount !== 0) {
                            finalMask = shrinkSelectionMask(finalMask, maskWidth, maskHeight, fillShrinkAmount);
                        }

                        // Check if we have any pixels to fill
                        let hasPixels = false;
                        for (let i = 0; i < finalMask.length; i++) {
                            if (finalMask[i] === 1) {
                                hasPixels = true;
                                break;
                            }
                        }

                        if (!hasPixels) {
                            loader.classList.add('hidden');
                            showToast("No area to fill from wand selection.");
                            return;
                        }

                        // Create SVG path from the entire selection mask using the selection's viewBox
                        const path = createFillPath(finalMask, maskWidth, maskHeight, selectionViewBox);

                        if (path) {
                            const fillPath = createSvgElement('path', {
                                'd': path,
                                'fill': blackOutlineModeEnabled ? '#000000' : currentColor,
                                'fill-opacity': currentStrokeOpacity,
                                'fill-rule': 'evenodd',
                                'stroke': 'none',
                                'style': 'pointer-events: none;'
                            });

                            // Apply clip path if selection is active
                            if (currentSelectionClipPathId) {
                                fillPath.setAttribute('clip-path', `url(#${currentSelectionClipPathId})`);
                            }

                            // Always insert fills BEFORE the strokes layer so they stay behind
                            if (maskedStrokesLayer) {
                                drawingLayer.insertBefore(fillPath, maskedStrokesLayer);
                            } else {
                                drawingLayer.appendChild(fillPath);
                            }
                            importedSvgPaths.push(fillPath);

                            // Apply filter if enabled
                            if (filterEnabled && currentColorFilter !== 'none') {
                                const filterCSS = getFilterCSS(currentColorFilter);
                                fillPath.style.filter = filterCSS;
                            }
                            addHistoryState('drawing');
                            showToast("Filled all same-color regions!");
                        } else {
                            showToast("Could not create fill path from wand selection.");
                        }

                        loader.classList.add('hidden');
                        return;
                    } catch (e) {
                        console.error("Error in auto-fill-all:", e);
                        loader.classList.add('hidden');
                        // Fall through to standard fill as fallback
                    }
                }
                // === END: Auto-fill ALL same-color regions ===

                // Check cache first
                const fillColor = hexToRgb(currentColor);
                const tolerance = 30; // Fixed tolerance for color matching
                const imageHash = (referenceImage ? getImageHash(referenceImage) : 'noimage') + '_' + drawingLayerVersion;
                const cached = getFillFromCache(screenX, screenY, currentColor, tolerance, imageHash);

                if (cached && cached.mask && cached.path) {
                    // Use cached fill
                    try {
                        const fillPath = cached.path;
                        if (fillPath && fillPath.setAttribute) {
                            fillPath.setAttribute('fill', currentColor);
                            fillPath.setAttribute('fill-opacity', currentStrokeOpacity);
                            drawingLayer.appendChild(fillPath);
                            importedSvgPaths.push(fillPath);
                            // Apply filter if enabled
                            if (filterEnabled && currentColorFilter !== 'none') {
                                const filterCSS = getFilterCSS(currentColorFilter);
                                fillPath.style.filter = filterCSS;
                            }
                            addHistoryState('drawing');
                            loader.classList.add('hidden');
                            return;
                        }
                    } catch (e) {
                        console.warn("Failed to use cached fill, recalculating:", e);
                        // Fall through to recalculate
                    }
                }

                // Use cached SVG rendering if available
                getRenderedSvgImageData().then(imageData => {
                    try {
                        const { data, width, height } = imageData;
                        const startPixelIdx = screenY * width + screenX;
                        const startIdx = startPixelIdx * 4;
                        const startColor = [data[startIdx], data[startIdx + 1], data[startIdx + 2], data[startIdx + 3]];

                        // Use tolerance from slider
                        const userTolerance = parseInt(toleranceSlider.value) || 30;
                        const toleranceSq = userTolerance * userTolerance;

                        // Create a mask for the fill area: 0=unvisited, 1=matched, 2=visited-no-match
                        const fillMask = new Uint8Array(width * height);

                        const queue = new Int32Array(width * height);
                        let qHead = 0;
                        let qTail = 0;

                        queue[qTail++] = startPixelIdx;
                        fillMask[startPixelIdx] = 1;

                        const maxProcess = width * height;
                        let processed = 0;

                        while (qHead < qTail && processed < maxProcess) {
                            processed++;
                            const idx = queue[qHead++];
                            const x = idx % width;
                            const y = (idx / width) | 0;

                            // 4-way neighbors
                            const nIdxs = [
                                x < width - 1 ? idx + 1 : -1,
                                x > 0 ? idx - 1 : -1,
                                y < height - 1 ? idx + width : -1,
                                y > 0 ? idx - width : -1
                            ];

                            for (let i = 0; i < 4; i++) {
                                const nIdx = nIdxs[i];
                                if (nIdx !== -1 && fillMask[nIdx] === 0) {
                                    const nColorIdx = nIdx * 4;
                                    const r = data[nColorIdx];
                                    const g = data[nColorIdx + 1];
                                    const b = data[nColorIdx + 2];
                                    const a = data[nColorIdx + 3];

                                    // Check distance including Alpha for better boundary detection
                                    const dr = startColor[0] - r;
                                    const dg = startColor[1] - g;
                                    const db = startColor[2] - b;
                                    const da = startColor[3] - a;

                                    // Use weighted Euclidean for slightly better results or standard
                                    const distSq = dr * dr + dg * dg + db * db + da * da;

                                    if (distSq <= toleranceSq * 4) { // *4 because we have 4 components now
                                        fillMask[nIdx] = 1; // Match
                                        queue[qTail++] = nIdx;
                                    } else {
                                        fillMask[nIdx] = 2; // Visited, no match
                                    }
                                }
                            }
                        }

                        // Convert fill mask to final mask (only 1s)
                        let finalMask = fillMask.map(v => v === 1 ? 1 : 0);

                        // Apply shrink to the fill mask (similar to selection shrink)
                        if (fillShrinkAmount !== 0) {
                            finalMask = shrinkSelectionMask(finalMask, width, height, fillShrinkAmount);
                        }

                        // Check if we have any pixels to fill
                        let hasPixels = false;
                        for (let i = 0; i < finalMask.length; i++) {
                            if (finalMask[i] === 1) {
                                hasPixels = true;
                                break;
                            }
                        }

                        if (!hasPixels) {
                            loader.classList.add('hidden');
                            showToast("No area to fill at this point.");
                            return;
                        }

                        // Create SVG path from the fill mask
                        const path = createFillPath(finalMask, width, height, viewBox);

                        if (path) {
                            // Create a filled path element
                            const fillPath = createSvgElement('path', {
                                'd': path,
                                'fill': blackOutlineModeEnabled ? '#000000' : currentColor,
                                'fill-opacity': currentStrokeOpacity,
                                'fill-rule': 'evenodd',
                                'stroke': 'none',
                                'style': 'pointer-events: none;'
                            });

                            // Apply clip path if selection is active
                            if (selectionMask && currentSelectionClipPathId) {
                                fillPath.setAttribute('clip-path', `url(#${currentSelectionClipPathId})`);
                            }

                            // Save to cache
                            saveFillToCache(screenX, screenY, currentColor, tolerance, imageHash, finalMask, fillPath.cloneNode(true));

                            // Always insert fills BEFORE the strokes layer so they stay behind
                            if (maskedStrokesLayer) {
                                drawingLayer.insertBefore(fillPath, maskedStrokesLayer);
                            } else {
                                drawingLayer.appendChild(fillPath);
                            }
                            importedSvgPaths.push(fillPath);
                            // Apply filter if enabled
                            if (filterEnabled && currentColorFilter !== 'none') {
                                const filterCSS = getFilterCSS(currentColorFilter);
                                fillPath.style.filter = filterCSS;
                            }
                            addHistoryState('drawing');
                        } else {
                            showToast("Could not create fill path.");
                        }

                        loader.classList.add('hidden');
                    } catch (e) {
                        console.error("Error in paint bucket:", e);
                        loader.classList.add('hidden');
                    }
                }).catch(e => {
                    console.error("Error loading SVG for paint bucket:", e);
                    loader.classList.add('hidden');
                });
            }

            function hexToRgb(hex) {
                // Use fast cached version
                const cached = fastHexToRgb(hex);
                return [cached.r, cached.g, cached.b];
            }

            // Optimized Create Fill Path using Marching Squares for clean vector output
            function createFillPath(mask, width, height, viewBox) {
                // Generate clean contours using Marching Squares
                const contours = getContoursFromMask(mask, width, height);
                if (contours.length === 0) return null;

                const scaleX = viewBox.w / width;
                const scaleY = viewBox.h / height;
                let pathData = "";

                // Helper to round coordinates for space efficiency
                const r = (n) => Math.round(n * 10) / 10;

                contours.forEach(contour => {
                    if (contour.length < 3) return;

                    // Simplify the contour to reduce node count while maintaining shape
                    const simplified = simplifyPath(contour, 0.4);
                    if (simplified.length < 3) return;

                    pathData += `M${r(viewBox.x + simplified[0].x * scaleX)},${r(viewBox.y + simplified[0].y * scaleY)}`;
                    for (let i = 1; i < simplified.length; i++) {
                        pathData += ` L${r(viewBox.x + simplified[i].x * scaleX)},${r(viewBox.y + simplified[i].y * scaleY)}`;
                    }
                    pathData += " Z ";
                });

                return pathData.trim() || null;
            }

            // === INTELLIGENT AUTO FILL ALL COLORS FUNCTION ===
            // Rewritten to match user request: Ref-guided logic with leak detection
            // - Removes temporary strokes (only fill remains)
            // - Picks dominant color (60-70% rule) ignoring shade/noise via HSL binning
            async function runAutoFill() {
                if (!referenceImage) {
                    showToast("Auto Fill requires a reference image. Load one first.");
                    return;
                }

                loader.classList.remove('hidden');
                showToast("Auto Fill: Analyzing...");

                // Yield to UI to show toast
                await new Promise(r => requestAnimationFrame(r));
                await new Promise(r => setTimeout(r, 50));

                try {
                    // 1. Get DRAWING Data (simulate what the paint bucket sees)
                    // Hide Ref image temporarily
                    const refOpacity = referenceImage.getAttribute('opacity');
                    const refDisplay = referenceImage.style.display;
                    referenceImage.setAttribute('opacity', '0');
                    referenceImage.style.display = 'none';

                    const drawingImageData = await getRenderedSvgImageData(true);

                    // Restore Ref
                    referenceImage.setAttribute('opacity', refOpacity);
                    referenceImage.style.display = refDisplay;

                    // 2. Get REFERENCE Data (to find color regions)
                    // Hide Drawing layer temporarily
                    const drawingDisplay = drawingLayer.style.display;
                    drawingLayer.style.display = 'none';
                    const refImageData = await getRenderedSvgImageData(true);
                    drawingLayer.style.display = drawingDisplay;

                    const width = drawingImageData.width;
                    const height = drawingImageData.height;
                    const dData = drawingImageData.data; // Drawing pixels
                    const rData = refImageData.data;     // Reference pixels

                    // 3. Segment Reference Image
                    const visited = new Uint8Array(width * height);
                    const regions = [];
                    // Use standard tolerance or a specific one for auto-fill
                    const tolerance = parseFloat(toleranceSlider.value) || 30;

                    // Optimization: Scan grid with step
                    const step = 2;

                    for (let y = 0; y < height; y += step) {
                        for (let x = 0; x < width; x += step) {
                            const idx = y * width + x;
                            if (visited[idx]) continue;

                            const r = rData[idx * 4];
                            const g = rData[idx * 4 + 1];
                            const b = rData[idx * 4 + 2];
                            const a = rData[idx * 4 + 3];

                            // Skip transparent areas in reference
                            if (a < 50) {
                                visited[idx] = 1;
                                continue;
                            }

                            // Start Region Extraction (Flood Fill)
                            const mask = new Uint8Array(width * height);
                            const q = [idx];
                            visited[idx] = 1;
                            mask[idx] = 1;

                            let minX = x, maxX = x, minY = y, maxY = y;
                            let count = 0;
                            const startColor = { r, g, b }; // Seed color

                            while (q.length > 0) {
                                const curr = q.pop();
                                const cx = curr % width;
                                const cy = (curr / width) | 0;

                                if (cx < minX) minX = cx;
                                if (cx > maxX) maxX = cx;
                                if (cy < minY) minY = cy;
                                if (cy > maxY) maxY = cy;
                                count++;

                                // Check neighbors
                                const neighbors = [curr - 1, curr + 1, curr - width, curr + width];

                                for (const n of neighbors) {
                                    if (n < 0 || n >= width * height) continue;
                                    // Wrap check
                                    const nx = n % width;
                                    if (Math.abs(nx - cx) > 1) continue;

                                    if (visited[n]) continue;

                                    const nr = rData[n * 4];
                                    const ng = rData[n * 4 + 1];
                                    const nb = rData[n * 4 + 2];
                                    const na = rData[n * 4 + 3];

                                    if (na < 50) {
                                        visited[n] = 1;
                                        continue;
                                    }

                                    // Color Distance check
                                    const diff = Math.abs(nr - startColor.r) + Math.abs(ng - startColor.g) + Math.abs(nb - startColor.b);
                                    if (diff < tolerance * 3) { // *3 for loose RGB sum tolerance
                                        visited[n] = 1;
                                        mask[n] = 1;
                                        q.push(n);
                                    }
                                }
                            }

                            if (count > 40) { // Minimum region size to care about
                                regions.push({
                                    mask,
                                    bounds: { minX, maxX, minY, maxY, width: maxX - minX + 1, height: maxY - minY + 1 },
                                    count,
                                    seed: { x, y }
                                });
                            }
                        }
                    }

                    showToast(`Found ${regions.length} regions. Filling...`);
                    await new Promise(r => setTimeout(r, 10)); // Yield

                    // 4. Process Each Region
                    let fillsAdded = 0;
                    const fragments = document.createDocumentFragment();
                    const currentVB = { ...viewBox };

                    for (const region of regions) {
                        try {
                            // --- IMPROVED COLOR ANALYSIS (Ignore Shade/Noise/Outlines) ---
                            // 1. Bin pixels by Hue (12 bins) to find "character" color
                            // 2. Exclude extremes (outlines, highlights) to find "True" dominant color
                            const colorBins = new Map(); // Key -> { count, sumR, sumG, sumB }
                            let totalValidPixels = 0;

                            for (let i = 0; i < width * height; i++) {
                                if (!region.mask[i]) continue;

                                const r = rData[i * 4];
                                const g = rData[i * 4 + 1];
                                const b = rData[i * 4 + 2];
                                const a = rData[i * 4 + 3];

                                // Skip transparent and near-transparent
                                if (a < 128) continue;

                                // Convert to HSL for better analysis
                                const max = Math.max(r, g, b);
                                const min = Math.min(r, g, b);
                                const l = (max + min) / 2 / 255;

                                // CRITICAL: Skip pixels that are likely outlines (very dark) or noise (very light)
                                if (l < 0.15 || l > 0.95) continue;

                                totalValidPixels++;

                                const d = max - min;
                                const s = max === min ? 0 : l > 0.5 ? d / (510 - max - min) : d / (max + min);

                                let h = 0;
                                if (max !== min) {
                                    switch (max) {
                                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                        case g: h = (b - r) / d + 2; break;
                                        case b: h = (r - g) / d + 4; break;
                                    }
                                    h /= 6;
                                }

                                // Construct Bin Key
                                let key;
                                if (s < 0.12) { // Achromatic (Gray/Black/White)
                                    // Group all neutrals together to find if the region is "Gray" overall
                                    key = "neutral";
                                } else {
                                    // Chromatic: Bin by Hue (12 bins = 30 degrees each)
                                    // We ignore L and S to find the dominant "Base Color" ignoring shades
                                    key = `hue-${Math.round(h * 12) % 12}`;
                                }

                                if (!colorBins.has(key)) colorBins.set(key, { count: 0, sumR: 0, sumG: 0, sumB: 0 });
                                const bin = colorBins.get(key);
                                bin.count++;
                                bin.sumR += r;
                                bin.sumG += g;
                                bin.sumB += b;
                            }

                            // Find the most represented bin
                            let dominantColor = null;
                            let maxBinCount = 0;
                            let winnerBin = null;

                            for (const [key, bin] of colorBins.entries()) {
                                if (bin.count > maxBinCount) {
                                    maxBinCount = bin.count;
                                    winnerBin = bin;
                                }
                            }

                            // Calculate the average color of the WINNING bin
                            if (winnerBin) {
                                dominantColor = {
                                    r: Math.round(winnerBin.sumR / winnerBin.count),
                                    g: Math.round(winnerBin.sumG / winnerBin.count),
                                    b: Math.round(winnerBin.sumB / winnerBin.count)
                                };
                            }

                            if (!dominantColor) continue; // Skip if no color determination possible

                            const regionHex = fastRgbToHex(dominantColor.r, dominantColor.g, dominantColor.b);


                            // --- LEAK DETECTION & FILL ---
                            // Find a valid seed point inside the mask
                            let validSeed = null;
                            // Search near the center first
                            const cx = Math.floor((region.bounds.minX + region.bounds.maxX) / 2);
                            const cy = Math.floor((region.bounds.minY + region.bounds.maxY) / 2);
                            const centerIdx = cy * width + cx;

                            if (region.mask[centerIdx]) {
                                const da = dData[centerIdx * 4 + 3];
                                const dr = dData[centerIdx * 4];
                                if (da < 100 || dr > 200) validSeed = centerIdx;
                            }

                            if (validSeed === null) {
                                // Scan bounding box for any valid seed
                                for (let iy = region.bounds.minY; iy <= region.bounds.maxY; iy++) {
                                    for (let ix = region.bounds.minX; ix <= region.bounds.maxX; ix++) {
                                        const i = iy * width + ix;
                                        if (region.mask[i]) {
                                            // Check if drawing is clear (not black line)
                                            const dr = dData[i * 4];
                                            const dg = dData[i * 4 + 1];
                                            const db = dData[i * 4 + 2];
                                            const da = dData[i * 4 + 3];

                                            // Valid fill spot is transparent OR light color
                                            if (da < 100 || (dr > 200 && dg > 200 && db > 200)) {
                                                validSeed = i;
                                                break;
                                            }
                                        }
                                    }
                                    if (validSeed) break;
                                }
                            }

                            let leaked = false;

                            if (validSeed === null) {
                                leaked = true;
                            } else {
                                // Simulate Flood Fill on Drawing
                                const margin = 20;
                                const boundMinX = Math.max(0, region.bounds.minX - margin);
                                const boundMaxX = Math.min(width - 1, region.bounds.maxX + margin);
                                const boundMinY = Math.max(0, region.bounds.minY - margin);
                                const boundMaxY = Math.min(height - 1, region.bounds.maxY + margin);

                                const drawMask = new Uint8Array(width * height);
                                const q = [validSeed];
                                drawMask[validSeed] = 1;

                                while (q.length > 0) {
                                    const curr = q.pop();
                                    const cx = curr % width;
                                    const cy = (curr / width) | 0;

                                    // Leak Detection
                                    if (cx < boundMinX || cx > boundMaxX || cy < boundMinY || cy > boundMaxY) {
                                        leaked = true;
                                        break;
                                    }

                                    const neighbors = [curr - 1, curr + 1, curr - width, curr + width];
                                    for (const n of neighbors) {
                                        if (n < 0 || n >= width * height) continue;
                                        const nx = n % width;
                                        if (Math.abs(nx - cx) > 1) continue;

                                        if (drawMask[n]) continue;

                                        // Bound check (Drawing Lines)
                                        const da = dData[n * 4 + 3];
                                        if (da > 100) {
                                            const dr = dData[n * 4];
                                            if (dr < 200) continue;
                                        }

                                        drawMask[n] = 1;
                                        q.push(n);
                                    }
                                }

                                if (!leaked) {
                                    region.mask = drawMask; // Use drawn shape
                                }
                            }

                            // Generate Output
                            // Slight dilation for better fit
                            const finalMask = shrinkSelectionMask(region.mask, width, height, -1.0);
                            const pathData = createFillPath(finalMask, width, height, currentVB);

                            if (pathData) {
                                // Add Fill ONLY (Temporary stroke removed per user request)
                                const fillPath = createSvgElement('path', {
                                    'd': pathData.trim(),
                                    'fill': regionHex,
                                    'fill-opacity': currentStrokeOpacity.toString(),
                                    'fill-rule': 'evenodd',
                                    'stroke': 'none',
                                    'style': 'pointer-events: none;',
                                    'data-auto-fill': 'true',
                                    'data-auto-fill-color': regionHex
                                });

                                if (currentColorFilter !== 'none') {
                                    fillPath.style.filter = getFilterCSS(currentColorFilter);
                                }

                                fragments.appendChild(fillPath);
                                fillsAdded++;
                            }

                        } catch (err) {
                            console.warn("Region processing error:", err);
                        }
                    }

                    // Batch update DOM
                    if (maskedStrokesLayer) {
                        drawingLayer.insertBefore(fragments, maskedStrokesLayer);
                    } else {
                        drawingLayer.appendChild(fragments);
                    }

                    if (fillsAdded > 0) {
                        addHistoryState('drawing');
                        showToast(`Auto Fill: ${fillsAdded} regions filled.`);
                    } else {
                        showToast("Auto Fill: No regions filled.");
                    }

                } catch (e) {
                    console.error("Auto Fill Error:", e);
                    showToast("Failed: " + e.message, true);
                } finally {
                    loader.classList.add('hidden');
                }
            }
            // === END INTELLIGENT AUTO FILL ALL COLORS ===
            // === END AUTO FILL ALL COLORS ===

            // --- END PAINT BUCKET FUNCTIONS ---


            // --- UI SETTINGS ---
            function getSettings() {
                // CRITICAL: If Shade Mode is active, we return the BACKUP of the general settings
                // so that the "General" state in the database is never corrupted by shade values.
                // We only allow the 'shadeSettings' object itself to be updated in the save file.
                if (isShadeMode && mainSettingsBackup) {
                    // Create a deep-ish copy of the backup
                    const settings = { ...mainSettingsBackup };

                    // IMPORTANT: Ensure the LATEST shade settings are included in the save
                    settings.shadeSettings = { ...shadeSettings };

                    // We also allow the current tool to be saved even in shade mode
                    settings.tool = currentTool;

                    // NEW: Save Shade Mode State
                    settings.isShadeMode = true;

                    return settings;
                }

                return {
                    tool: currentTool,
                    strokeWidth: currentStrokeWidth,
                    strokeOpacity: currentStrokeOpacity,
                    strokeBlur: currentStrokeBlur,
                    pencilMode: pencilModeSelect.value,
                    pathTolerance: pathTolerance,
                    fixedNodeCount: fixedNodeCount,
                    color: selectedBaseColor,
                    imageOpacity: opacitySlider.value,
                    imageLock: lockImageCheckbox.checked,
                    traceLock: traceLockCheckbox.checked,
                    isStickyPencil: stickyPencilActive,
                    autosaveInterval: autosaveIntervalInput.value,
                    wandTolerance: toleranceSlider.value,
                    allColorTolerance: allColorToleranceSlider.value,
                    fillShrink: fillShrinkAmount,
                    selectionShrink: selectionShrinkAmount,
                    isTempPencil: isTempPencilActive,
                    zeroOpacityStrokesEnabled: zeroOpacityStrokesEnabled,
                    forceBlackStrokeEnabled: forceBlackStrokeEnabled,
                    blackOutlineModeEnabled: blackOutlineModeEnabled,
                    wetPaintEnabled: wetPaintEnabled,
                    waterMixEnabled: waterMixEnabled,
                    glossyEffectEnabled: glossyEffectEnabled,
                    glitterEffectEnabled: glitterEffectEnabled,
                    waterMixShadowSize: waterMixShadowSize,
                    waterMixShadowBlur: waterMixShadowBlur,
                    waterMixShadowOpacity: waterMixShadowOpacity,
                    waterMixStrength: waterMixStrength,
                    waterMixHighlightEnabled: waterMixHighlightEnabled,
                    waterMixHighlightOpacity: waterMixHighlightOpacity,
                    waterMixHighlightSize: waterMixHighlightSize,
                    waterMixHighlightBlur: waterMixHighlightBlur,
                    autoColorPickMode: autoColorPickMode,
                    wandWMode: wandWMode,
                    autoStrokePathEnabled: autoStrokePathEnabled, // Added persistence
                    autoStrokeStyle: autoStrokeStyle,
                    autoStrokeDensity: autoStrokeDensity,
                    autoStrokeUturnMultiplier: autoStrokeUturnMultiplier,
                    deleteFillOnExport: deleteFillOnExport,
                    colorFilter: currentColorFilter || 'none',
                    filterEnabled: filterEnabled || false,
                    luminositySaturation: parseInt(luminositySaturationSlider.value) || 100,
                    luminosityVibrance: parseInt(luminosityVibranceSlider.value) || 100,
                    snapToOutlineEnabled: snapToOutlineEnabled,
                    snapStrength: snapStrength,
                    isSelectionVisible: isSelectionVisible,
                    maskBrushSize: maskBrushSize,
                    wetPaintInnerShadowBlur: wetPaintInnerShadowBlur,
                    bgOpacity: parseFloat(bgOpacitySlider.value) || 1.0,
                    glitterStarCount: glitterStarCount,
                    shadeSettings: shadeSettings,
                    autoRefOpacityEnabled: autoRefOpacityEnabled,
                    isShadeMode: isShadeMode
                };
            }

            function applySettings(settings) {
                if (!settings) return;

                // ALWAYS FORCE SHADE MODE OFF ON LOAD
                // ALWAYS FORCE SHADE MODE OFF ON LOAD INITIALLY
                isShadeMode = false;
                // Check if we should restore it
                if (settings.isShadeMode) {
                    window.restoreShadeModeOnLoad = true;
                }
                if (shortcutShadeBtn) shortcutShadeBtn.classList.remove('active');
                if (shadeDarkenContainer) shadeDarkenContainer.classList.add('hidden');
                mainColorBackup = null;
                mainSettingsBackup = null;

                let startTool = settings.tool || 'pencil';
                if (startTool === 'color-picker') {
                    startTool = 'pencil';
                }
                currentTool = startTool;

                currentStrokeWidth = settings.strokeWidth || 2;
                strokeWidthSlider.value = currentStrokeWidth;
                strokeWidthValue.textContent = `${currentStrokeWidth}px`;

                wandPencilSlider.value = currentStrokeWidth;
                wandPencilSliderValue.textContent = `${currentStrokeWidth}px`;

                // NEW: Apply opacity/blur
                currentStrokeOpacity = settings.strokeOpacity || 1.0;
                strokeOpacitySlider.value = currentStrokeOpacity;
                strokeOpacityValue.textContent = currentStrokeOpacity.toFixed(2);

                currentStrokeBlur = settings.strokeBlur || 0;
                strokeBlurSlider.value = currentStrokeBlur;
                strokeBlurValue.textContent = currentStrokeBlur;

                // NEW: Apply Mask Brush Size
                maskBrushSize = settings.maskBrushSize || 20;
                const maskSizeSlider = document.getElementById('mask-brush-size-slider');
                const maskSizeValue = document.getElementById('mask-brush-size-value');
                if (maskSizeSlider) maskSizeSlider.value = maskBrushSize;
                if (maskSizeValue) maskSizeValue.textContent = `${maskBrushSize}px`;
                // END NEW

                pencilModeSelect.value = settings.pencilMode || 'smoothness';
                pencilModeSelect.dispatchEvent(new Event('change'));
                pathTolerance = settings.pathTolerance || 1.5;
                simplifySlider.value = pathTolerance;
                simplifyValue.textContent = pathTolerance.toFixed(1);
                fixedNodeCount = settings.fixedNodeCount || 10;
                pencilNodesSlider.value = fixedNodeCount;
                pencilNodesValue.textContent = fixedNodeCount;
                selectedBaseColor = settings.color || '#000000';
                colorPicker.value = selectedBaseColor;
                selectColor(selectedBaseColor);

                forceBlackStrokeEnabled = settings.forceBlackStrokeEnabled || false;
                if (forceBlackStrokeToggle) forceBlackStrokeToggle.checked = forceBlackStrokeEnabled;

                blackOutlineModeEnabled = settings.blackOutlineModeEnabled || false;
                if (blackOutlineModeToggle) blackOutlineModeToggle.checked = blackOutlineModeEnabled;
                opacitySlider.value = settings.imageOpacity || 1.0;
                if (referenceImage) referenceImage.setAttribute('opacity', opacitySlider.value);
                lockImageCheckbox.checked = settings.imageLock || false;
                traceLockCheckbox.checked = settings.traceLock || false;
                drawingLayer.setAttribute('mask', traceLockCheckbox.checked ? 'url(#image-mask)' : '');

                stickyPencilActive = settings.isStickyPencil || false;
                stickyPencilToggle.checked = stickyPencilActive;

                autosaveIntervalInput.value = settings.autosaveInterval || '60';

                toleranceSlider.value = settings.wandTolerance || 30;
                toleranceValue.textContent = toleranceSlider.value;
                allColorToleranceSlider.value = settings.allColorTolerance || 5;
                allColorToleranceValue.textContent = allColorToleranceSlider.value;

                fillShrinkAmount = settings.fillShrink ?? 0;
                paintBucketShrinkSlider.value = fillShrinkAmount;
                paintBucketShrinkValue.textContent = `${fillShrinkAmount}px`;

                setShrinkAmount(settings.selectionShrink ?? 0, { skipSave: true });

                isTempPencilActive = settings.isTempPencil || false;
                tempStrokeToggle.checked = isTempPencilActive;

                // Default zero opacity strokes to OFF (false) - explicitly set to false if not in settings
                zeroOpacityStrokesEnabled = settings.zeroOpacityStrokesEnabled === true ? true : false;
                zeroOpacityStrokesToggle.checked = zeroOpacityStrokesEnabled;

                // NEW: Load auto color pick and delete fill settings
                if (settings.shadeSettings) {
                    shadeSettings = settings.shadeSettings;
                }
                autoColorPickMode = settings.autoColorPickMode || false;
                if (autoColorPickToggle) {
                    autoColorPickToggle.checked = autoColorPickMode;
                }
                wandWMode = settings.wandWMode || false;
                if (wandWToggle) {
                    wandWToggle.checked = wandWMode;
                }
                autoRefOpacityEnabled = (settings.autoRefOpacityEnabled !== undefined) ? settings.autoRefOpacityEnabled : false;
                if (autoRefOpacityToggle) {
                    autoRefOpacityToggle.checked = autoRefOpacityEnabled;
                }
                if (canvasAutoRefOpacityToggleBtn) {
                    canvasAutoRefOpacityToggleBtn.classList.toggle('active', autoRefOpacityEnabled);
                }
                autoStrokePathEnabled = (settings.autoStrokePathEnabled !== undefined) ? settings.autoStrokePathEnabled : true;
                if (autoStrokePathToggle) {
                    autoStrokePathToggle.checked = autoStrokePathEnabled;
                }
                if (canvasAutoStrokeToggleBtn) {
                    canvasAutoStrokeToggleBtn.classList.toggle('active', autoStrokePathEnabled);
                }

                // Load Auto Stroke Style and Density settings
                autoStrokeStyle = settings.autoStrokeStyle || 'uniform';
                if (autoStrokeStyleSelect) {
                    autoStrokeStyleSelect.value = autoStrokeStyle;
                }
                autoStrokeDensity = settings.autoStrokeDensity || 8;
                if (autoStrokeDensitySlider) {
                    autoStrokeDensitySlider.value = autoStrokeDensity;
                }
                autoStrokeUturnMultiplier = settings.autoStrokeUturnMultiplier || 1.99;
                if (autoStrokeUturnSlider) {
                    autoStrokeUturnSlider.value = autoStrokeUturnMultiplier;
                    autoStrokeUturnValue.textContent = autoStrokeUturnMultiplier.toFixed(2);
                }

                // revived setting for "Fill Export" (Exclude Fills)
                deleteFillOnExport = settings.deleteFillOnExport || false;
                if (fillExportToggle) fillExportToggle.checked = deleteFillOnExport;

                // Load color filter settings
                currentColorFilter = settings.colorFilter || 'none';
                filterEnabled = settings.filterEnabled || false;
                if (colorFilterSelect) {
                    colorFilterSelect.value = currentColorFilter;
                    luminosityControls.classList.toggle('hidden', currentColorFilter !== 'luminosity');
                }
                if (luminositySaturationSlider) {
                    luminositySaturationSlider.value = settings.luminositySaturation || 100;
                    if (luminositySaturationValue) {
                        luminositySaturationValue.textContent = luminositySaturationSlider.value;
                    }
                }
                if (luminosityVibranceSlider) {
                    luminosityVibranceSlider.value = settings.luminosityVibrance || 100;
                    if (luminosityVibranceValue) {
                        luminosityVibranceValue.textContent = luminosityVibranceSlider.value;
                    }
                }
                // Apply filter if enabled
                if (filterEnabled && currentColorFilter !== 'none') {
                    applyColorFilter();
                }

                // NEW: Load snap settings
                snapToOutlineEnabled = settings.snapToOutlineEnabled || false;
                if (snapToggle) {
                    snapToggle.checked = snapToOutlineEnabled;
                    snapStrengthContainer.style.display = snapToOutlineEnabled ? 'block' : 'none';
                }
                snapStrength = (typeof settings.snapStrength === 'number') ? settings.snapStrength : 1;
                if (snapStrengthSlider) {
                    snapStrengthSlider.value = snapStrength;
                    snapStrengthValue.textContent = `${snapStrength}px`;
                }

                // NEW: Load selection visibility setting
                if (settings.hasOwnProperty('isSelectionVisible')) {
                    isSelectionVisible = settings.isSelectionVisible;
                } else {
                    isSelectionVisible = true; // Default to true
                }

                // Update UI for selection visibility
                const showSelectionOutlineToggle = document.getElementById('show-selection-outline-toggle');
                if (showSelectionOutlineToggle) {
                    showSelectionOutlineToggle.checked = isSelectionVisible;
                }

                const selectionVisibilityBtn = document.getElementById('shortcut-selection-visibility-btn');
                if (selectionVisibilityBtn) {
                    const visibleIcon = selectionVisibilityBtn.querySelector('svg:not(#selection-hidden-icon)');
                    const hiddenIcon = selectionVisibilityBtn.querySelector('#selection-hidden-icon');
                    if (visibleIcon && hiddenIcon) {
                        if (isSelectionVisible) {
                            visibleIcon.classList.remove('hidden');
                            hiddenIcon.classList.add('hidden');
                        } else {
                            visibleIcon.classList.add('hidden');
                            hiddenIcon.classList.remove('hidden');
                        }
                    }
                }

                wetPaintEnabled = !!settings.wetPaintEnabled;
                wetPaintToolBtn.classList.toggle('active', wetPaintEnabled);

                glossyEffectEnabled = !!settings.glossyEffectEnabled;
                glossyEffectToolBtn.classList.toggle('active', glossyEffectEnabled);
                waterMixEnabled = !!settings.waterMixEnabled;
                waterMixToolBtn.classList.toggle('active', waterMixEnabled);
                glitterEffectEnabled = !!settings.glitterEffectEnabled;
                glitterEffectToolBtn.classList.toggle('active', glitterEffectEnabled);

                // Load wet paint shadow settings
                wetPaintOuterShadowSize = settings.wetPaintOuterShadowSize ?? 1.2;
                wetPaintOuterShadowBlur = settings.wetPaintOuterShadowBlur ?? 0.35;
                wetPaintInnerShadowSize = settings.wetPaintInnerShadowSize ?? 0.5;
                wetPaintInnerShadowBlur = settings.wetPaintInnerShadowBlur ?? 0.4;

                // Update slider values and val displays
                const wpOuterSizeSlider = document.getElementById('wp-outer-shadow-size');
                const wpOuterBlurSlider = document.getElementById('wp-outer-shadow-blur');
                const wpInnerSizeSlider = document.getElementById('wp-inner-shadow-size');
                const wpInnerBlurSlider = document.getElementById('wp-inner-shadow-blur');

                if (wpOuterSizeSlider) wpOuterSizeSlider.value = wetPaintOuterShadowSize;
                if (wpOuterBlurSlider) wpOuterBlurSlider.value = wetPaintOuterShadowBlur;
                if (wpInnerSizeSlider) wpInnerSizeSlider.value = wetPaintInnerShadowSize;
                if (wpInnerBlurSlider) wpInnerBlurSlider.value = wetPaintInnerShadowBlur;

                // NEW: Background Image Opacity
                if (settings.bgOpacity !== undefined) {
                    bgImageState.opacity = settings.bgOpacity;
                    if (bgOpacitySlider) bgOpacitySlider.value = settings.bgOpacity;
                    if (bgOpacityValue) bgOpacityValue.textContent = settings.bgOpacity.toFixed(2);
                    updateBgImage();
                }

                // NEW: Glitter Settings
                if (settings.glitterDensity !== undefined) {
                    glitterDensity = settings.glitterDensity;
                    if (glitterDensitySlider) glitterDensitySlider.value = glitterDensity;
                    if (glitterDensityValue) glitterDensityValue.textContent = glitterDensity.toFixed(2);
                }
                if (settings.glitterSize !== undefined) {
                    glitterSize = settings.glitterSize;
                    if (glitterSizeSlider) glitterSizeSlider.value = glitterSize;
                    if (glitterSizeValue) glitterSizeValue.textContent = glitterSize.toFixed(1);
                }
                if (settings.glitterStarCount !== undefined) {
                    glitterStarCount = settings.glitterStarCount;
                    if (glitterStarCountSlider) glitterStarCountSlider.value = glitterStarCount;
                    if (glitterStarCountValue) glitterStarCountValue.textContent = glitterStarCount.toFixed(2);
                }
                updateGlitterFilters();
                updateEffectSettingsVisibility();

                const wpOuterSizeVal = document.getElementById('wp-outer-shadow-size-val');
                const wpOuterBlurVal = document.getElementById('wp-outer-shadow-blur-val');
                const wpInnerSizeVal = document.getElementById('wp-inner-shadow-size-val');
                const wpInnerBlurVal = document.getElementById('wp-inner-shadow-blur-val');

                if (wpOuterSizeVal) wpOuterSizeVal.textContent = wetPaintOuterShadowSize.toFixed(1);
                if (wpOuterBlurVal) wpOuterBlurVal.textContent = wetPaintOuterShadowBlur.toFixed(2);
                if (wpInnerSizeVal) wpInnerSizeVal.textContent = wetPaintInnerShadowSize.toFixed(1);
                if (wpInnerBlurVal) wpInnerBlurVal.textContent = wetPaintInnerShadowBlur.toFixed(2);

                // Load water mix settings
                waterMixShadowSize = settings.waterMixShadowSize ?? 0.6;
                waterMixShadowBlur = settings.waterMixShadowBlur ?? 0.4;
                waterMixShadowOpacity = settings.waterMixShadowOpacity ?? 0.15;
                waterMixStrength = settings.waterMixStrength ?? 0.3;

                const wmSizeSlider = document.getElementById('wm-shadow-size');
                const wmBlurSlider = document.getElementById('wm-shadow-blur');
                const wmOpacitySlider = document.getElementById('wm-shadow-opacity');
                const wmMixSlider = document.getElementById('wm-mix-strength');

                if (wmSizeSlider) wmSizeSlider.value = waterMixShadowSize;
                if (wmBlurSlider) wmBlurSlider.value = waterMixShadowBlur;
                if (wmOpacitySlider) wmOpacitySlider.value = waterMixShadowOpacity;
                if (wmMixSlider) wmMixSlider.value = waterMixStrength;

                const wmSizeVal = document.getElementById('wm-shadow-size-val');
                const wmBlurVal = document.getElementById('wm-shadow-blur-val');
                const wmOpacityVal = document.getElementById('wm-shadow-opacity-val');
                const wmMixVal = document.getElementById('wm-mix-strength-val');

                if (wmSizeVal) wmSizeVal.textContent = waterMixShadowSize.toFixed(1);
                if (wmBlurVal) wmBlurVal.textContent = waterMixShadowBlur.toFixed(2);
                if (wmOpacityVal) wmOpacityVal.textContent = waterMixShadowOpacity.toFixed(2);
                if (wmMixVal) wmMixVal.textContent = waterMixStrength.toFixed(2);

                waterMixHighlightEnabled = !!settings.waterMixHighlightEnabled;
                if (document.getElementById('wm-highlight-toggle')) {
                    document.getElementById('wm-highlight-toggle').checked = waterMixHighlightEnabled;
                }
                waterMixHighlightOpacity = settings.waterMixHighlightOpacity ?? 0.5;
                if (document.getElementById('wm-highlight-opacity')) {
                    document.getElementById('wm-highlight-opacity').value = waterMixHighlightOpacity;
                }
                if (document.getElementById('wm-highlight-opacity-val')) {
                    document.getElementById('wm-highlight-opacity-val').textContent = waterMixHighlightOpacity.toFixed(2);
                }

                waterMixHighlightSize = settings.waterMixHighlightSize ?? 0.6;
                if (document.getElementById('wm-highlight-size')) {
                    document.getElementById('wm-highlight-size').value = waterMixHighlightSize;
                }
                if (document.getElementById('wm-highlight-size-val')) {
                    document.getElementById('wm-highlight-size-val').textContent = waterMixHighlightSize.toFixed(1);
                }

                waterMixHighlightBlur = settings.waterMixHighlightBlur ?? 0.0;
                if (document.getElementById('wm-highlight-blur')) {
                    document.getElementById('wm-highlight-blur').value = waterMixHighlightBlur;
                }
                if (document.getElementById('wm-highlight-blur-val')) {
                    document.getElementById('wm-highlight-blur-val').textContent = waterMixHighlightBlur.toFixed(2);
                }
            }

            function saveUiSettings() { localStorage.setItem('svgDrawSettings', JSON.stringify(getSettings())); }
            function loadUiSettings() {
                const saved = localStorage.getItem('svgDrawSettings');
                if (!saved) return;
                applySettings(JSON.parse(saved));
                switchTool(currentTool);
            }

            // --- SETTINGS PROFILES SYSTEM ---
            const PROFILES_STORAGE_KEY = 'svgDrawProfiles';
            const DEFAULT_PROFILE_KEY = 'svgDrawDefaultProfile';
            const ACTIVE_PROFILE_KEY = 'svgDrawActiveProfile';

            let settingsProfiles = {};
            let activeProfileId = 'default';

            // Initialize profiles system
            function initProfilesSystem() {
                loadProfiles();
                updateProfilesUI();
                loadDefaultProfileOnStartup();
            }

            // Load profiles from localStorage
            function loadProfiles() {
                try {
                    const saved = localStorage.getItem(PROFILES_STORAGE_KEY);
                    if (saved) {
                        settingsProfiles = JSON.parse(saved);
                    } else {
                        // Initialize with default profile
                        settingsProfiles = {
                            'default': {
                                id: 'default',
                                name: 'Default',
                                settings: getSettings(),
                                createdAt: Date.now()
                            }
                        };
                        saveProfiles();
                    }
                } catch (e) {
                    console.error('Error loading profiles:', e);
                    settingsProfiles = {
                        'default': {
                            id: 'default',
                            name: 'Default',
                            settings: getSettings(),
                            createdAt: Date.now()
                        }
                    };
                }
            }

            // Save profiles to localStorage
            function saveProfiles() {
                try {
                    localStorage.setItem(PROFILES_STORAGE_KEY, JSON.stringify(settingsProfiles));
                } catch (e) {
                    console.error('Error saving profiles:', e);
                    showToast('Error saving profiles!', true);
                }
            }

            // Get default profile ID
            function getDefaultProfileId() {
                return localStorage.getItem(DEFAULT_PROFILE_KEY) || 'default';
            }

            // Set default profile ID
            function setDefaultProfileId(profileId) {
                localStorage.setItem(DEFAULT_PROFILE_KEY, profileId);
                updateProfilesUI();
            }

            // Get active profile ID
            function getActiveProfileId() {
                return localStorage.getItem(ACTIVE_PROFILE_KEY) || getDefaultProfileId();
            }

            // Set active profile ID
            function setActiveProfileId(profileId) {
                localStorage.setItem(ACTIVE_PROFILE_KEY, profileId);
                activeProfileId = profileId;
            }

            // Load default profile on app startup
            function loadDefaultProfileOnStartup() {
                const defaultId = getDefaultProfileId();
                const profile = settingsProfiles[defaultId];
                if (profile && profile.settings) {
                    applySettings(profile.settings);
                    switchTool(currentTool);
                    setActiveProfileId(defaultId);
                    activeProfileId = defaultId;
                }
            }

            // Save all current settings to a specific profile
            function saveSettingsToProfile(profileId) {
                if (!settingsProfiles[profileId]) {
                    showToast('Profile not found!', true);
                    return false;
                }
                settingsProfiles[profileId].settings = getSettings();
                settingsProfiles[profileId].lastModified = Date.now();
                saveProfiles();
                // Also update the basic settings backup
                saveUiSettings();
                return true;
            }

            // Load settings from a specific profile
            function loadSettingsFromProfile(profileId) {
                const profile = settingsProfiles[profileId];
                if (!profile || !profile.settings) {
                    showToast('Profile not found!', true);
                    return false;
                }
                applySettings(profile.settings);
                switchTool(currentTool);
                setActiveProfileId(profileId);
                activeProfileId = profileId;
                updateProfilesUI();
                return true;
            }

            // Create a new profile
            function createProfile(name, copyCurrentSettings = true) {
                const id = 'profile_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const newProfile = {
                    id: id,
                    name: name.trim() || 'New Profile',
                    settings: copyCurrentSettings ? getSettings() : null,
                    createdAt: Date.now()
                };
                settingsProfiles[id] = newProfile;
                saveProfiles();
                setActiveProfileId(id);
                activeProfileId = id;
                updateProfilesUI();
                return id;
            }

            // Delete a profile
            function deleteProfile(profileId) {
                if (profileId === 'default') {
                    showToast('Cannot delete the default profile!', true);
                    return false;
                }
                if (!settingsProfiles[profileId]) {
                    showToast('Profile not found!', true);
                    return false;
                }

                const profileName = settingsProfiles[profileId].name;
                delete settingsProfiles[profileId];
                saveProfiles();

                // If deleted profile was the default, reset to 'default'
                if (getDefaultProfileId() === profileId) {
                    setDefaultProfileId('default');
                }

                // If deleted profile was the active one, switch to default
                if (getActiveProfileId() === profileId) {
                    loadSettingsFromProfile('default');
                }

                updateProfilesUI();
                showToast(`Profile "${profileName}" deleted.`);
                return true;
            }

            // Update the profiles UI (dropdown, buttons, etc.)
            function updateProfilesUI() {
                const profileSelect = document.getElementById('profile-select');
                const defaultNameSpan = document.getElementById('current-default-name');
                const setDefaultBtn = document.getElementById('set-default-profile-btn');
                const defaultIndicator = document.getElementById('default-profile-indicator');

                if (!profileSelect) return;

                // Populate dropdown
                const currentActive = getActiveProfileId();
                const currentDefault = getDefaultProfileId();

                profileSelect.innerHTML = '';
                Object.values(settingsProfiles)
                    .sort((a, b) => {
                        // Keep 'default' first
                        if (a.id === 'default') return -1;
                        if (b.id === 'default') return 1;
                        return (a.createdAt || 0) - (b.createdAt || 0);
                    })
                    .forEach(profile => {
                        const option = document.createElement('option');
                        option.value = profile.id;
                        option.textContent = profile.name + (profile.id === currentDefault ? ' ' : '');
                        if (profile.id === currentActive) {
                            option.selected = true;
                        }
                        profileSelect.appendChild(option);
                    });

                // Update default display
                if (defaultNameSpan) {
                    const defaultProfile = settingsProfiles[currentDefault];
                    defaultNameSpan.textContent = defaultProfile ? defaultProfile.name : 'Default';
                }

                // Update set as default button
                if (setDefaultBtn && defaultIndicator) {
                    if (currentActive === currentDefault) {
                        defaultIndicator.textContent = ' Is Default';
                        setDefaultBtn.classList.add('bg-amber-200');
                        setDefaultBtn.classList.remove('bg-amber-100');
                    } else {
                        defaultIndicator.textContent = 'Set Default';
                        setDefaultBtn.classList.remove('bg-amber-200');
                        setDefaultBtn.classList.add('bg-amber-100');
                    }
                }
            }

            // Initialize profile event listeners
            function initProfileEventListeners() {
                const profileSelect = document.getElementById('profile-select');
                const saveAllSettingsBtn = document.getElementById('save-all-settings-btn');
                const createProfileBtn = document.getElementById('create-profile-btn');
                const deleteProfileBtn = document.getElementById('delete-profile-btn');
                const setDefaultBtn = document.getElementById('set-default-profile-btn');
                const profileNameModal = document.getElementById('profile-name-modal');
                const profileNameInput = document.getElementById('profile-name-input');
                const copyCurrentSettingsCheckbox = document.getElementById('copy-current-settings-checkbox');
                const cancelProfileNameBtn = document.getElementById('cancel-profile-name-btn');
                const confirmProfileNameBtn = document.getElementById('confirm-profile-name-btn');

                // Profile selection change - load settings from selected profile
                if (profileSelect) {
                    profileSelect.addEventListener('change', (e) => {
                        const selectedId = e.target.value;
                        loadSettingsFromProfile(selectedId);
                        showToast(`Loaded profile: ${settingsProfiles[selectedId]?.name || 'Unknown'}`);
                    });
                }

                // Save All Settings button
                if (saveAllSettingsBtn) {
                    saveAllSettingsBtn.addEventListener('click', () => {
                        const selectedId = profileSelect?.value || activeProfileId;
                        if (saveSettingsToProfile(selectedId)) {
                            const profileName = settingsProfiles[selectedId]?.name || 'Unknown';
                            showToast(`All settings saved to "${profileName}"!`);
                            // Visual feedback
                            saveAllSettingsBtn.style.transform = 'scale(0.95)';
                            setTimeout(() => {
                                saveAllSettingsBtn.style.transform = 'scale(1)';
                            }, 150);
                        }
                    });
                }

                // Create Profile button - show modal
                if (createProfileBtn && profileNameModal) {
                    createProfileBtn.addEventListener('click', () => {
                        if (profileNameInput) profileNameInput.value = '';
                        if (copyCurrentSettingsCheckbox) copyCurrentSettingsCheckbox.checked = true;
                        profileNameModal.classList.remove('hidden');
                        profileNameModal.classList.add('flex');
                        if (profileNameInput) profileNameInput.focus();
                    });
                }

                // Cancel profile name modal
                if (cancelProfileNameBtn && profileNameModal) {
                    cancelProfileNameBtn.addEventListener('click', () => {
                        profileNameModal.classList.add('hidden');
                        profileNameModal.classList.remove('flex');
                    });
                }

                // Confirm create profile
                if (confirmProfileNameBtn && profileNameModal && profileNameInput) {
                    confirmProfileNameBtn.addEventListener('click', () => {
                        const name = profileNameInput.value.trim();
                        if (!name) {
                            showToast('Please enter a profile name!', true);
                            return;
                        }
                        const copySettings = copyCurrentSettingsCheckbox?.checked ?? true;
                        const newId = createProfile(name, copySettings);
                        profileNameModal.classList.add('hidden');
                        profileNameModal.classList.remove('flex');
                        showToast(`Profile "${name}" created!`);
                    });

                    // Enter key to confirm
                    profileNameInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            confirmProfileNameBtn.click();
                        }
                    });
                }

                // Delete Profile button
                if (deleteProfileBtn) {
                    deleteProfileBtn.addEventListener('click', () => {
                        const selectedId = profileSelect?.value || activeProfileId;
                        if (selectedId === 'default') {
                            showToast('Cannot delete the default profile!', true);
                            return;
                        }
                        const profileName = settingsProfiles[selectedId]?.name || 'Unknown';
                        showConfirmation(
                            'Delete Profile?',
                            `Are you sure you want to delete the profile "${profileName}"? This action cannot be undone.`,
                            () => {
                                deleteProfile(selectedId);
                            }
                        );
                    });
                }

                // Set as Default button
                if (setDefaultBtn) {
                    setDefaultBtn.addEventListener('click', () => {
                        const selectedId = profileSelect?.value || activeProfileId;
                        setDefaultProfileId(selectedId);
                        const profileName = settingsProfiles[selectedId]?.name || 'Unknown';
                        showToast(`"${profileName}" is now the default profile!`);
                    });
                }
            }

            // --- END SETTINGS PROFILES SYSTEM ---

            // --- EXPORT ---
            function exportSVG() {
                loader.classList.remove('hidden');
                deselect();

                const finalSvg = createSvgElement('svg', { xmlns: 'http://www.w3.org/2000/svg', 'xmlns:xlink': 'http://www.w3.org/1999/xlink', width: canvasContainer.clientWidth, height: canvasContainer.clientHeight, viewBox: `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}` });

                finalSvg.appendChild(defs.cloneNode(true));

                if (referenceImage) {
                    const backgroundLayer = createSvgElement("g", { id: 'background-image-layer' });
                    const bottomImage = referenceImage.cloneNode(true);
                    bottomImage.removeAttribute('opacity');
                    bottomImage.setAttribute('opacity', 1);
                    backgroundLayer.appendChild(bottomImage);
                    finalSvg.appendChild(backgroundLayer);
                }

                const clonedDrawingLayer = drawingLayer.cloneNode(true);
                clonedDrawingLayer.removeAttribute('mask');

                // Restore heavy filters for export (Filter Preview Optimization)
                clonedDrawingLayer.querySelectorAll('path[data-cached-filter]').forEach(path => {
                    path.setAttribute('filter', path.getAttribute('data-cached-filter'));
                });
                // Ensure drawing-layer ID is preserved for re-import
                if (!clonedDrawingLayer.getAttribute('id')) {
                    clonedDrawingLayer.setAttribute('id', 'drawing-layer');
                }

                clonedDrawingLayer.querySelectorAll('path[data-temp-stroke="true"]').forEach(path => path.remove());
                clonedDrawingLayer.querySelectorAll('.auto-stroke-overlay').forEach(el => el.remove());

                // Process paths to create perfect step-by-step ordering for animation
                // Maintain exact DOM order (drawing order) for perfect step-by-step animation
                const allPaths = Array.from(clonedDrawingLayer.querySelectorAll('path'));

                // Track fills and their overlapping zero-opacity strokes for masking
                const fillMaskMap = new Map(); // Maps fill index to array of overlapping zero-opacity stroke indices
                let maskCounter = 0;

                // First pass: Identify fills and their overlapping zero-opacity strokes
                allPaths.forEach((path, index) => {
                    const fill = path.getAttribute('fill');
                    const stroke = path.getAttribute('stroke');
                    const strokeOpacity = parseFloat(path.getAttribute('stroke-opacity') || '1');

                    // Check if this is a fill path (has fill, no stroke or stroke is none)
                    if (fill && fill !== 'none' && (!stroke || stroke === 'none')) {
                        const fillBounds = getPathBounds(path);

                        // Find all zero-opacity strokes that come AFTER this fill and overlap with it
                        const overlappingStrokes = [];
                        for (let i = index + 1; i < allPaths.length; i++) {
                            const laterPath = allPaths[i];
                            const laterStroke = laterPath.getAttribute('stroke');
                            const laterStrokeOpacity = parseFloat(laterPath.getAttribute('stroke-opacity') || '1');

                            // Only consider zero-opacity strokes that come after this fill
                            if (laterStroke && laterStroke !== 'none' && laterStrokeOpacity <= 0.01) {
                                const strokeBounds = getPathBounds(laterPath);
                                if (boundsOverlap(fillBounds, strokeBounds)) {
                                    overlappingStrokes.push(i);
                                }
                            }
                        }

                        if (overlappingStrokes.length > 0) {
                            fillMaskMap.set(index, overlappingStrokes);
                        }
                    }
                });

                // Clear the cloned drawing layer
                clonedDrawingLayer.innerHTML = '';

                // Second pass: Process paths in order, applying masks where needed
                allPaths.forEach((path, index) => {
                    const fill = path.getAttribute('fill');
                    const stroke = path.getAttribute('stroke');
                    const currentStrokeOpacity = parseFloat(path.getAttribute('stroke-opacity') || '1');

                    // NEW: skip fills if "Exclude Fills on Export" is ON
                    if (deleteFillOnExport && fill && fill !== 'none' && (!stroke || stroke === 'none')) {
                        return; // Skip this path entirely
                    }

                    // Apply zero opacity to strokes if toggle is enabled
                    if (zeroOpacityStrokesEnabled && stroke && stroke !== 'none') {
                        path.setAttribute('stroke-opacity', '0');
                    } else if (currentStrokeOpacity <= 0.01 && stroke && stroke !== 'none') {
                        // Maintain zero opacity if already set
                        // Maintain zero opacity if already set
                        path.setAttribute('stroke-opacity', '0');
                    }

                    // Apply force black stroke if enabled
                    if (forceBlackStrokeEnabled && stroke && stroke !== 'none') {
                        path.setAttribute('stroke', '#000000');
                    }

                    // Check if this is a fill that needs masking
                    if (fillMaskMap.has(index)) {
                        const overlappingStrokeIndices = fillMaskMap.get(index);
                        const fillBounds = getPathBounds(path);
                        const maskId = `reveal-mask-${maskCounter++}`;

                        // Create mask definition
                        const mask = createSvgElement('mask', { id: maskId });

                        // Add black background (initially hidden - black = transparent in mask)
                        const blackRect = createSvgElement('rect', {
                            x: fillBounds.x - 10,
                            y: fillBounds.y - 10,
                            width: fillBounds.width + 20,
                            height: fillBounds.height + 20,
                            fill: 'black'
                        });
                        mask.appendChild(blackRect);

                        // Add white strokes that will be animated to reveal the fill
                        overlappingStrokeIndices.forEach(strokeIndex => {
                            const strokePath = allPaths[strokeIndex];
                            let pathLength = 0;
                            try {
                                pathLength = strokePath.getTotalLength();
                            } catch (e) {
                                const bounds = getPathBounds(strokePath);
                                pathLength = Math.max(bounds.width, bounds.height) * 2;
                            }

                            // Create mask stroke (white reveals in mask)
                            const strokeForMask = strokePath.cloneNode(true);
                            strokeForMask.setAttribute('fill', 'none');
                            strokeForMask.setAttribute('stroke', 'white');
                            strokeForMask.setAttribute('stroke-width', strokePath.getAttribute('stroke-width') || '2');
                            strokeForMask.setAttribute('stroke-linecap', 'round');
                            strokeForMask.setAttribute('stroke-linejoin', 'round');
                            strokeForMask.removeAttribute('stroke-opacity');
                            strokeForMask.removeAttribute('opacity');

                            // Set up dash array for animation (initially fully hidden)
                            if (pathLength > 0) {
                                strokeForMask.setAttribute('stroke-dasharray', pathLength);
                                strokeForMask.setAttribute('stroke-dashoffset', pathLength);
                            }
                            mask.appendChild(strokeForMask);
                        });

                        finalSvg.querySelector('defs').appendChild(mask);

                        // Create group for this fill with mask
                        const fillGroup = createSvgElement('g', { mask: `url(#${maskId})` });
                        fillGroup.appendChild(path.cloneNode(true));
                        clonedDrawingLayer.appendChild(fillGroup);
                    } else {
                        // Regular path (fill or stroke) - add directly maintaining order
                        clonedDrawingLayer.appendChild(path.cloneNode(true));
                    }
                });

                finalSvg.appendChild(clonedDrawingLayer);

                if (referenceImage) {
                    const outlineLayer = createSvgElement("g", { id: 'outline-image-layer', style: 'mix-blend-mode: multiply;' });
                    const topImage = referenceImage.cloneNode(true);
                    topImage.removeAttribute('opacity');
                    topImage.setAttribute('opacity', 1);
                    outlineLayer.appendChild(topImage);
                    finalSvg.appendChild(outlineLayer);
                }

                // CLEANUP: Remove unused selection clip-paths from defs to reduce file size and lag
                const exportedDefs = finalSvg.querySelector('defs');
                if (exportedDefs) {
                    const usedIds = new Set();
                    // Collect all IDs referenced in the drawing layer
                    const allElements = clonedDrawingLayer.querySelectorAll('*');
                    allElements.forEach(el => {
                        const clipPath = el.getAttribute('clip-path');
                        if (clipPath && clipPath.includes('url(#')) {
                            const match = clipPath.match(/url\(#([^)]+)\)/);
                            if (match && match[1]) usedIds.add(match[1]);
                        }
                    });

                    // Remove unused selection clip paths
                    const clipPaths = exportedDefs.querySelectorAll('clipPath');
                    clipPaths.forEach(cp => {
                        const id = cp.id;
                        // Only target our generated selection clip paths to be safe
                        if (id && id.startsWith('selection-clip-path-') && !usedIds.has(id)) {
                            cp.remove();
                        }
                    });
                }

                const svgData = new XMLSerializer().serializeToString(finalSvg);
                const a = document.createElement('a');
                a.href = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgData);
                a.download = `${currentProjectName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.svg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                setTimeout(() => { loader.classList.add('hidden'); }, 500);
            }

            // PNG Export Settings
            let pngExportScale = 2; // Default scale

            // Show PNG export options modal
            function showPngExportModal() {
                if (!pngExportModal || !pngScaleSelect) return;

                deselect();

                // Update scale options with current viewBox dimensions
                const scaleOptions = [1, 2, 3, 4];
                const optionsHtml = scaleOptions.map(scale => {
                    const width = Math.round(viewBox.w * scale);
                    const height = Math.round(viewBox.h * scale);
                    const selected = scale === pngExportScale ? 'selected' : '';
                    return `<option value="${scale}" ${selected}>${scale}x - ${width} x ${height} px</option>`;
                }).join('') + '<option value="custom"' + (pngExportScale !== 1 && !scaleOptions.includes(pngExportScale) ? ' selected' : '') + '>Custom Scale</option>';

                if (pngScaleSelect) {
                    pngScaleSelect.innerHTML = optionsHtml;
                    pngScaleSelect.value = (pngExportScale === 1 || scaleOptions.includes(pngExportScale)) ? pngExportScale.toString() : 'custom';
                }

                // Update preset
                if (pngQualityPreset) {
                    const presetMap = { 2: 'standard', 3: 'high', 4: 'very-high', 5: 'ultra', 8: 'maximum' };
                    pngQualityPreset.value = presetMap[pngExportScale] || 'high';
                }

                // Update preview
                updatePngExportPreview();

                pngExportModal.classList.remove('hidden');
                pngExportModal.classList.add('flex');
            }

            // Update PNG export preview
            function updatePngExportPreview() {
                if (!pngScaleSelect || !pngOutputSize) return;

                const scale = pngScaleSelect.value === 'custom' ?
                    (pngCustomScale ? parseFloat(pngCustomScale.value) : pngExportScale) :
                    parseFloat(pngScaleSelect.value);

                const width = Math.round(viewBox.w * scale);
                const height = Math.round(viewBox.h * scale);

                if (pngOutputSize) {
                    pngOutputSize.textContent = `${width} x ${height} px`;
                }

                if (pngScaleSelect.value === 'custom') {
                    if (pngCustomScaleContainer) {
                        pngCustomScaleContainer.classList.remove('hidden');
                    }
                    if (pngCustomScale) {
                        pngCustomScale.value = scale.toString();
                    }
                    if (pngCustomScaleValue) {
                        pngCustomScaleValue.textContent = `${scale}x`;
                    }
                    if (pngDimensionsPreview) {
                        pngDimensionsPreview.textContent = `Dimensions: ${width} x ${height} px`;
                    }
                } else {
                    if (pngCustomScaleContainer) {
                        pngCustomScaleContainer.classList.add('hidden');
                    }
                }
            }

            // Export as PNG image - exports exactly what's visible on canvas
            async function exportPNG(scale = null) {
                const exportScale = scale || pngExportScale;
                loader.classList.remove('hidden');
                deselect();

                try {
                    // Use same logic as exportSVG to ensure PNG matches canvas exactly
                    const finalSvg = createSvgElement('svg', {
                        xmlns: 'http://www.w3.org/2000/svg',
                        'xmlns:xlink': 'http://www.w3.org/1999/xlink',
                        width: canvasContainer.clientWidth,
                        height: canvasContainer.clientHeight,
                        viewBox: `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`
                    });

                    finalSvg.appendChild(defs.cloneNode(true));

                    // Add reference image if present (background layer)
                    if (referenceImage) {
                        const backgroundLayer = createSvgElement("g", { id: 'background-image-layer' });
                        const bottomImage = referenceImage.cloneNode(true);
                        bottomImage.removeAttribute('opacity');
                        bottomImage.setAttribute('opacity', 1);
                        backgroundLayer.appendChild(bottomImage);
                        finalSvg.appendChild(backgroundLayer);
                    }

                    // Clone drawing layer exactly as it appears
                    const clonedDrawingLayer = drawingLayer.cloneNode(true);
                    clonedDrawingLayer.removeAttribute('mask');

                    // Restore heavy filters for export (Filter Preview Optimization)
                    clonedDrawingLayer.querySelectorAll('path[data-cached-filter]').forEach(path => {
                        path.setAttribute('filter', path.getAttribute('data-cached-filter'));
                    });

                    // Remove temp strokes only
                    clonedDrawingLayer.querySelectorAll('path[data-temp-stroke="true"]').forEach(path => path.remove());
                    clonedDrawingLayer.querySelectorAll('.auto-stroke-overlay').forEach(el => el.remove());

                    // Process paths to maintain exact visual order (same as exportSVG)
                    const allPaths = Array.from(clonedDrawingLayer.querySelectorAll('path'));
                    clonedDrawingLayer.innerHTML = '';

                    // Process paths exactly like exportSVG - maintain visual order and all effects
                    allPaths.forEach((path) => {
                        const fill = path.getAttribute('fill');
                        const stroke = path.getAttribute('stroke');
                        const currentStrokeOpacity = parseFloat(path.getAttribute('stroke-opacity') || '1');

                        // Apply zero opacity to strokes if toggle is enabled (match canvas appearance)
                        if (zeroOpacityStrokesEnabled && stroke && stroke !== 'none') {
                            const clonedPath = path.cloneNode(true);
                            clonedPath.setAttribute('stroke-opacity', '0');
                            clonedDrawingLayer.appendChild(clonedPath);
                        } else if (currentStrokeOpacity <= 0.01 && stroke && stroke !== 'none') {
                            // Maintain zero opacity if already set (matches canvas)
                            const clonedPath = path.cloneNode(true);
                            clonedPath.setAttribute('stroke-opacity', '0');
                            clonedDrawingLayer.appendChild(clonedPath);
                        } else {
                            // Add path as-is to maintain exact appearance (includes all fills, strokes, effects)
                            clonedDrawingLayer.appendChild(path.cloneNode(true));
                        }
                    });

                    finalSvg.appendChild(clonedDrawingLayer);

                    // Add reference image on top if present (outline layer - matches exportSVG)
                    if (referenceImage) {
                        const outlineLayer = createSvgElement("g", { id: 'outline-image-layer', style: 'mix-blend-mode: multiply;' });
                        const topImage = referenceImage.cloneNode(true);
                        topImage.removeAttribute('opacity');
                        topImage.setAttribute('opacity', 1);
                        outlineLayer.appendChild(topImage);
                        finalSvg.appendChild(outlineLayer);
                    }

                    // Serialize SVG to string
                    const svgData = new XMLSerializer().serializeToString(finalSvg);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);

                    // Create image element to load SVG
                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                // Create canvas based on viewBox dimensions with selected scale
                                const canvas = document.createElement('canvas');
                                // Use viewBox dimensions with user-selected scale for quality
                                canvas.width = Math.round(viewBox.w * exportScale);
                                canvas.height = Math.round(viewBox.h * exportScale);

                                const ctx = canvas.getContext('2d');

                                // Fill white background
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);

                                // Draw SVG image scaled to viewBox dimensions
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                                // Convert to PNG blob
                                canvas.toBlob((blob) => {
                                    if (blob) {
                                        const pngUrl = URL.createObjectURL(blob);
                                        const a = document.createElement('a');
                                        a.href = pngUrl;
                                        a.download = `${currentProjectName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        URL.revokeObjectURL(pngUrl);
                                        const width = Math.round(viewBox.w * exportScale);
                                        const height = Math.round(viewBox.h * exportScale);
                                        showToast(`PNG exported successfully! (${width} x ${height} px, ${exportScale}x scale)`);
                                        loader.classList.add('hidden');
                                        resolve();
                                    } else {
                                        reject(new Error('Failed to create PNG blob'));
                                    }
                                }, 'image/png');

                                URL.revokeObjectURL(url);
                            } catch (error) {
                                URL.revokeObjectURL(url);
                                reject(error);
                            }
                        };
                        img.onerror = (error) => {
                            URL.revokeObjectURL(url);
                            reject(error);
                        };
                        img.src = url;
                    });
                } catch (error) {
                    console.error('Error exporting PNG:', error);
                    showToast('Error exporting PNG.', true);
                    loader.classList.add('hidden');
                }
            }

            // Helper function to get path bounds
            function getPathBounds(path) {
                try {
                    // Try to get bounding box directly
                    const bbox = path.getBBox();
                    if (bbox && bbox.width > 0 && bbox.height > 0) {
                        return {
                            x: bbox.x,
                            y: bbox.y,
                            width: bbox.width,
                            height: bbox.height
                        };
                    }
                } catch (e) {
                    // Fallback to path length method
                }

                // Fallback: use path length for stroke paths
                try {
                    const pathLength = path.getTotalLength();
                    if (pathLength > 0) {
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                        for (let i = 0; i <= 20; i++) {
                            const point = path.getPointAtLength((pathLength * i) / 20);
                            minX = Math.min(minX, point.x);
                            minY = Math.min(minY, point.y);
                            maxX = Math.max(maxX, point.x);
                            maxY = Math.max(maxY, point.y);
                        }

                        return {
                            x: minX,
                            y: minY,
                            width: maxX - minX,
                            height: maxY - minY
                        };
                    }
                } catch (e) {
                    // If all else fails, return default bounds
                }

                // Default bounds if we can't determine
                return { x: 0, y: 0, width: 100, height: 100 };
            }

            // Helper function to check if bounds overlap
            function boundsOverlap(bounds1, bounds2) {
                return !(bounds1.x + bounds1.width < bounds2.x ||
                    bounds2.x + bounds2.width < bounds1.x ||
                    bounds1.y + bounds1.height < bounds2.y ||
                    bounds2.y + bounds2.height < bounds1.y);
            }

            // --- TOAST & MODALS ---
            function showToast(message, isError = false) {
                toast.textContent = message;
                toast.style.backgroundColor = isError ? '#dc2626' : '#1f2937';
                toast.style.display = 'block';
                toast.classList.remove('opacity-0', 'translate-x-full');
                setTimeout(() => {
                    toast.classList.add('opacity-0', 'translate-x-full');
                    // After transition completes, hide it completely
                    setTimeout(() => {
                        toast.style.display = 'none';
                    }, 300); // Wait for transition to complete (0.3s)
                }, 2500);
            }
            function showConfirmation(title, message, onConfirm) {
                confirmTitle.textContent = title;
                confirmMessage.textContent = message;
                confirmActionBtn.onclick = () => { onConfirm(); confirmModal.classList.add('hidden'); };
                cancelConfirmBtn.onclick = () => confirmModal.classList.add('hidden');
                confirmModal.classList.remove('hidden', 'items-center', 'justify-center');
                confirmModal.classList.add('flex', 'items-center', 'justify-center');
            }

            // --- DATABASE & PROJECT LOGIC ---
            function initDB() {
                return new Promise((resolve, reject) => {
                    if (db) return resolve(db);
                    const request = indexedDB.open('SVGProjectsDB', 2);
                    request.onupgradeneeded = e => { const db = e.target.result; if (!db.objectStoreNames.contains('projects')) db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true }); };
                    request.onsuccess = e => { db = e.target.result; resolve(db); };
                    request.onerror = e => reject('Database error: ' + e.target.errorCode);
                });
            }

            // Delete IndexedDB database completely
            function deleteDatabase() {
                return new Promise((resolve, reject) => {
                    if (db) {
                        db.close();
                        db = null;
                    }
                    const deleteRequest = indexedDB.deleteDatabase('SVGProjectsDB');
                    deleteRequest.onsuccess = () => resolve();
                    deleteRequest.onerror = () => reject('Failed to delete database');
                    deleteRequest.onblocked = () => {
                        // Database is blocked, try again after a short delay
                        setTimeout(() => deleteDatabase().then(resolve).catch(reject), 100);
                    };
                });
            }

            // Reset app completely - clears everything and reloads
            async function resetApp() {
                if (!confirm('RESET APP?\n\nThis will:\n- Delete ALL projects\n- Clear ALL cache\n- Delete ALL stored data\n- Reset app to fresh state\n- Reload the page\n\nThis action CANNOT be undone!')) {
                    return;
                }

                try {
                    loader.classList.remove('hidden');
                    showToast('Resetting app...');

                    // Clear all cache
                    clearCache();

                    // Clear localStorage and sessionStorage
                    try {
                        localStorage.clear();
                        sessionStorage.clear();
                    } catch (e) {
                        console.warn("Failed to clear storage:", e);
                    }

                    // Delete IndexedDB database
                    try {
                        await deleteDatabase();
                    } catch (e) {
                        console.warn("Failed to delete database:", e);
                    }

                    // Reset all app state variables
                    currentProjectId = null;
                    currentProjectName = 'Untitled Project';
                    isDirty = false;
                    history = [];
                    historyIndex = -1;
                    drawingHistory = [];
                    drawingHistoryIndex = -1;
                    selectionHistory = [];
                    selectionHistoryIndex = -1;
                    referenceImage = null;
                    tempColorImageHref = null;
                    previewImageHref = null;
                    previewImageState = { x: 100, y: 100, width: 200, height: 200, baseWidth: 200, baseHeight: 200, visible: true, zoom: 1.0, panX: 0, panY: 0 };
                    colorRefImageState = { x: 0, y: 0, width: 1000, height: 1000, opacity: 1.0 };
                    selectionMask = null;
                    selectionPath = null;
                    selectionViewBox = null;
                    selectionBounds = null;
                    cachedShrunkMask = null;
                    currentSelectionClipPathId = null;
                    refModeEnabled = false;
                    autoRefOpacityEnabled = false; // NEW
                    refModeCurrentColor = null;
                    refModeInitialColor = null;
                    isEditingColorRef = false;
                    currentTool = 'pencil';
                    // autoRefOpacityEnabled = false; // Already reset above
                    currentColor = '#000000';
                    currentStrokeWidth = 2;
                    currentStrokeOpacity = 1.0;
                    currentStrokeBlur = 0;
                    stickyPencilActive = false;
                    isTempPencilActive = false;
                    wetPaintEnabled = false;
                    glossyEffectEnabled = false;
                    glitterEffectEnabled = false;
                    zeroOpacityStrokesEnabled = false;
                    autoColorPickMode = false;
                    importedSvgPaths = [];
                    savedTraceOpacity = 1.0;
                    isSelectionVisible = true; // NEW: Reset selection visibility

                    // Clear canvas and layers
                    if (drawingLayer) {
                        drawingLayer.innerHTML = '';
                        drawingLayerVersion++;
                    }
                    if (imageMask) imageMask.innerHTML = '';
                    if (previewLayer) previewLayer.innerHTML = '';
                    if (refModeImage) {
                        refModeImage.setAttribute('visibility', 'hidden');
                        refModeImage.removeAttribute('href');
                    }
                    if (colorPickerImage) {
                        colorPickerImage.setAttribute('visibility', 'hidden');
                    }

                    // Clear marching ants
                    if (antsAnimationId) {
                        cancelAnimationFrame(antsAnimationId);
                        antsAnimationId = null;
                    }
                    if (antsCtx) {
                        antsCtx.clearRect(0, 0, antsCanvas.width, antsCanvas.height);
                    }

                    // Clear auto-save interval
                    if (autoSaveIntervalId) {
                        clearInterval(autoSaveIntervalId);
                        autoSaveIntervalId = null;
                    }

                    // Clear any timers
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }

                    // Reset viewBox to default
                    viewBox = { x: 0, y: 0, w: 1000, h: 1000 };

                    // Reset drawing layer version
                    drawingLayerVersion = 0;

                    // Clear cache again to be sure
                    clearCache();

                    showToast('App reset complete. Reloading...');

                    // Reload the page after a short delay
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);

                } catch (e) {
                    console.error("Error resetting app:", e);
                    showToast("Error resetting app. Please reload manually.", true);
                    loader.classList.add('hidden');
                }
            }
            function saveProjectToDB(projectData) {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['projects'], 'readwrite');
                    const store = transaction.objectStore('projects');
                    const request = store.put(projectData);
                    request.onsuccess = e => resolve(e.target.result);
                    request.onerror = e => reject('Failed to save project: ' + e.target.errorCode);
                });
            }
            function loadProjectsFromDB() {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['projects'], 'readonly');
                    const store = transaction.objectStore('projects');
                    // OPTIMIZATION: Use cursor to load only metadata to prevent crash on load
                    const request = store.openCursor();
                    const projects = [];

                    request.onsuccess = e => {
                        const cursor = e.target.result;
                        if (cursor) {
                            // Only extract lightweight metadata
                            projects.push({
                                id: cursor.value.id,
                                name: cursor.value.name,
                                lastModified: cursor.value.lastModified
                            });
                            cursor.continue();
                        } else {
                            resolve(projects.sort((a, b) => (b.lastModified || 0) - (a.lastModified || 0)));
                        }
                    };
                    request.onerror = e => reject('Failed to load projects: ' + e.target.errorCode);
                });
            }
            function loadProjectFromDB(id) {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['projects'], 'readonly');
                    const store = transaction.objectStore('projects');
                    const request = store.get(id);
                    request.onsuccess = e => resolve(e.target.result);
                    request.onerror = e => reject('Failed to load project: ' + e.target.errorCode);
                });
            }
            function deleteProjectFromDB(id) {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(['projects'], 'readwrite');
                    const store = transaction.objectStore('projects');
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = e => reject('Failed to delete project: ' + e.target.errorCode);
                });
            }

            function gatherProjectData() {
                return {
                    name: currentProjectName,
                    lastModified: new Date(),
                    svgContent: drawingLayer.innerHTML,
                    defsContent: defs.innerHTML,
                    referenceImage: referenceImage ? {
                        href: referenceImage.getAttribute('href'), // Save full base64 data URL
                        width: referenceImage.getAttribute('width'),
                        height: referenceImage.getAttribute('height'),
                        x: referenceImage.getAttribute('x'),
                        y: referenceImage.getAttribute('y'),
                        opacity: referenceImage.getAttribute('opacity')
                    } : null,
                    viewBox: viewBox,
                    settings: getSettings(),
                    tempColorImageHref: tempColorImageHref, // This is already a base64 data URL
                    colorRefImageState: colorRefImageState,
                    refModeEnabled: refModeEnabled, // Save ref mode state
                    bgImageHref: bgImageHref,
                    bgImageState: bgImageState,
                    drawingLayerVersion: drawingLayerVersion, // Save version for cache validity
                    cache: serializeCache() || null // Save cache with project (fallback to null on error)
                };
            }
            function applyProjectData(project) {
                currentProjectId = project.id || null;
                currentProjectName = project.name || 'Untitled Project';
                currentProjectNameEl.textContent = currentProjectName;

                viewBox = project.viewBox || { x: 0, y: 0, w: 1000, h: 1000 };
                setViewBox();

                // MODIFICATION: Call applyHistoryState with the full project state
                applyHistoryState({
                    drawing: project.svgContent || '',
                    defs: project.defsContent || '',
                    image: project.referenceImage || null,
                    tempColorImageHref: project.tempColorImageHref || null,
                    colorRefImageState: project.colorRefImageState || { x: 0, y: 0, width: 1000, height: 1000, opacity: 1.0 },
                    bgImageHref: project.bgImageHref || null,
                    bgImageState: project.bgImageState || { opacity: 1.0, visible: true }
                });

                // Restore drawing layer version if available, otherwise it starts at 1 (from applyHistoryState)
                if (typeof project.drawingLayerVersion === 'number') {
                    drawingLayerVersion = project.drawingLayerVersion;
                }

                // Apply settings from the project
                applySettings(project.settings);

                // Restore ref mode state if it was saved
                if (project.refModeEnabled && tempColorImageHref) {
                    refModeEnabled = true;
                    if (refModeToggle) refModeToggle.checked = true;
                    // Sync the ref mode image
                    if (refModeImage && typeof syncRefModeImage === 'function') {
                        syncRefModeImage();
                    }
                } else {
                    refModeEnabled = false;
                    if (refModeToggle) refModeToggle.checked = false;
                    // Hide ref mode image
                    if (refModeImage) {
                        refModeImage.setAttribute('visibility', 'hidden');
                    }
                }

                // Load cache for this project
                try {
                    if (project.cache && typeof project.cache === 'object') {
                        deserializeCache(project.cache);
                    } else {
                        clearCache(); // Clear cache if project has no cache
                    }
                } catch (e) {
                    console.warn("Failed to load project cache, clearing cache:", e);
                    clearCache(); // Clear cache on error
                }

                updateCanvasOverlays();

                // Clear history and add this loaded state as the first entry
                history = [];
                historyIndex = -1;

                // FIX: Also clear specialized histories to prevent state corruption from previous projects
                drawingHistory = [];
                drawingHistoryIndex = -1;
                selectionHistory = [];
                selectionHistoryIndex = -1;

                addHistoryState();
                isDirty = false;
                saveProjectBtn.disabled = true;
            }

            async function handleNewProject() {
                projectNameModalTitle.textContent = "Create New Project";
                projectNameInput.value = `New Project ${new Date().toLocaleTimeString()}`;
                projectNameModal.classList.remove('hidden');
                projectNameInput.focus();
                projectNameInput.select();

                confirmSaveNameBtn.onclick = async () => {
                    const newName = projectNameInput.value.trim();
                    if (!newName) return;

                    projectNameModal.classList.add('hidden');

                    // Reset Shade Mode when starting a new project
                    isShadeMode = false;
                    if (shortcutShadeBtn) shortcutShadeBtn.classList.remove('active');
                    if (shadeDarkenContainer) shadeDarkenContainer.classList.add('hidden');
                    mainColorBackup = null;
                    mainSettingsBackup = null;

                    const baseDefs = defs.innerHTML; // Get base defs from the HTML

                    const newProjectData = {
                        name: newName,
                        lastModified: new Date(),
                        svgContent: '',
                        defsContent: baseDefs,
                        referenceImage: null,
                        viewBox: { x: 0, y: 0, w: 1000, h: 1000 },
                        settings: getSettings(),
                        tempColorImageHref: null,
                        colorRefImageState: { x: 0, y: 0, width: 1000, height: 1000, opacity: 1.0 },
                        refModeEnabled: false, // New projects start with ref mode off
                        // NEW: Preserve background image for new projects
                        bgImageHref: bgImageHref,
                        bgImageState: { ...bgImageState },
                        cache: null // New project starts with empty cache
                    };

                    // Clear cache for new project
                    clearCache();

                    try {
                        const savedId = await saveProjectToDB(newProjectData);
                        newProjectData.id = savedId;
                        // Invalidate cache to refresh project list
                        cachedProjects = null;
                        applyProjectData(newProjectData);
                        showToast(`Project "${newName}" created!`);
                        projectsModal.classList.add('hidden');
                        showMainApp();
                        setupAutoSave();
                    } catch (e) {
                        showToast("Error creating project.", true);
                        console.error(e);
                    }
                };
            }
            async function handleSaveProject(isSaveAs = false, isSilent = false) {
                const performSave = async (name, isSilentSave = false) => {
                    currentProjectName = name;
                    currentProjectNameEl.textContent = name;
                    const projectData = gatherProjectData();
                    try {
                        if (currentProjectId && !isSaveAs) {
                            projectData.id = currentProjectId;
                        }

                        const savedId = await saveProjectToDB(projectData);
                        currentProjectId = savedId;
                        isDirty = false;
                        saveProjectBtn.disabled = true;
                        // Invalidate cache to refresh project list
                        cachedProjects = null;
                        if (!isSilentSave) {
                            showToast(`Project "${name}" saved!`);
                        }
                    } catch (e) {
                        showToast("Error saving project.", true);
                        console.error(e);
                    }
                };

                if (!currentProjectId || isSaveAs) {
                    projectNameModalTitle.textContent = isSaveAs ? "Save As New Project" : "Save Project";
                    projectNameInput.value = isSaveAs ? `${currentProjectName} Copy` : currentProjectName;
                    projectNameModal.classList.remove('hidden');
                    projectNameInput.focus();
                    projectNameInput.select();
                    confirmSaveNameBtn.onclick = () => {
                        const newName = projectNameInput.value.trim();
                        if (newName) {
                            if (isSaveAs) currentProjectId = null;

                            performSave(newName, false);
                            projectNameModal.classList.add('hidden');
                        }
                    };
                } else {
                    await performSave(currentProjectName, isSilent);
                }
            }
            async function handleLoadProject(id, showToastMsg = true) {
                try {
                    const project = await loadProjectFromDB(id);
                    if (project) {
                        applyProjectData(project);
                        if (showToastMsg) showToast(`Loaded "${project.name}".`);
                        projectsModal.classList.add('hidden');
                        showMainApp();
                        switchTool(project.settings?.tool || 'pencil');
                        setupAutoSave();
                    } else {
                        if (showToastMsg) showToast("Project not found.", true);
                    }
                } catch (e) {
                    if (showToastMsg) showToast("Error loading project.", true);
                    console.error(e);
                }
            }
            async function handleRenameProject(id, name) {
                projectNameModalTitle.textContent = "Rename Project";
                projectNameInput.value = name;
                projectNameModal.classList.remove('hidden');
                projectNameInput.focus();
                projectNameInput.select();

                confirmSaveNameBtn.onclick = async () => {
                    const newName = projectNameInput.value.trim();
                    if (!newName) return;

                    try {
                        const projectToRename = await loadProjectFromDB(id);
                        if (projectToRename) {
                            projectToRename.name = newName;
                            projectToRename.lastModified = new Date();
                            await saveProjectToDB(projectToRename);
                            // Invalidate cache to refresh project list
                            cachedProjects = null;

                            if (id === currentProjectId) {
                                currentProjectName = newName;
                                currentProjectNameEl.textContent = newName;
                            }

                            projectNameModal.classList.add('hidden');
                            await populateProjectsList();
                        }
                    } catch (e) {
                        showToast("Error renaming project.", true);
                        console.error(e);
                    }
                };
            }
            function renderProjectsList(projects) {
                // Multi-select state
                let selectionMode = false;
                let selectedProjects = new Set();
                let pressTimer = null;

                if (projects.length === 0) {
                    projectsListContainer.innerHTML = `
            <div class="project-list-message">
                <p class="font-semibold text-gray-800">No saved projects yet.</p>
                <p class="text-sm text-gray-500 mt-1">Create a project to see it listed here.</p>
            </div>`;
                    return;
                }

                const sortedProjects = [...projects].sort((a, b) => {
                    const timeA = a.lastModified ? new Date(a.lastModified).getTime() : 0;
                    const timeB = b.lastModified ? new Date(b.lastModified).getTime() : 0;
                    return timeB - timeA;
                });

                // Create container with delete selected button at top
                const container = document.createElement('div');

                // Delete selected button container
                const deleteSelectedContainer = document.createElement('div');
                deleteSelectedContainer.className = 'delete-selected-container';

                const selectionInfo = document.createElement('span');
                selectionInfo.className = 'font-semibold text-gray-800';
                selectionInfo.textContent = '0 projects selected';

                const buttonGroup = document.createElement('div');
                buttonGroup.style.display = 'flex';
                buttonGroup.style.gap = '0.5rem';

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-selected-btn';
                deleteBtn.textContent = 'Delete Selected';
                deleteBtn.disabled = true;

                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'delete-selected-btn';
                cancelBtn.style.backgroundColor = '#6b7280';
                cancelBtn.textContent = 'Cancel';

                const selectAllBtn = document.createElement('button');
                selectAllBtn.className = 'delete-selected-btn';
                selectAllBtn.style.backgroundColor = '#3b82f6';
                selectAllBtn.textContent = 'Select All';

                buttonGroup.appendChild(selectAllBtn);
                buttonGroup.appendChild(deleteBtn);
                buttonGroup.appendChild(cancelBtn);
                deleteSelectedContainer.appendChild(selectionInfo);
                deleteSelectedContainer.appendChild(buttonGroup);

                // Project list
                const projectList = document.createElement('div');
                projectList.className = 'project-list';

                const updateSelectionUI = () => {
                    projectList.classList.toggle('selection-mode', selectionMode);
                    deleteSelectedContainer.style.display = selectionMode ? 'flex' : 'none';

                    const count = selectedProjects.size;
                    selectionInfo.textContent = `${count} project${count !== 1 ? 's' : ''} selected`;
                    deleteBtn.disabled = count === 0;
                };

                cancelBtn.addEventListener('click', () => {
                    selectionMode = false;
                    selectedProjects.clear();
                    document.querySelectorAll('.project-item').forEach(item => {
                        item.classList.remove('selected');
                        const checkbox = item.querySelector('.project-checkbox');
                        if (checkbox) checkbox.checked = false;
                    });
                    selectAllBtn.textContent = 'Select All';
                    updateSelectionUI();
                });

                selectAllBtn.addEventListener('click', () => {
                    if (!selectionMode) {
                        selectionMode = true;
                    }

                    // Toggle select all/deselect all
                    if (selectedProjects.size === sortedProjects.length) {
                        // Deselect all
                        selectedProjects.clear();
                        document.querySelectorAll('.project-item').forEach(item => {
                            item.classList.remove('selected');
                            const checkbox = item.querySelector('.project-checkbox');
                            if (checkbox) checkbox.checked = false;
                        });
                        selectAllBtn.textContent = 'Select All';
                    } else {
                        // Select all
                        sortedProjects.forEach(project => {
                            selectedProjects.add(project.id);
                        });
                        document.querySelectorAll('.project-item').forEach(item => {
                            item.classList.add('selected');
                            const checkbox = item.querySelector('.project-checkbox');
                            if (checkbox) checkbox.checked = true;
                        });
                        selectAllBtn.textContent = 'Deselect All';
                    }
                    updateSelectionUI();
                });

                deleteBtn.addEventListener('click', async () => {
                    const count = selectedProjects.size;
                    const confirmed = confirm(`Delete ${count} selected project${count !== 1 ? 's' : ''}? This action cannot be undone.`);

                    if (confirmed) {
                        try {
                            // Delete all selected projects
                            for (const id of selectedProjects) {
                                await deleteProjectFromDB(id);

                                // If current project is deleted, clear it
                                if (id === currentProjectId) {
                                    currentProjectId = null;
                                    currentProjectName = 'Untitled Project';
                                    currentProjectNameEl.textContent = currentProjectName;
                                    mainAppContainer.classList.add('hidden');
                                    mainAppContainer.classList.remove('flex');
                                }
                            }

                            showToast(`Deleted ${count} project${count !== 1 ? 's' : ''}.`);
                            // Invalidate cache to refresh project list
                            cachedProjects = null;
                            selectionMode = false;
                            selectedProjects.clear();
                            selectAllBtn.textContent = 'Select All';
                            await populateProjectsList();
                        } catch (e) {
                            showToast('Error deleting projects.', true);
                            console.error(e);
                        }
                    }
                });

                sortedProjects.forEach(project => {
                    const safeName = project.name || 'Untitled Project';
                    const lastSavedDate = project.lastModified ? new Date(project.lastModified) : null;
                    const hasValidDate = lastSavedDate && !isNaN(lastSavedDate.getTime());
                    const lastSaved = hasValidDate ? lastSavedDate.toLocaleString() : 'Not saved yet';

                    const item = document.createElement('div');
                    item.className = 'project-item';
                    item.setAttribute('role', 'button');
                    item.setAttribute('tabindex', '0');

                    // Checkbox (hidden by default, shown in selection mode)
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'project-checkbox';
                    checkbox.addEventListener('change', (e) => {
                        e.stopPropagation();
                        if (checkbox.checked) {
                            selectedProjects.add(project.id);
                            item.classList.add('selected');
                        } else {
                            selectedProjects.delete(project.id);
                            item.classList.remove('selected');
                        }

                        // Update Select All button text
                        if (selectedProjects.size === sortedProjects.length) {
                            selectAllBtn.textContent = 'Deselect All';
                        } else {
                            selectAllBtn.textContent = 'Select All';
                        }

                        updateSelectionUI();
                    });

                    const meta = document.createElement('div');
                    meta.className = 'project-meta';

                    const nameEl = document.createElement('p');
                    nameEl.className = 'project-name';
                    nameEl.textContent = safeName;

                    const dateEl = document.createElement('p');
                    dateEl.className = 'project-updated';
                    dateEl.textContent = `Last saved ${lastSaved}`;

                    meta.appendChild(nameEl);
                    meta.appendChild(dateEl);

                    const actions = document.createElement('div');
                    actions.className = 'project-actions';

                    const openBtn = document.createElement('button');
                    openBtn.className = 'project-action-btn primary';
                    openBtn.textContent = 'Open';

                    const renameBtn = document.createElement('button');
                    renameBtn.className = 'project-action-btn ghost';
                    renameBtn.textContent = 'Rename';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'project-action-btn danger';
                    deleteBtn.textContent = 'Delete';

                    actions.append(openBtn, renameBtn, deleteBtn);
                    item.append(checkbox, meta, actions);
                    projectList.appendChild(item);

                    const openProject = () => {
                        if (selectionMode) return; // Don't open in selection mode
                        if (project.id == null) return;
                        handleLoadProject(project.id);
                    };

                    // Long press detection
                    const startPress = (e) => {
                        if (selectionMode) return; // Already in selection mode

                        pressTimer = setTimeout(() => {
                            // Enter selection mode
                            selectionMode = true;
                            selectedProjects.add(project.id);
                            checkbox.checked = true;
                            item.classList.add('selected');
                            updateSelectionUI();

                            // Vibrate if supported (mobile feedback)
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }, 500); // 500ms long press
                    };

                    const endPress = () => {
                        if (pressTimer) {
                            clearTimeout(pressTimer);
                            pressTimer = null;
                        }
                    };

                    // Click handler
                    item.addEventListener('click', (e) => {
                        if (selectionMode) {
                            // In selection mode, toggle selection
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change'));
                        } else {
                            // Normal mode, open project
                            openProject();
                        }
                    });

                    // Touch events for long press
                    item.addEventListener('touchstart', startPress, { passive: true });
                    item.addEventListener('touchend', endPress, { passive: true });
                    item.addEventListener('touchcancel', endPress, { passive: true });
                    item.addEventListener('touchmove', endPress, { passive: true });

                    // Mouse events for long press
                    item.addEventListener('mousedown', startPress);
                    item.addEventListener('mouseup', endPress);
                    item.addEventListener('mouseleave', endPress);

                    // Keyboard support
                    item.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            if (selectionMode) {
                                checkbox.checked = !checkbox.checked;
                                checkbox.dispatchEvent(new Event('change'));
                            } else {
                                openProject();
                            }
                        }
                    });

                    openBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!selectionMode) openProject();
                    });

                    renameBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!selectionMode) handleRenameProject(project.id, safeName);
                    });

                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (selectionMode) return;

                        showConfirmation('Delete Project?', `Are you sure you want to delete "${safeName}"? This cannot be undone.`, async () => {
                            await deleteProjectFromDB(project.id);
                            // Invalidate cache to refresh project list
                            cachedProjects = null;
                            showToast(`Deleted "${safeName}".`);

                            if (project.id === currentProjectId) {
                                currentProjectId = null;
                                currentProjectName = 'Untitled Project';
                                currentProjectNameEl.textContent = currentProjectName;
                                mainAppContainer.classList.add('hidden');
                                mainAppContainer.classList.remove('flex');
                                if (projectsModal.classList.contains('hidden')) {
                                    handleOpenProjectsModal();
                                }
                            }

                            await populateProjectsList();
                        });
                    });
                });

                container.appendChild(deleteSelectedContainer);
                container.appendChild(projectList);
                projectsListContainer.innerHTML = '';
                projectsListContainer.appendChild(container);
            }

            async function populateProjectsList(useCache = true) {
                // Show cached projects immediately if available
                if (useCache && cachedProjects !== null) {
                    renderProjectsList(cachedProjects);
                } else {
                    projectsListContainer.innerHTML = '<div class="loader mx-auto"></div>';
                }

                try {
                    const projects = await loadProjectsFromDB();
                    // Update cache with fresh data
                    cachedProjects = projects;
                    // Render with fresh data (this will replace the cached view if it was shown)
                    renderProjectsList(projects);

                } catch (e) {
                    projectsListContainer.innerHTML = '<p class="text-center text-red-500 p-4">Could not load projects.</p>';
                    console.error(e);
                }
            }
            function handleOpenProjectsModal() {
                saveAsBtn.style.display = currentProjectId ? 'flex' : 'none';
                projectsModal.classList.remove('hidden');
                projectsModal.classList.add('flex');
                populateProjectsList();
            }
            function setupAutoSave() {
                if (autoSaveIntervalId) clearInterval(autoSaveIntervalId);
                const interval = (parseInt(autosaveIntervalInput.value, 10) || 60) * 1000;
                autoSaveIntervalId = setInterval(() => {
                    if (isDirty && currentProjectId) {
                        handleSaveProject(false, true);
                    }
                }, interval);
            }
            // NEW: Auto Ref Opacity Toggle
            const autoRefOpacityToggle = document.getElementById('auto-ref-opacity-toggle');
            if (autoRefOpacityToggle) {
                autoRefOpacityToggle.addEventListener('change', (e) => {
                    autoRefOpacityEnabled = e.target.checked;
                    // Apply immediate effect based on current tool
                    if (autoRefOpacityEnabled) {
                        if (currentTool === 'magic-wand') {
                            colorRefImageState.opacity = 1.0;
                            colorRefOpacitySlider.value = '1.0';
                            if (colorPickerImage) colorPickerImage.setAttribute('opacity', '1.0');
                            if (refModeImage) refModeImage.setAttribute('opacity', '1.0');
                        } else if (currentTool === 'pencil' || currentTool === 'pencil-2') {
                            colorRefImageState.opacity = 0.0;
                            colorRefOpacitySlider.value = '0.0';
                            if (colorPickerImage) colorPickerImage.setAttribute('opacity', '0.0');
                            if (refModeImage) refModeImage.setAttribute('opacity', '0.0');
                        }
                    }
                    saveUiSettings();
                });
            }

            editColorRefBtn.addEventListener('click', async () => {
                isEditingColorRef = !isEditingColorRef;
                if (isEditingColorRef) {
                    try {
                        await activateColorPicker();
                        switchTool('pan');
                        editColorRefBtn.querySelector('span').textContent = 'Stop Editing Ref';
                    } catch (e) {
                        isEditingColorRef = false;
                    }
                } else {
                    deactivateColorPicker();
                    switchTool('pencil');
                }
                editColorRefBtn.classList.toggle('active', isEditingColorRef);
            });

            saveColorRefBtn.addEventListener('click', () => {
                if (colorPickerImage) {
                    colorRefImageState = {
                        x: parseFloat(colorPickerImage.getAttribute('x')),
                        y: parseFloat(colorPickerImage.getAttribute('y')),
                        width: parseFloat(colorPickerImage.getAttribute('width')),
                        height: parseFloat(colorPickerImage.getAttribute('height')),
                        opacity: parseFloat(colorPickerImage.getAttribute('opacity'))
                    };
                    deactivateColorPicker();
                    switchTool('pencil');
                    showToast("Color Reference settings saved!");
                    addHistoryState('drawing'); // NEW: Add history state
                }
            });
            resetColorRefBtn.addEventListener('click', () => {
                if (!tempColorImageHref) return;
                const img = new Image();
                img.onload = () => {
                    const padding = 0.95, imgAspectRatio = img.width / img.height;
                    const canvasAspectRatio = canvasContainer.clientWidth / canvasContainer.clientHeight;
                    let width, height;
                    if (imgAspectRatio > canvasAspectRatio) { width = viewBox.w * padding; height = width / imgAspectRatio; } else { height = viewBox.h * padding; width = height * imgAspectRatio; }
                    const x = viewBox.x + (viewBox.w - width) / 2, y = viewBox.y + (viewBox.h - height) / 2;

                    colorPickerImage.setAttribute('x', x);
                    colorPickerImage.setAttribute('y', y);
                    colorPickerImage.setAttribute('width', width);
                    colorPickerImage.setAttribute('height', height);
                    colorPickerImage.setAttribute('opacity', 1.0);

                    colorRefOpacitySlider.value = 1.0;
                    showToast("Ref settings reset. Click 'Save' to confirm.");

                    // NEW: Update state and add to history
                    colorRefImageState = { x, y, width, height, opacity: 1.0 };
                    addHistoryState('drawing');
                };
                img.crossOrigin = "anonymous";
                img.src = tempColorImageHref;
            });

            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            // NEW: Mask Brush Event Listeners
            const maskBrushToolBtn = document.getElementById('mask-brush-tool');
            if (maskBrushToolBtn) {
                maskBrushToolBtn.addEventListener('click', () => switchTool('mask-brush'));
            }

            const shortcutMaskBrushBtn = document.getElementById('shortcut-mask-brush-btn');
            if (shortcutMaskBrushBtn) {
                shortcutMaskBrushBtn.addEventListener('click', () => switchTool('mask-brush'));
            }

            const maskBrushSizeSlider = document.getElementById('mask-brush-size-slider');
            const maskBrushSizeValue = document.getElementById('mask-brush-size-value');
            if (maskBrushSizeSlider) {
                maskBrushSizeSlider.addEventListener('input', (e) => {
                    maskBrushSize = parseInt(e.target.value, 10);
                    if (maskBrushSizeValue) maskBrushSizeValue.textContent = `${maskBrushSize}px`;
                });
            }
            canvasUndoBtn.addEventListener('click', undo);
            canvasRedoBtn.addEventListener('click', redo);
            wandUndoBtn.addEventListener('click', undo); // NEW
            wandRedoBtn.addEventListener('click', redo); // NEW
            // NEW: Bottom left undo/redo buttons
            if (bottomLeftUndoBtn) bottomLeftUndoBtn.addEventListener('click', undo);
            if (bottomLeftRedoBtn) bottomLeftRedoBtn.addEventListener('click', redo);

            // NEW: Fullscreen functionality
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        // Enter fullscreen
                        if (document.documentElement.requestFullscreen) {
                            document.documentElement.requestFullscreen();
                        } else if (document.documentElement.webkitRequestFullscreen) {
                            document.documentElement.webkitRequestFullscreen();
                        } else if (document.documentElement.msRequestFullscreen) {
                            document.documentElement.msRequestFullscreen();
                        }
                    } else {
                        // Exit fullscreen
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }
                    }
                });

                // Update fullscreen icon based on state
                const updateFullscreenIcon = () => {
                    const isFullscreen = !!document.fullscreenElement ||
                        !!document.webkitFullscreenElement ||
                        !!document.msFullscreenElement;
                    if (isFullscreen) {
                        fullscreenEnterIcon.style.display = 'none';
                        fullscreenExitIcon.style.display = 'block';
                        fullscreenBtn.classList.add('active');
                    } else {
                        fullscreenEnterIcon.style.display = 'block';
                        fullscreenExitIcon.style.display = 'none';
                        fullscreenBtn.classList.remove('active');
                    }
                };

                // Listen for fullscreen changes
                document.addEventListener('fullscreenchange', updateFullscreenIcon);
                document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
                document.addEventListener('msfullscreenchange', updateFullscreenIcon);

                // Initial icon state
                updateFullscreenIcon();
            }

            clearBtn.addEventListener('click', () => showConfirmation('Clear Canvas?', 'This will erase all drawings on the canvas. This action does not delete the project.', () => {
                // Clear cache when canvas is cleared
                clearCache('strokes');
                clearCache('fills');
                deselect();
                drawingLayer.innerHTML = '';

                // Re-create strokes layer
                maskedStrokesLayer = createSvgElement('g', { id: 'masked-strokes-layer' });
                drawingLayer.appendChild(maskedStrokesLayer);

                // Re-create base defs but keep custom filters
                const baseDefs = `<filter id="trace-mask-filter"><feColorMatrix type="matrix" values="0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"/><feComponentTransfer><feFuncA type="table" tableValues="0 1 1 1 1 1 1 1 1 1 1"/></feComponentTransfer></filter><mask id="image-mask"></mask>`;
                defs.innerHTML = baseDefs + document.getElementById('svg-canvas').querySelector('defs').innerHTML; // Keep blur filters
                imageMask = document.getElementById('image-mask');

                deleteReferenceImage(false);
                addHistoryState('drawing');
            }));
            cancelConfirmBtn.addEventListener('click', () => confirmModal.classList.add('hidden'));
            exportBtn.addEventListener('click', exportSVG);
            // PNG Export Modal Event Listeners
            if (exportPngBtn) {
                exportPngBtn.addEventListener('click', () => {
                    showPngExportModal();
                });
            }

            if (closePngExportModalBtn) {
                closePngExportModalBtn.addEventListener('click', () => {
                    pngExportModal.classList.add('hidden');
                    pngExportModal.classList.remove('flex');
                });
            }

            if (cancelPngExportBtn) {
                cancelPngExportBtn.addEventListener('click', () => {
                    pngExportModal.classList.add('hidden');
                    pngExportModal.classList.remove('flex');
                });
            }

            if (confirmPngExportBtn) {
                confirmPngExportBtn.addEventListener('click', async () => {
                    // Get selected scale
                    let selectedScale = 2;
                    if (pngScaleSelect.value === 'custom') {
                        selectedScale = parseFloat(pngCustomScale.value);
                    } else {
                        selectedScale = parseFloat(pngScaleSelect.value);
                    }

                    // Validate scale (1-8)
                    selectedScale = Math.max(1, Math.min(8, selectedScale));
                    pngExportScale = selectedScale;

                    // Close modal
                    pngExportModal.classList.add('hidden');
                    pngExportModal.classList.remove('flex');

                    // Export with selected scale
                    await exportPNG(selectedScale);
                });
            }

            // Update preview when scale changes
            if (pngScaleSelect) {
                pngScaleSelect.addEventListener('change', () => {
                    if (pngScaleSelect.value === 'custom') {
                        pngCustomScaleContainer.classList.remove('hidden');
                        pngCustomScale.value = pngExportScale.toString();
                    } else {
                        pngCustomScaleContainer.classList.add('hidden');
                        const scale = parseFloat(pngScaleSelect.value);
                        const presetMap = { 2: 'standard', 3: 'high', 4: 'very-high', 5: 'ultra', 8: 'maximum' };
                        if (pngQualityPreset) {
                            pngQualityPreset.value = presetMap[scale] || 'high';
                        }
                    }
                    updatePngExportPreview();
                });
            }

            // Update preset dropdown
            if (pngQualityPreset) {
                pngQualityPreset.addEventListener('change', () => {
                    const presetScales = { 'standard': 2, 'high': 3, 'very-high': 4, 'ultra': 5, 'maximum': 8 };
                    const scale = presetScales[pngQualityPreset.value];
                    if (scale && pngScaleSelect) {
                        pngScaleSelect.value = scale.toString();
                        pngCustomScaleContainer.classList.add('hidden');
                        updatePngExportPreview();
                    }
                });
            }

            // Update custom scale
            if (pngCustomScale && pngCustomScaleValue && pngDimensionsPreview) {
                pngCustomScale.addEventListener('input', () => {
                    const scale = parseFloat(pngCustomScale.value);
                    pngCustomScaleValue.textContent = `${scale}x`;
                    const width = Math.round(viewBox.w * scale);
                    const height = Math.round(viewBox.h * scale);
                    pngDimensionsPreview.textContent = `Dimensions: ${width} x ${height} px`;
                    updatePngExportPreview();
                });
            }
            pencilModeSelect.addEventListener('change', (e) => { if (e.target.value === 'smoothness') { smoothnessSliderContainer.classList.remove('hidden'); fixedNodesSliderContainer.classList.add('hidden'); } else { smoothnessSliderContainer.classList.add('hidden'); fixedNodesSliderContainer.classList.remove('hidden'); } saveUiSettings(); });
            simplifySlider.addEventListener('input', (e) => {
                pathTolerance = parseFloat(e.target.value);
                simplifyValue.textContent = pathTolerance.toFixed(1);
                if (isShadeMode) {
                    shadeSettings.smoothness = pathTolerance;
                    if (shadeSmoothnessSlider) {
                        shadeSmoothnessSlider.value = pathTolerance;
                        shadeSmoothnessValue.textContent = pathTolerance.toFixed(1);
                    }
                }
                saveUiSettings();
            });

            // NEW: Shade Darken Listener (Sync Bottom and Panel)
            function updateShadeDarkness(val) {
                const amount = parseInt(val) / 100;
                shadeSettings.darkenAmount = amount;

                // Update UI element
                if (shadeDarkenSlider && shadeDarkenValue) {
                    shadeDarkenSlider.value = val;
                    shadeDarkenValue.textContent = `${val}%`;
                }

                if (isShadeMode && mainColorBackup) {
                    const newColor = getDarkenedColor(mainColorBackup, amount);
                    selectColor(newColor);
                }
                saveUiSettings();
            }

            if (shadeDarkenSlider) {
                shadeDarkenSlider.addEventListener('input', (e) => updateShadeDarkness(e.target.value));
            }
            pencilNodesSlider.addEventListener('input', (e) => { fixedNodeCount = parseInt(e.target.value, 10); pencilNodesValue.textContent = fixedNodeCount; saveUiSettings(); });

            stickyPencilToggle.addEventListener('change', (e) => {
                stickyPencilActive = e.target.checked;
                isStickyDrawing = false;
                interactionState = 'idle';
                saveUiSettings();
            });

            if (fillExportToggle) {
                fillExportToggle.addEventListener('change', (e) => {
                    deleteFillOnExport = e.target.checked;
                    saveUiSettings();
                });
            }

            tempStrokeToggle.addEventListener('change', (e) => {
                isTempPencilActive = e.target.checked;
                saveUiSettings();
            });

            // NEW: Auto Color Pick Toggle
            autoColorPickToggle.addEventListener('change', (e) => {
                autoColorPickMode = e.target.checked;
                saveUiSettings();
                // If there's an active selection, update the display
                if (selectionMask && autoColorPickMode) {
                    // Hide marching ants
                    antsCtx.clearRect(0, 0, antsCanvas.width, antsCanvas.height);
                    if (antsAnimationId) {
                        cancelAnimationFrame(antsAnimationId);
                        antsAnimationId = null;
                    }
                } else if (selectionMask && !autoColorPickMode) {
                    // Show marching ants
                    startMarchingAnts();
                }
            });

            // NEW: Auto Stroke Path Toggle
            autoStrokePathToggle.addEventListener('change', (e) => {
                autoStrokePathEnabled = e.target.checked;

                // NEW: When auto stroke is enabled, disable auto color pick
                if (autoStrokePathEnabled) {
                    autoColorPickMode = false;
                    autoColorPickToggle.checked = false;
                    // Hide marching ants if selection exists
                    if (selectionMask) {
                        antsCtx.clearRect(0, 0, antsCanvas.width, antsCanvas.height);
                        if (antsAnimationId) {
                            cancelAnimationFrame(antsAnimationId);
                            antsAnimationId = null;
                        }
                    }
                } else {
                    // When auto stroke is disabled, enable auto color pick
                    autoColorPickMode = true;
                    autoColorPickToggle.checked = true;
                    // Show marching ants if selection exists
                    if (selectionMask) {
                        startMarchingAnts();
                    }
                }

                saveUiSettings();
            });

            // NEW: Canvas Auto Stroke Toggle Button
            canvasAutoStrokeToggleBtn.addEventListener('click', () => {
                autoStrokePathEnabled = !autoStrokePathEnabled;
                autoStrokePathToggle.checked = autoStrokePathEnabled;
                canvasAutoStrokeToggleBtn.classList.toggle('active', autoStrokePathEnabled);
                // Trigger change event to run the auto color pick sync logic
                autoStrokePathToggle.dispatchEvent(new Event('change'));
            });

            // NEW: Canvas Auto Ref Opacity Toggle Button
            canvasAutoRefOpacityToggleBtn.addEventListener('click', () => {
                autoRefOpacityEnabled = !autoRefOpacityEnabled;
                autoRefOpacityToggle.checked = autoRefOpacityEnabled;
                canvasAutoRefOpacityToggleBtn.classList.toggle('active', autoRefOpacityEnabled);
                // Trigger the same effect as the checkbox
                autoRefOpacityToggle.dispatchEvent(new Event('change'));
                saveUiSettings();
            });

            // NEW: Auto Stroke U-Turn Step Slider
            autoStrokeUturnSlider.addEventListener('input', (e) => {
                autoStrokeUturnMultiplier = parseFloat(e.target.value);
                autoStrokeUturnValue.textContent = autoStrokeUturnMultiplier.toFixed(2);
                saveUiSettings();
            });

            // NEW: Auto Stroke Style Select
            autoStrokeStyleSelect.addEventListener('change', (e) => {
                autoStrokeStyle = e.target.value;
                saveUiSettings();
            });

            // NEW: Auto Stroke Density Slider
            autoStrokeDensitySlider.addEventListener('input', (e) => {
                autoStrokeDensity = parseInt(e.target.value);
                saveUiSettings();
            });

            // NEW: Wand W (Shape Bounds) Toggle
            if (wandWToggle) {
                wandWToggle.addEventListener('change', (e) => {
                    wandWMode = e.target.checked;
                    saveUiSettings();
                });
            }

            // Function to update delete fill export button appearance
            // NEW: Delete Fill Button - deletes all fills instantly
            if (deleteFillBtn) {
                deleteFillBtn.addEventListener('click', () => {
                    const allPaths = drawingLayer.querySelectorAll('path');
                    let deletedCount = 0;

                    allPaths.forEach(path => {
                        const fill = path.getAttribute('fill');
                        const stroke = path.getAttribute('stroke');
                        // Check if this is a fill path (has fill, no stroke or stroke is none)
                        if (fill && fill !== 'none' && (!stroke || stroke === 'none')) {
                            path.remove();
                            deletedCount++;
                        }
                    });

                    // Also check groups for fill paths
                    const allGroups = drawingLayer.querySelectorAll('g');
                    allGroups.forEach(group => {
                        // Skip our internal strokes layer from being deleted as a "group"
                        if (group.id === 'masked-strokes-layer') return;

                        const groupPaths = group.querySelectorAll('path');
                        groupPaths.forEach(path => {
                            const fill = path.getAttribute('fill');
                            const stroke = path.getAttribute('stroke');
                            if (fill && fill !== 'none' && (!stroke || stroke === 'none')) {
                                path.remove();
                                deletedCount++;
                            }
                        });
                        // Remove empty groups
                        if (group.querySelectorAll('path').length === 0) {
                            group.remove();
                        }
                    });

                    if (deletedCount > 0) {
                        addHistoryState('drawing');
                        showToast(`Deleted ${deletedCount} fill path(s).`);
                    } else {
                        showToast('No fill paths to delete.');
                    }
                });
            }

            // NEW: Delete Imported SVG Button
            if (deleteImportedSvgBtn) {
                deleteImportedSvgBtn.addEventListener('click', () => {
                    const importedPaths = drawingLayer.querySelectorAll('path[data-imported-svg="true"], g[data-imported-svg-group="true"]');
                    let deletedCount = 0;

                    importedPaths.forEach(element => {
                        element.remove();
                        deletedCount++;
                    });

                    // Also remove any groups that might contain imported paths
                    const allGroups = drawingLayer.querySelectorAll('g');
                    allGroups.forEach(group => {
                        const hasImportedPaths = group.querySelectorAll('path[data-imported-svg="true"]').length > 0;
                        if (hasImportedPaths) {
                            group.remove();
                            deletedCount++;
                        }
                    });

                    importedSvgPaths = []; // Clear tracking

                    if (deletedCount > 0) {
                        addHistoryState('drawing');
                        deleteImportedSvgBtn.classList.add('hidden');
                        showToast(`Deleted ${deletedCount} imported SVG element(s).`);
                    } else {
                        showToast('No imported SVG to delete.');
                        deleteImportedSvgBtn.classList.add('hidden');
                    }
                });
            }

            deleteTempStrokesBtn.addEventListener('click', () => {
                const tempStrokes = drawingLayer.querySelectorAll('path[data-temp-stroke="true"]');
                if (tempStrokes.length > 0) {
                    tempStrokes.forEach(path => path.remove());
                    addHistoryState('drawing');
                    showToast(`Deleted ${tempStrokes.length} temporary strokes.`);
                } else {
                    showToast('No temporary strokes to delete.');
                }
            });

            // NEW: Delete Fill Paths Button
            deleteFillPathsBtn.addEventListener('click', () => {
                const allPaths = drawingLayer.querySelectorAll('path');
                let deletedCount = 0;

                allPaths.forEach(path => {
                    const fill = path.getAttribute('fill');
                    const stroke = path.getAttribute('stroke');
                    // Check if this is a fill path (has fill, no stroke or stroke is none)
                    if (fill && fill !== 'none' && (!stroke || stroke === 'none')) {
                        path.remove();
                        deletedCount++;
                    }
                });

                if (deletedCount > 0) {
                    addHistoryState('drawing');
                    showToast(`Deleted ${deletedCount} fill path(s).`);
                } else {
                    showToast('No fill paths to delete.');
                }
            });

            svgCanvas.addEventListener('pointerdown', onPointerDown);
            svgCanvas.addEventListener('pointermove', onPointerMove);
            svgCanvas.addEventListener('pointerup', onPointerUp);
            svgCanvas.addEventListener('pointerleave', onPointerUp);
            svgCanvas.addEventListener('pointercancel', onPointerUp);

            // --- Wand Toggle Button Draggable Listeners ---
            wandToggleBtn.addEventListener('pointerdown', (e) => {
                if (!wandToggleBtn.classList.contains('visible')) return;

                // Track start position for move detection
                wandBtnStartPointerPos = { x: e.clientX, y: e.clientY };
                hasWandBtnMoved = false;
                isWandBtnDragging = false; // Don't start dragging yet

                wandToggleBtn.setPointerCapture(e.pointerId);

                const btnRect = wandToggleBtn.getBoundingClientRect();
                wandBtnStartOffset = {
                    x: e.clientX - btnRect.left,
                    y: e.clientY - btnRect.top
                };
                e.stopPropagation(); // Don't trigger canvas events
            });

            wandToggleBtn.addEventListener('pointermove', (e) => {
                if (!wandToggleBtn.hasPointerCapture(e.pointerId)) return;

                // Threshold to prevent accidental drags on tiny movements (taps)
                const dx = e.clientX - wandBtnStartPointerPos.x;
                const dy = e.clientY - wandBtnStartPointerPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (!isWandBtnDragging && dist > 5) {
                    isWandBtnDragging = true;
                    hasWandBtnMoved = true;
                    wandToggleBtn.classList.add('dragging');
                }

                if (isWandBtnDragging) {
                    // Position relative to canvasContainer (as updateWandButtonPosition uses)
                    const containerRect = canvasContainer.getBoundingClientRect();
                    let left = e.clientX - containerRect.left - wandBtnStartOffset.x;
                    let top = e.clientY - containerRect.top - wandBtnStartOffset.y;

                    wandBtnManualPos = { left, top };
                    wandToggleBtn.style.left = `${left}px`;
                    wandToggleBtn.style.top = `${top}px`;
                    wandToggleBtn.style.bottom = 'auto';
                    wandToggleBtn.style.right = 'auto';
                }
                e.stopPropagation();
            });

            wandToggleBtn.addEventListener('pointerup', (e) => {
                if (!wandToggleBtn.hasPointerCapture(e.pointerId)) return;

                isWandBtnDragging = false;
                wandToggleBtn.classList.remove('dragging');
                wandToggleBtn.releasePointerCapture(e.pointerId);

                // If it was moved, we want to stop propagation to prevent the click handler 
                // but 'click' event will still fire. We handle that in the click listener.
                if (hasWandBtnMoved) {
                    e.stopPropagation();
                }
            });
            wandToggleBtn.addEventListener('pointercancel', (e) => {
                isWandBtnDragging = false;
                wandToggleBtn.classList.remove('dragging');
                if (wandToggleBtn.hasPointerCapture(e.pointerId)) {
                    wandToggleBtn.releasePointerCapture(e.pointerId);
                }
            });

            svgCanvas.addEventListener('wheel', onWheel, { passive: false });
            // Prevent context menu globally to stop browser menu on long press
            window.addEventListener('contextmenu', e => e.preventDefault(), { passive: false });
            // Throttled resize handler to prevent excessive calls
            const throttledHandleResize = throttle(() => {
                handleResize();
                // Clear cached rects on resize
                cachedRect = null;
                cachedRectTimestamp = 0;
                invalidateViewBoxCache();
            }, 250); // Throttle resize to max once per 250ms

            window.addEventListener('resize', throttledHandleResize);
            cleanupFunctions.push(() => {
                window.removeEventListener('resize', throttledHandleResize);
            });

            window.addEventListener('keydown', (e) => {
                if (projectNameModal.classList.contains('flex') || confirmModal.classList.contains('flex')) {
                    if (e.key === 'Escape') {
                        projectNameModal.classList.add('hidden');
                        confirmModal.classList.add('hidden');
                    }
                    return;
                }

                if (e.key === 'Escape') {
                    e.preventDefault();
                    if (isEditingColorRef) {
                        deactivateColorPicker();
                        switchTool('pencil');
                    } else if (currentTool === 'color-picker') {
                        deactivateColorPicker();
                        switchTool('pencil');
                    } else if (selectionMask) {
                        deselect();
                    }
                }

                if (e.key === 'w' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) && !e.ctrlKey && !e.metaKey && !isEditingColorRef) {
                    e.preventDefault();
                    switchTool('magic-wand');
                }

                if (e.key === 'b' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) && !e.ctrlKey && !e.metaKey && !isEditingColorRef) {
                    e.preventDefault();
                    if (currentTool !== 'color-picker') {
                        activateColorPicker()
                            .then(() => {
                                switchTool('color-picker');
                            })
                            .catch(err => console.error("Color picker activation failed:", err));
                    }
                }

                if (e.key === '1' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    toggleGlitterEffect(true);
                }

                if (e.key === '2' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    toggleWetPaint(true);
                }

                if (e.key === '3' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    toggleWaterMix(true);
                }

                if (e.key === '4' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    toggleWetPaint(false);
                    toggleWaterMix(false);
                    toggleGlitterEffect(false);
                    toggleGlossyEffect(false);
                    if (currentTool !== 'pencil' && currentTool !== 'pencil-2' && currentTool !== 'color-picker') {
                        switchTool('pencil');
                    }
                }

                if (e.key === 'm' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                    e.preventDefault();
                    switchTool('pencil');
                }

                if ((e.ctrlKey || e.metaKey) && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                    if (e.key === 'z') { e.preventDefault(); undo(); }
                    if (e.key === 'y') { e.preventDefault(); redo(); }
                    if (e.key === 's') { e.preventDefault(); if (!saveProjectBtn.disabled) handleSaveProject(false, false); }
                }

                // NEW: Shortcut to toggle selection visibility (Shift+H)
                if (e.shiftKey && e.key === 'H' && !['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                    e.preventDefault();
                    if (showSelectionOutlineToggle) {
                        showSelectionOutlineToggle.checked = !showSelectionOutlineToggle.checked;
                        showSelectionOutlineToggle.dispatchEvent(new Event('change'));
                        showToast(`Selection Outline: ${showSelectionOutlineToggle.checked ? 'Visible' : 'Hidden'}`);
                    }
                }
            });

            // --- EVENT LISTENERS ---
            openSidebarBtn.addEventListener('click', () => {
                sidebar.classList.add('open');
                sidebarBackdrop.classList.remove('hidden');
            });
            closeSidebarBtn.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarBackdrop.classList.add('hidden');
                updateCanvasOverlays();
            });
            sidebarBackdrop.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarBackdrop.classList.add('hidden');
                updateCanvasOverlays();
            });

            imageUpload.addEventListener('change', handleImageUpload);
            importSvgBtn.addEventListener('click', () => svgUpload.click());
            svgUpload.addEventListener('change', handleSvgImport);
            uploadTempImageBtn.addEventListener('click', () => tempImageUpload.click());
            tempImageUpload.addEventListener('change', handleTempImageUpload);
            deleteTempImageBtn.addEventListener('click', handleDeleteTempImage);

            // NEW: Preview Image Event Listeners
            uploadPreviewImageBtn.addEventListener('click', () => previewImageUpload.click());
            previewImageUpload.addEventListener('change', handlePreviewImageUpload);
            togglePreviewImage.addEventListener('change', (e) => {
                previewImageState.visible = e.target.checked;
                updatePreviewImage();
            });
            deletePreviewImageBtn.addEventListener('click', deletePreviewImage);

            // NEW: Background Image Event Listeners
            uploadBgImageBtn.addEventListener('click', () => bgImageUpload.click());
            bgImageUpload.addEventListener('change', handleBgImageUpload);
            bgOpacitySlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                bgImageState.opacity = val;
                bgOpacityValue.textContent = val.toFixed(2);
                updateBgImage();
                saveUiSettings();
            });
            deleteBgImageBtn.addEventListener('click', deleteBgImage);

            // NEW: Pin Image Button Event Listener (Works for both tracing and preview images)
            pinImageBtn.addEventListener('click', togglePinActiveImage);

            // Add wheel zoom for preview image - attach to preview image element when it's visible
            referencePreviewImage.addEventListener('wheel', handlePreviewImageWheel, { passive: false });
            // Preview image interactions are handled in onPointerDown to prevent interference

            // --- NEW: Stroke Width Control Event Listeners ---
            strokeWidthMinusBtn.addEventListener('click', () => {
                if (currentStrokeWidth > 1) {
                    currentStrokeWidth = Math.max(1, currentStrokeWidth - 1);
                    updateStrokeWidthControls();
                }
            });

            strokeWidthPlusBtn.addEventListener('click', () => {
                if (currentStrokeWidth < 50) {
                    currentStrokeWidth = Math.min(50, currentStrokeWidth + 1);
                    updateStrokeWidthControls();
                }
            });

            function updateStrokeWidthControls() {
                // Update sidebar slider
                if (strokeWidthSlider) {
                    strokeWidthSlider.value = currentStrokeWidth;
                }
                if (strokeWidthValue) {
                    strokeWidthValue.textContent = `${currentStrokeWidth}px`;
                }
                // Update bottom-left display
                if (bottomLeftStrokeWidthValue) {
                    bottomLeftStrokeWidthValue.textContent = `${currentStrokeWidth}px`;
                }
                // Update wand/pencil slider if visible
                if (wandPencilSlider) {
                    wandPencilSlider.value = currentStrokeWidth;
                }
                if (wandPencilSliderValue) {
                    wandPencilSliderValue.textContent = `${currentStrokeWidth}px`;
                }
                // Update button states
                if (strokeWidthMinusBtn) {
                    strokeWidthMinusBtn.disabled = currentStrokeWidth <= 1;
                }
                if (strokeWidthPlusBtn) {
                    strokeWidthPlusBtn.disabled = currentStrokeWidth >= 50;
                }
                // Save to settings
                if (typeof saveUiSettings === 'function') {
                    saveUiSettings();
                }
            }

            // Initialize stroke width controls
            updateStrokeWidthControls();

            // --- NEW: Tool Shortcuts Event Listeners ---
            shortcutWandBtn.addEventListener('click', () => {
                // Turn off filter when wand shortcut is clicked
                toggleColorFilter(false);
                // If wand is already active and there's a selection, deselect it
                if (currentTool === 'magic-wand' && selectionMask) {
                    deselect();
                } else {
                    switchTool('magic-wand');
                }
            });
            shortcutFillBtn.addEventListener('click', () => switchTool('paint-bucket'));
            shortcutPencilBtn.addEventListener('click', () => switchTool('pencil'));
            shortcutPanBtn.addEventListener('click', () => switchTool('pan'));
            if (shortcutAutoFillBtn) {
                shortcutAutoFillBtn.addEventListener('click', () => {
                    if (!refModeEnabled) {
                        showToast("Please enable Ref Mode first to use Auto Fill.");
                        return;
                    }
                    runAutoFill();
                });
            }

            if (shortcutRefModeBtn) {
                shortcutRefModeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (refModeToggle) {
                        refModeToggle.click(); // This will trigger the change event and sync states
                    } else {
                        refModeEnabled = !refModeEnabled;
                        if (refModeEnabled) {
                            enableRefMode();
                        } else {
                            disableRefMode();
                        }
                    }
                });
            }
            // NEW: Shortcut Selection Visibility Button
            if (shortcutSelectionVisibilityBtn) {
                shortcutSelectionVisibilityBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // Toggle state
                    isSelectionVisible = !isSelectionVisible;

                    // Update UI Icons
                    const visibleIcon = shortcutSelectionVisibilityBtn.querySelector('svg:not(#selection-hidden-icon)');
                    const hiddenIcon = document.getElementById('selection-hidden-icon');

                    if (visibleIcon && hiddenIcon) {
                        if (isSelectionVisible) {
                            visibleIcon.classList.remove('hidden');
                            hiddenIcon.classList.add('hidden');
                            shortcutSelectionVisibilityBtn.title = "Hide Selection Outline";
                        } else {
                            visibleIcon.classList.add('hidden');
                            hiddenIcon.classList.remove('hidden');
                            shortcutSelectionVisibilityBtn.title = "Show Selection Outline";
                        }
                    }

                    // Update Canvas Visibility
                    if (antsCanvas) {
                        antsCanvas.style.opacity = isSelectionVisible ? '1' : '0';
                    }

                    // If we have a selection, re-run marching ants to ensure correct state
                    if (selectionMask) {
                        startMarchingAnts();
                    }

                    // Sync with sidebar toggle if it exists
                    if (showSelectionOutlineToggle) {
                        showSelectionOutlineToggle.checked = isSelectionVisible;
                    }

                    // Update Wand Toggle Button Visibility
                    if (wandToggleBtn) {
                        wandToggleBtn.style.display = isSelectionVisible ? '' : 'none';
                    }

                    showToast(`Selection Outline: ${isSelectionVisible ? 'Visible' : 'Hidden'}`);
                    saveUiSettings();
                });
            }

            // --- NEW: Floating Color Palette Event Listeners ---
            floatingColorPaletteToggle.addEventListener('click', toggleFloatingPalette);
            floatingPaletteCloseBtn.addEventListener('click', hideFloatingPalette);
            floatingCustomColorInput.addEventListener('input', (e) => {
                selectColor(e.target.value);
                floatingPaletteColors.querySelectorAll('.floating-color-swatch').forEach(s => s.classList.remove('active'));
                // Auto-minimize palette after color selection
                hideFloatingPalette();
            });

            opacitySlider.addEventListener('input', (e) => {
                if (referenceImage) {
                    referenceImage.setAttribute('opacity', e.target.value);
                    activeImageType = 'tracingImage';
                    updatePinButtonState();
                }
                saveUiSettings();
            });
            deleteImageBtn.addEventListener('click', () => deleteReferenceImage(true));
            traceLockCheckbox.addEventListener('change', (e) => {
                const targetLayer = maskedStrokesLayer || drawingLayer;
                targetLayer.setAttribute('mask', e.target.checked ? 'url(#image-mask)' : '');
                saveUiSettings();
            });
            lockImageCheckbox.addEventListener('change', saveUiSettings);

            function setStrokeWidth(width) {
                let val = parseFloat(width);
                if (isNaN(val)) val = 1;
                const newWidth = Math.max(0.01, Math.min(50, val));

                currentStrokeWidth = newWidth;
                // Display up to 2 decimal places if needed, otherwise clean integer
                const displayVal = Number.isInteger(newWidth) ? newWidth : parseFloat(newWidth.toFixed(2));

                strokeWidthValue.textContent = `${displayVal}px`;
                strokeWidthSlider.value = newWidth;
                wandPencilSliderValue.textContent = `${displayVal}px`;
                wandPencilSlider.value = newWidth;

                // NEW: Update clipPath if selection is active (to account for new stroke width)
                if (selectionMask && selectionViewBox) {
                    updateSelectionClipPath(selectionMask, antsCanvas.width, antsCanvas.height);
                }

                saveUiSettings();

                // NEW: Sync Shade settings if active
                if (isShadeMode) {
                    shadeSettings.width = newWidth;
                    if (shadeWidthSlider) {
                        shadeWidthSlider.value = newWidth;
                        shadeWidthValue.textContent = `${displayVal}px`;
                    }
                }
            }
            strokeWidthSlider.addEventListener('input', (e) => setStrokeWidth(e.target.value));
            wandPencilSlider.addEventListener('input', (e) => setStrokeWidth(e.target.value));

            wandPencilMinusBtn.addEventListener('click', () => {
                const currentWidth = parseFloat(wandPencilSlider.value);
                if (currentWidth > 1) {
                    setStrokeWidth(currentWidth - 1);
                } else if (currentWidth > 0.1) {
                    setStrokeWidth(currentWidth - 0.1);
                } else if (currentWidth > 0.02) {
                    setStrokeWidth(currentWidth - 0.01);
                }
            });
            wandPencilPlusBtn.addEventListener('click', () => {
                const currentWidth = parseFloat(wandPencilSlider.value);
                if (currentWidth < 0.1) {
                    setStrokeWidth(currentWidth + 0.01);
                } else if (currentWidth < 1) {
                    setStrokeWidth(currentWidth + 0.1);
                } else if (currentWidth < 50) {
                    setStrokeWidth(currentWidth + 1);
                }
            });

            // NEW: Show/Hide Selection Outline Toggle
            if (showSelectionOutlineToggle) {
                showSelectionOutlineToggle.addEventListener('change', (e) => {
                    isSelectionVisible = e.target.checked;

                    // Update canvas visibility and animation
                    if (selectionMask) {
                        startMarchingAnts();
                    }

                    // Update shortcut button icon state
                    const btn = document.getElementById('shortcut-selection-visibility-btn');
                    if (btn) {
                        const visibleIcon = btn.querySelector('svg:not(#selection-hidden-icon)');
                        const hiddenIcon = btn.querySelector('#selection-hidden-icon');
                        if (visibleIcon && hiddenIcon) {
                            if (isSelectionVisible) {
                                visibleIcon.classList.remove('hidden');
                                hiddenIcon.classList.add('hidden');
                                btn.title = "Hide Selection Outline";
                            } else {
                                visibleIcon.classList.add('hidden');
                                hiddenIcon.classList.remove('hidden');
                                btn.title = "Show Selection Outline";
                            }
                        }
                    }
                    saveUiSettings(); // Save the new state
                });
            }
            // --- NEW Shrink Slider Event Handlers ---
            function setShrinkAmount(amount, { skipSave = false } = {}) {
                const parsed = parseInt(amount, 10);
                const newAmount = Math.max(-5, Math.min(10, isNaN(parsed) ? 0 : parsed));
                selectionShrinkAmount = newAmount;
                const formattedAmount = `${newAmount > 0 ? '+' : ''}${newAmount}px`;
                wandShrinkSliderValue.textContent = formattedAmount;
                wandShrinkSlider.value = newAmount;

                // Invalidate cached shrunk mask
                cachedShrunkMask = null;

                // Regenerate selection path and clipPath with new shrink amount
                if (selectionMask && selectionViewBox && antsCanvas) {
                    generateSelectionPath(selectionMask, antsCanvas.width, antsCanvas.height);
                    startMarchingAnts();
                }

                if (!skipSave) {
                    saveUiSettings();
                }
            }

            wandShrinkSlider.addEventListener('input', (e) => setShrinkAmount(e.target.value));

            wandShrinkMinusBtn.addEventListener('click', () => {
                const currentAmount = parseInt(wandShrinkSlider.value, 10);
                setShrinkAmount(currentAmount - 1);
            });

            wandShrinkPlusBtn.addEventListener('click', () => {
                const currentAmount = parseInt(wandShrinkSlider.value, 10);
                setShrinkAmount(currentAmount + 1);
            });

            // --- NEW Opacity/Blur Listeners ---
            strokeOpacitySlider.addEventListener('input', (e) => {
                currentStrokeOpacity = parseFloat(e.target.value);
                strokeOpacityValue.textContent = currentStrokeOpacity.toFixed(2);
                if (isShadeMode) {
                    shadeSettings.opacity = currentStrokeOpacity;
                    if (shadeOpacitySlider) {
                        shadeOpacitySlider.value = currentStrokeOpacity;
                        shadeOpacityValue.textContent = currentStrokeOpacity.toFixed(2);
                    }
                }
                saveUiSettings();
            });
            strokeBlurSlider.addEventListener('input', (e) => {
                currentStrokeBlur = parseInt(e.target.value, 10);
                strokeBlurValue.textContent = currentStrokeBlur;
                saveUiSettings();
            });
            strokeWidthSlider.addEventListener('input', (e) => {
                currentStrokeWidth = parseInt(e.target.value);
                strokeWidthValue.textContent = `${currentStrokeWidth}px`;
                updateStrokeWidthControls(); // Sync all controls
                saveUiSettings();
            });
            wandPencilSlider.addEventListener('input', (e) => {
                currentStrokeWidth = parseInt(e.target.value);
                wandPencilSliderValue.textContent = `${currentStrokeWidth}px`;
                updateStrokeWidthControls(); // Sync all controls
                saveUiSettings();
            });
            // --- END NEW ---

            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tool = btn.id.replace('-tool', '');
                    if (tool === 'wet-paint') {
                        toggleWetPaint();
                        return;
                    }
                    if (tool === 'water-mix') {
                        toggleWaterMix();
                        return;
                    }
                    if (tool === 'glossy-effect') {
                        toggleGlossyEffect();
                        return;
                    }
                    if (tool === 'glitter-effect') {
                        toggleGlitterEffect();
                        return;
                    }
                    if (tool === 'color-picker') {
                        activateColorPicker()
                            .then(() => {
                                switchTool('color-picker');
                            })
                            .catch(err => console.error("Color picker activation failed:", err));
                    } else {
                        switchTool(tool);
                    }
                });
            });

            // --- Color Filter Functions ---
            function getFilterCSS(filterType) {
                switch (filterType) {
                    case 'sepia':
                        return 'sepia(100%)';
                    case 'vintage':
                        return 'sepia(40%) saturate(80%) contrast(90%) brightness(95%)';
                    case 'teal-orange':
                        // Teal & Orange effect using color matrix and split toning approximation
                        return 'sepia(20%) saturate(120%) hue-rotate(180deg) contrast(110%)';
                    case 'luminosity':
                        const saturation = parseInt(luminositySaturationSlider.value) || 100;
                        const vibrance = parseInt(luminosityVibranceSlider.value) || 100;
                        // Approximate vibrance with saturation adjustments
                        const satValue = saturation / 100;
                        const vibAdjust = (vibrance - 100) / 100;
                        return `saturate(${satValue + vibAdjust * 0.3}) contrast(${100 + vibAdjust * 5}%)`;
                    default:
                        return 'none';
                }
            }

            function applyColorFilter() {
                if (!filterEnabled || currentColorFilter === 'none') {
                    // Remove filter from all image layers
                    if (referenceImage) referenceImage.style.filter = 'none';
                    if (colorPickerImage) colorPickerImage.style.filter = 'none';
                    if (refModeImage) refModeImage.style.filter = 'none';
                    // Remove filter from all fill paths (paths with fill but no stroke or stroke="none")
                    drawingLayer.querySelectorAll('path[fill]').forEach(path => {
                        const stroke = path.getAttribute('stroke');
                        // Only remove filter from fill paths, not pencil strokes
                        if (!stroke || stroke === 'none') {
                            path.style.filter = 'none';
                        }
                    });
                    return;
                }

                const filterCSS = getFilterCSS(currentColorFilter);

                // Apply filter to image layers (but not to drawingLayer which contains pencil strokes)
                if (referenceImage) referenceImage.style.filter = filterCSS;
                if (colorPickerImage) colorPickerImage.style.filter = filterCSS;
                if (refModeImage) refModeImage.style.filter = filterCSS;
                // Apply filter to all fill paths (paths with fill attribute that aren't pencil strokes)
                drawingLayer.querySelectorAll('path[fill]').forEach(path => {
                    const stroke = path.getAttribute('stroke');
                    // Only apply to fill paths, not pencil strokes
                    // Pencil strokes have stroke attribute with a color value
                    if (!stroke || stroke === 'none') {
                        path.style.filter = filterCSS;
                    }
                });
            }

            function toggleColorFilter(enable) {
                filterEnabled = enable;
                applyColorFilter();
            }

            // Color Filter Event Listeners
            colorFilterSelect.addEventListener('change', (e) => {
                currentColorFilter = e.target.value;
                luminosityControls.classList.toggle('hidden', currentColorFilter !== 'luminosity');
                // Enable filter by default when a filter type is selected (unless selection tool is active)
                if (currentColorFilter !== 'none' && currentTool !== 'magic-wand') {
                    filterEnabled = true;
                    applyColorFilter();
                } else if (currentColorFilter === 'none') {
                    filterEnabled = false;
                    applyColorFilter();
                }
                saveUiSettings();
            });

            luminositySaturationSlider.addEventListener('input', (e) => {
                luminositySaturationValue.textContent = e.target.value;
                if (filterEnabled && currentColorFilter === 'luminosity') {
                    applyColorFilter();
                }
                saveUiSettings();
            });

            luminosityVibranceSlider.addEventListener('input', (e) => {
                luminosityVibranceValue.textContent = e.target.value;
                if (filterEnabled && currentColorFilter === 'luminosity') {
                    applyColorFilter();
                }
                saveUiSettings();
            });

            magicWandToolBtn.addEventListener('click', () => {
                // Turn off filter when magic wand is clicked
                toggleColorFilter(false);
                switchTool('magic-wand');
            });

            // --- NEW: Function to detect all closed shapes formed by black outlines ---
            async function detectAllClosedShapes() {
                if (!referenceImage) {
                    showToast('No reference image loaded');
                    return;
                }

                loader.classList.remove('hidden');

                try {
                    // Get the rendered image data
                    const imageData = await getRenderedSvgImageData();
                    const { data, width, height } = imageData;

                    // First pass: detect all black/dark outline pixels (like Wand 2)
                    const outlineMask = new Uint8Array(width * height);
                    for (let i = 0; i < width * height; i++) {
                        // Use a slightly more generous threshold for global detection
                        if (isBlackBoundary(data, i, width, height, 55)) {
                            outlineMask[i] = 1;
                        }
                    }

                    // Create inverse mask: areas that are NOT outlines
                    const areaMask = new Uint8Array(width * height);
                    for (let i = 0; i < width * height; i++) {
                        areaMask[i] = outlineMask[i] === 1 ? 0 : 1;
                    }

                    // Find all enclosed areas using flood fill
                    const visited = new Uint8Array(width * height);
                    const allShapesMask = new Uint8Array(width * height);
                    const shapes = [];

                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;

                            // Skip if already visited, is outline, or is transparent
                            if (visited[idx] === 1 || outlineMask[idx] === 1 || data[idx * 4 + 3] <= 128) continue;

                            // Flood fill to find this enclosed area
                            const shapePixels = [];
                            const stack = [[x, y]];
                            let minX = width, minY = height, maxX = 0, maxY = 0;
                            let hasShape = false;

                            while (stack.length > 0) {
                                const [cx, cy] = stack.pop();
                                const cidx = cy * width + cx;

                                if (cx < 0 || cx >= width || cy < 0 || cy >= height || visited[cidx] === 1) continue;

                                // Skip if this is an outline pixel
                                if (outlineMask[cidx] === 1) continue;

                                // Skip if transparent
                                if (data[cidx * 4 + 3] <= 128) continue;

                                visited[cidx] = 1;
                                shapePixels.push(cidx);
                                hasShape = true;

                                // Track bounds
                                if (cx < minX) minX = cx;
                                if (cx > maxX) maxX = cx;
                                if (cy < minY) minY = cy;
                                if (cy > maxY) maxY = cy;

                                // Add neighbors to stack
                                stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                            }

                            // If we found a shape with significant area, add it
                            if (hasShape && shapePixels.length > 50) { // Minimum area threshold
                                shapes.push({
                                    pixels: shapePixels,
                                    bounds: { x: minX, y: minY, width: maxX - minX + 1, height: maxY - minY + 1 },
                                    centerX: (minX + maxX) / 2,
                                    centerY: (minY + maxY) / 2
                                });

                                // Mark these pixels in the overall mask
                                shapePixels.forEach(pixelIdx => {
                                    allShapesMask[pixelIdx] = 1;
                                });
                            }
                        }
                    }

                    if (shapes.length > 0) {
                        // Set the selection mask
                        selectionMask = allShapesMask;
                        outlineSelectionMask = outlineMask; // Store outline mask for reference
                        selectionMaskWidth = width;
                        selectionMaskHeight = height;
                        currentSelectionType = 'multi-wand';

                        // Calculate overall bounds
                        let overallMinX = width, overallMinY = height, overallMaxX = 0, overallMaxY = 0;
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (selectionMask[y * width + x] === 1) {
                                    if (x < overallMinX) overallMinX = x;
                                    if (x > overallMaxX) overallMaxX = x;
                                    if (y < overallMinY) overallMinY = y;
                                    if (y > overallMaxY) overallMaxY = y;
                                }
                            }
                        }

                        selectionBounds = { x: overallMinX, y: overallMinY, width: overallMaxX - overallMinX + 1, height: overallMaxY - overallMinY + 1 };
                        selectionViewBox = { ...viewBox };

                        // Generate selection path for visual feedback
                        generateSelectionPath(selectionMask, selectionMaskWidth, selectionMaskHeight);

                        // Compute components for individual shape handling
                        const result = computeSelectionComponents(selectionMask, selectionMaskWidth, selectionMaskHeight);
                        if (result) {
                            selectionComponentLabels = result.labels;
                            selectionComponentCount = result.count;
                        }

                        // Show marching ants
                        startMarchingAnts();
                        deselectBtn.classList.remove('hidden');
                        if (shortcutSelectionVisibilityBtn) shortcutSelectionVisibilityBtn.classList.remove('hidden');

                        // Turn on filter if active
                        if (currentColorFilter !== 'none') {
                            toggleColorFilter(true);
                        }

                        // Enable Wand 2 settings since we're working with outlines
                        forceBlackStrokeEnabled = true;
                        if (forceBlackStrokeToggle) forceBlackStrokeToggle.checked = true;

                        // Auto-disable auto color pick mode
                        autoColorPickMode = false;
                        if (autoColorPickToggle) autoColorPickToggle.checked = false;

                        showToast(`Detected ${shapes.length} closed shapes from outlines`);

                        // Auto-switch to pencil 2 for outline-based coloring
                        switchTool('pencil-2');

                        // Enable snap to outline
                        snapToOutlineEnabled = true;
                        if (snapToggle) {
                            snapToggle.checked = true;
                        }
                        if (snapStrengthContainer) {
                            snapStrengthContainer.style.display = 'block';
                        }
                    } else {
                        showToast('No closed shapes detected from outlines');
                    }

                } catch (error) {
                    console.error('Error detecting closed shapes:', error);
                    showToast('Failed to detect closed shapes');
                } finally {
                    loader.classList.add('hidden');
                }
            }

            // Multi-Wand Toggle Event Listener
            multiWandToggleBtn.addEventListener('click', () => {
                multiWandMode = !multiWandMode;
                multiWandToggleBtn.classList.toggle('active', multiWandMode);

                if (multiWandMode) {
                    // Auto-detect all closed shapes when enabling multi-wand
                    detectAllClosedShapes();
                    showToast('Multi-Wand Mode ON - All closed shapes from outlines selected');
                } else {
                    showToast('Multi-Wand Mode OFF');
                    deselect();
                    // Clear any ongoing long press timer
                    if (multiWandLongPressTimer) {
                        clearTimeout(multiWandLongPressTimer);
                        multiWandLongPressTimer = null;
                    }
                }
            });
            // NEW: Wand 2 Shortcut
            const shortcutWand2Btn = document.getElementById('shortcut-wand-2-btn');
            if (shortcutWand2Btn) {
                shortcutWand2Btn.addEventListener('click', () => {
                    toggleColorFilter(false);
                    switchTool('magic-wand-2');
                    // Update active state
                    document.querySelectorAll('.tool-shortcut-btn').forEach(btn => btn.classList.remove('active'));
                    shortcutWand2Btn.classList.add('active');
                });
            }

            // NEW: Eyedropper Shortcut
            const shortcutEyedropperBtn = document.getElementById('shortcut-eyedropper-btn');
            if (shortcutEyedropperBtn) {
                shortcutEyedropperBtn.addEventListener('click', async () => {
                    if (!window.EyeDropper) {
                        showToast("Your browser does not support the EyeDropper API.", true);
                        return;
                    }
                    try {
                        const eyeDropper = new EyeDropper();
                        const result = await eyeDropper.open();
                        if (result && result.sRGBHex) {
                            selectColor(result.sRGBHex);
                            showToast(`Color picked: ${result.sRGBHex}`);
                        }
                    } catch (e) {
                        // User cancelled or error
                        console.log("EyeDropper closed or failed", e);
                    }
                });
            }


            paintBucketToolBtn.addEventListener('click', () => switchTool('paint-bucket'));
            wandToggleBtn.addEventListener('click', (e) => {
                if (hasWandBtnMoved) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                // Turn off filter when wand toggle is clicked
                toggleColorFilter(false);
                switchTool('magic-wand');
            });
            toleranceSlider.addEventListener('input', (e) => {
                toleranceValue.textContent = e.target.value;
                saveUiSettings();
            });
            allColorToleranceSlider.addEventListener('input', (e) => {
                allColorToleranceValue.textContent = e.target.value;
                saveUiSettings();
            });

            // Fill shrink slider event listeners
            paintBucketShrinkSlider.addEventListener('input', (e) => {
                fillShrinkAmount = parseInt(e.target.value);
                paintBucketShrinkValue.textContent = `${fillShrinkAmount}px`;
                saveUiSettings();
            });

            paintBucketShrinkMinusBtn.addEventListener('click', () => {
                const newValue = Math.max(-5, parseInt(paintBucketShrinkSlider.value) - 1);
                paintBucketShrinkSlider.value = newValue;
                fillShrinkAmount = newValue;
                paintBucketShrinkValue.textContent = `${fillShrinkAmount}px`;
                saveUiSettings();
            });

            paintBucketShrinkPlusBtn.addEventListener('click', () => {
                const newValue = Math.min(10, parseInt(paintBucketShrinkSlider.value) + 1);
                paintBucketShrinkSlider.value = newValue;
                fillShrinkAmount = newValue;
                paintBucketShrinkValue.textContent = `${fillShrinkAmount}px`;
                saveUiSettings();
            });

            // Zero opacity strokes toggle
            zeroOpacityStrokesToggle.addEventListener('change', (e) => {
                zeroOpacityStrokesEnabled = e.target.checked;
                // Update all existing pencil strokes to have zero opacity if enabled
                if (zeroOpacityStrokesEnabled) {
                    drawingLayer.querySelectorAll('path[stroke]').forEach(path => {
                        if (!path.hasAttribute('data-temp-stroke')) {
                            // Save original opacity if not already saved
                            if (!path.hasAttribute('data-original-opacity')) {
                                const currentOpacity = path.getAttribute('stroke-opacity') || currentStrokeOpacity.toString();
                                path.setAttribute('data-original-opacity', currentOpacity);
                            }
                            path.setAttribute('stroke-opacity', '0');
                        }
                    });
                } else {
                    // Restore original opacity from data-original-opacity attribute or use currentStrokeOpacity
                    drawingLayer.querySelectorAll('path[stroke]').forEach(path => {
                        if (!path.hasAttribute('data-temp-stroke')) {
                            const savedOpacity = path.getAttribute('data-original-opacity');
                            if (savedOpacity !== null) {
                                path.setAttribute('stroke-opacity', savedOpacity);
                            } else {
                                path.setAttribute('stroke-opacity', currentStrokeOpacity.toString());
                            }
                        }
                    });
                }
                addHistoryState('drawing');
                saveUiSettings();
            });
            deselectBtn.addEventListener('click', deselect);

            // --- NEW Un-pick Button Listener ---
            unpickColorBtn.addEventListener('click', () => {
                deactivateColorPicker();
                switchTool('pencil');
            });

            colorRefOpacitySlider.addEventListener('input', (e) => {
                if (colorPickerImage) {
                    colorPickerImage.setAttribute('opacity', e.target.value);
                    // NEW: Update state for history
                    colorRefImageState.opacity = parseFloat(e.target.value);
                    activeImageType = 'colorRefImage';
                    updatePinButtonState();
                }
                // Also update ref mode image opacity if enabled
                if (refModeEnabled && refModeImage) {
                    refModeImage.setAttribute('opacity', e.target.value);
                }
            });

            // Ref Mode Toggle Event Listener
            refModeToggle.addEventListener('change', (e) => {
                refModeEnabled = e.target.checked;
                if (refModeEnabled) {
                    enableRefMode();
                } else {
                    disableRefMode();
                }
            });

            // --- Project Listeners ---
            saveProjectBtn.addEventListener('click', () => handleSaveProject(false, false));
            manageProjectsBtn.addEventListener('click', handleOpenProjectsModal);

            // Clear Cache Button
            if (clearCacheBtn) {
                clearCacheBtn.addEventListener('click', () => {
                    if (confirm('Clear all cached data for this project? This will force recalculation of wand selections, fills, and other cached operations. The cache will be cleared and saved with the project.')) {
                        clearCache();
                        // Save project to update cache
                        if (currentProjectId) {
                            handleSaveProject(false, true); // Silent save
                        }
                        showToast('Cache cleared successfully.');
                    }
                });
            }

            // Reset App Button
            if (resetAppBtn) {
                resetAppBtn.addEventListener('click', () => {
                    resetApp();
                });
            }

            // NEW: Delete Temp Strokes Button
            if (deleteTempStrokesBtn) {
                deleteTempStrokesBtn.addEventListener('click', () => {
                    const tempStrokes = drawingLayer.querySelectorAll('path[data-temp-stroke]');
                    let count = 0;
                    tempStrokes.forEach(path => {
                        path.remove();
                        count++;
                    });
                    if (count > 0) {
                        showToast(`Deleted ${count} temporary strokes.`);
                    } else {
                        showToast('No temporary strokes found.');
                    }
                });
            }

            // NEW: Export Project as JSON file
            exportProjectBtn.addEventListener('click', () => {
                try {
                    const projectData = gatherProjectData();
                    // Remove ID so it can be imported as a new project
                    delete projectData.id;
                    const jsonData = JSON.stringify(projectData, null, 2);
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${currentProjectName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_project.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`Project "${currentProjectName}" exported successfully!`);
                } catch (error) {
                    console.error('Error exporting project:', error);
                    showToast('Error exporting project.', true);
                }
            });

            // NEW: Import Project from JSON file
            importProjectBtn.addEventListener('click', () => {
                projectFileUpload.click();
            });

            projectFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                if (!file.name.toLowerCase().endsWith('.json')) {
                    showToast('Please select a valid project JSON file.', true);
                    projectFileUpload.value = '';
                    return;
                }

                loader.classList.remove('hidden');
                const reader = new FileReader();

                reader.onload = async (event) => {
                    try {
                        const jsonText = event.target.result;
                        const projectData = JSON.parse(jsonText);

                        // Validate project data structure
                        if (!projectData.name || !projectData.svgContent) {
                            throw new Error('Invalid project file format.');
                        }

                        // Show confirmation dialog
                        const confirmed = confirm(`Import project "${projectData.name}"? This will replace your current work.`);
                        if (!confirmed) {
                            loader.classList.add('hidden');
                            projectFileUpload.value = '';
                            return;
                        }

                        // Apply the imported project
                        applyProjectData(projectData);

                        // Save as new project in database
                        projectData.lastModified = new Date();
                        delete projectData.id; // Remove ID so it's saved as new project
                        const savedId = await saveProjectToDB(projectData);
                        currentProjectId = savedId;
                        // Invalidate cache to refresh project list
                        cachedProjects = null;

                        showToast(`Project "${projectData.name}" imported successfully!`);
                        loader.classList.add('hidden');
                        projectFileUpload.value = '';

                    } catch (error) {
                        console.error('Error importing project:', error);
                        showToast('Error importing project. Invalid file format.', true);
                        loader.classList.add('hidden');
                        projectFileUpload.value = '';
                    }
                };

                reader.onerror = () => {
                    showToast('Error reading project file.', true);
                    loader.classList.add('hidden');
                    projectFileUpload.value = '';
                };

                reader.readAsText(file);
            });
            closeProjectsModalBtn.addEventListener('click', () => {
                projectsModal.classList.add('hidden');
                projectsModal.classList.remove('flex');
            });

            autosaveIntervalInput.addEventListener('change', setupAutoSave);

            // --- NEW: Glitter Settings Event Listeners ---
            if (glitterDensitySlider) {
                glitterDensitySlider.addEventListener('input', (e) => {
                    glitterDensity = parseFloat(e.target.value);
                    if (glitterDensityValue) glitterDensityValue.textContent = glitterDensity.toFixed(2);
                    updateGlitterFilters();
                    saveUiSettings();
                });
            }

            if (glitterSizeSlider) {
                glitterSizeSlider.addEventListener('input', (e) => {
                    glitterSize = parseFloat(e.target.value);
                    if (glitterSizeValue) glitterSizeValue.textContent = glitterSize.toFixed(1);
                    updateGlitterFilters();
                    saveUiSettings();
                });
            }

            if (glitterStarCountSlider) {
                glitterStarCountSlider.addEventListener('input', (e) => {
                    glitterStarCount = parseFloat(e.target.value);
                    if (glitterStarCountValue) glitterStarCountValue.textContent = glitterStarCount.toFixed(2);
                    updateGlitterFilters();
                    saveUiSettings();
                });
            }
            newProjectBtn.addEventListener('click', () => { handleNewProject(); });
            saveAsBtn.addEventListener('click', () => { handleSaveProject(true, false); });

            cancelSaveNameBtn.addEventListener('click', () => projectNameModal.classList.add('hidden'));
            projectNameInput.addEventListener('keydown', e => { if (e.key === 'Enter') confirmSaveNameBtn.click(); });

            // Wet Paint Shadow Sliders
            document.getElementById('wp-outer-shadow-size').addEventListener('input', (e) => {
                wetPaintOuterShadowSize = parseFloat(e.target.value);
                document.getElementById('wp-outer-shadow-size-val').textContent = wetPaintOuterShadowSize.toFixed(1);
                clearCache('wetPaint');
                // We need to clear existing wet paint filters in defs to force regeneration
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="wet-paint-stroke-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });
            document.getElementById('wp-outer-shadow-blur').addEventListener('input', (e) => {
                wetPaintOuterShadowBlur = parseFloat(e.target.value);
                document.getElementById('wp-outer-shadow-blur-val').textContent = wetPaintOuterShadowBlur.toFixed(2);
                clearCache('wetPaint');
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="wet-paint-stroke-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });
            document.getElementById('wp-inner-shadow-size').addEventListener('input', (e) => {
                wetPaintInnerShadowSize = parseFloat(e.target.value);
                document.getElementById('wp-inner-shadow-size-val').textContent = wetPaintInnerShadowSize.toFixed(1);
                clearCache('wetPaint');
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="wet-paint-stroke-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });
            document.getElementById('wp-inner-shadow-blur').addEventListener('input', (e) => {
                wetPaintInnerShadowBlur = parseFloat(e.target.value);
                document.getElementById('wp-inner-shadow-blur-val').textContent = wetPaintInnerShadowBlur.toFixed(2);
                clearCache('wetPaint');
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="wet-paint-stroke-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });

            // Water Mix Shadow Sliders
            document.getElementById('wm-shadow-size').addEventListener('input', (e) => {
                waterMixShadowSize = parseFloat(e.target.value);
                document.getElementById('wm-shadow-size-val').textContent = waterMixShadowSize.toFixed(1);
                // Clear existing water mix filters to force regeneration
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });
            document.getElementById('wm-shadow-blur').addEventListener('input', (e) => {
                waterMixShadowBlur = parseFloat(e.target.value);
                document.getElementById('wm-shadow-blur-val').textContent = waterMixShadowBlur.toFixed(2);
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });
            document.getElementById('wm-shadow-opacity').addEventListener('input', (e) => {
                waterMixShadowOpacity = parseFloat(e.target.value);
                document.getElementById('wm-shadow-opacity-val').textContent = waterMixShadowOpacity.toFixed(2);
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });
            document.getElementById('wm-mix-strength').addEventListener('input', (e) => {
                waterMixStrength = parseFloat(e.target.value);
                document.getElementById('wm-mix-strength-val').textContent = waterMixStrength.toFixed(2);
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });

            document.getElementById('wm-highlight-toggle').addEventListener('change', (e) => {
                waterMixHighlightEnabled = e.target.checked;
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });

            document.getElementById('wm-highlight-opacity').addEventListener('input', (e) => {
                waterMixHighlightOpacity = parseFloat(e.target.value);
                document.getElementById('wm-highlight-opacity-val').textContent = waterMixHighlightOpacity.toFixed(2);
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });

            document.getElementById('wm-highlight-size').addEventListener('input', (e) => {
                waterMixHighlightSize = parseFloat(e.target.value);
                document.getElementById('wm-highlight-size-val').textContent = waterMixHighlightSize.toFixed(1);
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });

            document.getElementById('wm-highlight-blur').addEventListener('input', (e) => {
                waterMixHighlightBlur = parseFloat(e.target.value);
                document.getElementById('wm-highlight-blur-val').textContent = waterMixHighlightBlur.toFixed(2);
                if (defs) {
                    const existingFilters = defs.querySelectorAll('[id^="water-mix-filter-"]');
                    existingFilters.forEach(f => f.remove());
                }
                saveUiSettings();
            });

            initialSetup();

            // --- PERFORMANCE OPTIMIZATION: Periodic Memory Cleanup ---
            // Run memory check every 30 seconds during active use
            memoryCheckInterval = setInterval(() => {
                SmartMemory.checkMemory();
            }, 30000); // 30 seconds

            // --- CLEANUP: Handle page unload and visibility changes ---
            const handleCleanup = () => {
                // Cancel all animation frames
                if (pathUpdateRafId) {
                    cancelAnimationFrame(pathUpdateRafId);
                    pathUpdateRafId = null;
                }
                if (antsAnimationId) {
                    cancelAnimationFrame(antsAnimationId);
                    antsAnimationId = null;
                }

                // Clear intervals
                if (memoryCheckInterval) {
                    clearInterval(memoryCheckInterval);
                    memoryCheckInterval = null;
                }
                if (autoSaveIntervalId) {
                    clearInterval(autoSaveIntervalId);
                    autoSaveIntervalId = null;
                }

                // Clear all timeouts
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                // Run cleanup functions
                cleanupFunctions.forEach(fn => {
                    try {
                        fn();
                    } catch (e) {
                        console.warn('Cleanup function error:', e);
                    }
                });

                // Aggressive memory cleanup on unload
                SmartMemory.cleanup();

                // Clear large data structures
                points = [];
                cachedShrunkMask = null;

                // Remove event listeners (those we track)
                // Note: Browser will clean up most listeners on page unload, but we clean up explicitly
            };

            // Cleanup on page unload
            window.addEventListener('beforeunload', (e) => {
                handleCleanup();
            });

            // Cleanup on page visibility change (when tab becomes hidden)
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // Perform memory cleanup when tab becomes hidden
                    SmartMemory.checkMemory();
                } else {
                    // Resume periodic memory checks when tab becomes visible
                    if (!memoryCheckInterval) {
                        memoryCheckInterval = setInterval(() => {
                            SmartMemory.checkMemory();
                        }, 30000);
                    }
                }
            });

            // Cleanup on pagehide (mobile browsers)
            window.addEventListener('pagehide', () => {
                handleCleanup();
            });

            // Ensure shortcuts are visible on mobile/tablet on initial load
            setTimeout(() => {
                updateCanvasOverlays();
            }, 100);

            // --- FULLSCREEN HEADER AUTO-HIDE FUNCTIONALITY ---
            const header = document.querySelector('header');
            let lastScrollY = 0;
            let headerHideTimeout = null;
            let isHeaderVisible = true;

            function showHeader() {
                if (header && !isHeaderVisible) {
                    header.style.transform = 'translateY(0)';
                    header.style.opacity = '1';
                    isHeaderVisible = true;
                }
            }

            function hideHeader() {
                if (header && isHeaderVisible) {
                    header.style.transform = 'translateY(-100%)';
                    header.style.opacity = '0';
                    isHeaderVisible = false;
                }
            }

            function resetHeaderHideTimer() {
                clearTimeout(headerHideTimeout);
                showHeader();
                headerHideTimeout = setTimeout(() => {
                    hideHeader();
                }, 3000); // Hide after 3 seconds of inactivity
            }

            // Add transition to header
            if (header) {
                header.style.transition = 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out';
            }

            // Show header when mouse is near top of screen
            document.addEventListener('mousemove', (e) => {
                if (e.clientY < 50) {
                    resetHeaderHideTimer();
                }
            });

            // Show header on touch/scroll events (swipe down gesture)
            let touchStartY = 0;
            document.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            });

            document.addEventListener('touchmove', (e) => {
                const touchY = e.touches[0].clientY;
                const deltaY = touchY - touchStartY;

                // Swipe down gesture
                if (deltaY > 30 && touchStartY < 100) {
                    resetHeaderHideTimer();
                }
            });

            // Hide header when clicking on canvas
            if (canvasContainer) {
                canvasContainer.addEventListener('pointerdown', () => {
                    clearTimeout(headerHideTimeout);
                    headerHideTimeout = setTimeout(() => {
                        hideHeader();
                    }, 1500);
                });
            }

            // Start auto-hide timer on initial load
            resetHeaderHideTimer();
            // --- NEW: Keyboard Shortcuts ---
            window.addEventListener('keydown', (e) => {
                // Ignore if in input/textarea
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

                // Ignore shortcuts if modifiers are pressed
                if (e.ctrlKey || e.metaKey || e.altKey) return;

                const key = e.key.toLowerCase();

                switch (key) {
                    case 'f':
                        const paletteToggle = document.getElementById('floating-color-palette-toggle');
                        if (paletteToggle) {
                            paletteToggle.click();
                            showToast('Color Palette');
                        }
                        break;
                    case 'g':
                        const bucket = document.getElementById('paint-bucket-tool');
                        if (bucket) {
                            bucket.click();
                            showToast('Fill Bucket Tool');
                        }
                        break;
                    case 'h':
                        const pencil = document.getElementById('pencil-tool');
                        if (pencil) {
                            pencil.click();
                            showToast('Pencil Tool');
                        }
                        break;
                    case 'w':
                        const wand1 = document.getElementById('magic-wand-tool');
                        if (wand1) {
                            wand1.click();
                            showToast('Magic Wand Tool');
                        }
                        break;
                    case 'e':
                        const wand2 = document.getElementById('magic-wand-2-tool');
                        if (wand2) {
                            wand2.click();
                            showToast('Wand 2 Tool');
                        }
                        break;
                    case 'p':
                        const panTool = document.getElementById('pan-tool');
                        if (panTool) {
                            panTool.click();
                            showToast('Pan/Zoom Tool');
                        }
                        break;
                    case 'j':
                        const screenPicker = document.getElementById('shortcut-eyedropper-btn');
                        if (screenPicker) {
                            screenPicker.click();
                            showToast('Screen Color Picker');
                        }
                        break;
                    case 's': // NEW: Shade Mode Shortcut
                        if (shortcutShadeBtn) {
                            shortcutShadeBtn.click();
                        }
                        break;
                }
            });

            // --- Shade Mode Event Listeners ---
            if (shortcutShadeBtn) {
                shortcutShadeBtn.addEventListener('click', () => {
                    const nextMode = !isShadeMode;

                    if (nextMode) {
                        // 1. Take snapshot of General settings FIRST while isShadeMode is still false
                        saveCurrentSettings('main');

                        isShadeMode = true; // Now activate Shade Mode

                        // NEW: Auto-disable filters in Shade Mode
                        wetPaintEnabled = false;
                        waterMixEnabled = false;
                        glitterEffectEnabled = false;

                        const wpBtnShade = document.getElementById('wet-paint-tool');
                        const wmBtnShade = document.getElementById('water-mix-tool');
                        const glBtnShade = document.getElementById('glitter-effect-tool');

                        if (wpBtnShade) wpBtnShade.classList.remove('active');
                        if (wmBtnShade) wmBtnShade.classList.remove('active');
                        if (glBtnShade) glBtnShade.classList.remove('active');

                        updateEffectSettingsVisibility();

                        // 2. Backup color and darken it
                        mainColorBackup = selectedBaseColor;
                        const darkenAmt = shadeSettings.darkenAmount || 0.2;
                        const darkColor = getDarkenedColor(mainColorBackup, darkenAmt);
                        selectColor(darkColor);

                        // 3. Apply Shade specifics (but don't show floating panel)
                        restoreCurrentSettings('shade');
                        if (shadeDarkenContainer) {
                            shadeDarkenContainer.classList.remove('hidden');
                            const currentVal = Math.round((shadeSettings.darkenAmount || 0.2) * 100);
                            if (shadeDarkenSlider) shadeDarkenSlider.value = currentVal;
                            if (shadeDarkenValue) shadeDarkenValue.textContent = `${currentVal}%`;
                        }
                        showToast("Shade Mode Active");
                    } else {
                        // Deactivating
                        saveCurrentSettings('shade');
                        isShadeMode = false;

                        if (mainColorBackup) {
                            selectColor(mainColorBackup);
                            mainColorBackup = null;
                        }

                        restoreCurrentSettings('main');
                        if (shadeDarkenContainer) shadeDarkenContainer.classList.add('hidden');
                        showToast("Shade Mode Deactivated");
                    }

                    shortcutShadeBtn.classList.toggle('active', isShadeMode);
                    saveUiSettings();
                });
            }

            // --- Wet Paint, Water Mix, and Glitter Shortcut Event Listeners ---
            if (shortcutWetPaintBtn) {
                shortcutWetPaintBtn.addEventListener('click', () => {
                    if (wetPaintToolBtn) {
                        wetPaintToolBtn.click();
                    }
                });
            }

            if (shortcutWaterMixBtn) {
                shortcutWaterMixBtn.addEventListener('click', () => {
                    if (waterMixToolBtn) {
                        waterMixToolBtn.click();
                    }
                });
            }

            if (shortcutGlitterBtn) {
                shortcutGlitterBtn.addEventListener('click', () => {
                    if (glitterEffectToolBtn) {
                        glitterEffectToolBtn.click();
                    }
                });
            }

            if (shortcutDisableFiltersBtn) {
                shortcutDisableFiltersBtn.addEventListener('click', () => {
                    let filtersDisabled = false;

                    if (wetPaintEnabled) {
                        wetPaintEnabled = false;
                        if (wetPaintToolBtn) wetPaintToolBtn.classList.remove('active');
                        filtersDisabled = true;
                    }

                    if (waterMixEnabled) {
                        waterMixEnabled = false;
                        if (waterMixToolBtn) waterMixToolBtn.classList.remove('active');
                        filtersDisabled = true;
                    }

                    if (glitterEffectEnabled) {
                        glitterEffectEnabled = false;
                        if (glitterEffectToolBtn) glitterEffectToolBtn.classList.remove('active');
                        filtersDisabled = true;
                    }

                    if (filtersDisabled) {
                        updateEffectSettingsVisibility();
                        showToast("All active filters disabled.");
                        saveUiSettings();
                    } else {
                        showToast("No active filters to disable.");
                    }
                });
            }

            shadeOpacitySlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                shadeOpacityValue.textContent = val.toFixed(2);
                if (isShadeMode) {
                    currentStrokeOpacity = val;
                    if (strokeOpacitySlider) {
                        strokeOpacitySlider.value = val;
                        strokeOpacityValue.textContent = val.toFixed(2);
                    }
                    saveUiSettings();
                }
            });

            shadeWidthSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                shadeWidthValue.textContent = `${val}px`;
                if (isShadeMode) {
                    currentStrokeWidth = val;
                    if (strokeWidthSlider) {
                        strokeWidthSlider.value = val;
                        strokeWidthValue.textContent = `${val}px`;
                    }
                    if (bottomLeftStrokeWidthValue) {
                        bottomLeftStrokeWidthValue.textContent = `${Math.round(val)}px`;
                    }
                    if (wandPencilSlider) {
                        wandPencilSlider.value = val;
                        wandPencilSliderValue.textContent = `${val}px`;
                    }
                    saveUiSettings();
                }
            });

            shadeSmoothnessSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                shadeSmoothnessValue.textContent = val.toFixed(1);
                if (isShadeMode) {
                    pathTolerance = val;
                    if (simplifySlider) {
                        simplifySlider.value = val;
                        simplifyValue.textContent = val.toFixed(1);
                    }
                    saveUiSettings();
                }
            });
            // NEW: Auto-Restore Shade Mode if saved
            if (window.restoreShadeModeOnLoad && shortcutShadeBtn) {
                setTimeout(() => {
                    if (!isShadeMode) {
                        shortcutShadeBtn.click();
                        showToast("Restored Shade Mode");
                    }
                }, 500);
            }
        });
    </script>
</body>

</html>
